# (APPENDIX) 附录 {#appendix .unnumbered}

# Sharing your book

```{r setup-appendix, echo=FALSE}
source(file = "_common.R")
sysfonts::font_add_google(name = "Noto Sans")
sysfonts::font_add_google(name = "Noto Serif SC")
```

https://github.com/XiangyunHuang/masr/issues/19

首先简单回顾一下什么是区间估计？

关于置信区间，学校和教科书里，老师让我们记住二者的差别，可是差别究竟是什么？为什么要采纳第一种说法而不是第二种呢？

两种说法：$1-\alpha$ 的把握确定区间包含真值、区间包含真值的概率是 $1-\alpha$

关于区间估计，历史上 E. S. Pearson 和 R. A. Fisher 曾有过争论，

Clopper-Pearson 精确区间估计

1934 年 C. J. Clopper 和 E. S. Pearson 在给定置信水平 $1- \alpha = 0.95$ 和样本量 $n = 10$ 的情况下，给出二项分布 $B(n, p)$ 参数 $p$ 的置信带 [@Clopper1934]，如图 \@ref(fig:confidence-belt) 所示，横坐标为观测到的成功次数，纵坐标为参数 $p$ 的估计区间的上下界。举个例子，固定样本量为 10，假定观测到的成功次数为 2，在置信水平为 0.95 的情况下，Base R 内置的二项精确检验函数 `binom.test()`，可以获得参数 $p$ 的精确区间估计为 $(p_1, p_2) = (0.03, 0.55)$，即：

```{r}
# 精确二项检验
binom.test(x = 2, n = 10, p = 0.2)
```

在给定置信水平为 0.95，即 $\alpha = 0.05$，固定样本量 $n = 10$，观测到的成功次数 $x$ 可能为 $0,1,\cdots,10$，
对于给定的 $p$，不同 $x$ 值出现的机率由 $(p + q)^10$ 二项展开式的项给出，这里 $q = 1-p$，

二项分布有对称性，尾项之和应不超过 $\alpha/2$，最大的 $x$ 值可有如下方程给出

$$\sum_{r = x}^{n}\binom{n}{x}p^x(1-p)^{n-x} = \frac{\alpha}{2}$$
在给定 $p = 0.1$ 的情况下，二项分布的上分位点 $x = 3$，即

```{r}
qbinom(0.025, size = 10, prob = 0.1, lower.tail = F)
```

反过来，若已知上分位点为 $x = 3$，则概率 $p$ 为 $0.0127952$。

```{r}
pbinom(q = 3, size = 10, prob = 0.1, lower.tail = F)
```

(ref:confidence-belt) 给定置信水平 $1- \alpha = 0.95$ 和样本量 $n = 10$ 的情况下，二项分布参数 $p$ 的置信带。

(ref:confidence-belt-s) 二项分布 $\mathrm{Bin}(n,p)$ 参数 $p$ 的置信带

```{r confidence-belt, fig.cap="(ref:confidence-belt)", fig.scap="(ref:confidence-belt-s)", echo=FALSE, fig.width=5, fig.height=5, out.width='60%', fig.showtext=TRUE}
library(rootSolve) # uniroot.all
options(digits = 4)
# r 为上分位点
p_fun <- function(p, r = 9) qbinom(0.025, size = 10, prob = p, lower.tail = F) - r # 上分位点
l_fun <- function(p, r = 9) qbinom(0.025, size = 10, prob = p, lower.tail = T) - r # 下分位点

# 计算每个分位点对应的最小的概率 p
p <- sapply(0:10, function(x) min(uniroot.all(p_fun, lower = 0, upper = 1, r = x)))

# 计算每个分位点对应的最大的概率 l
l <- sapply(0:10, function(x) max(uniroot.all(l_fun, lower = 0, upper = 1, r = x)))

plot(
  x = seq(from = 0, to = 10, length.out = 11),
  y = seq(from = 0, to = 1, length.out = 11),
  type = "n", ann = FALSE, panel.first = grid(),
  family = "Noto Sans"
)
title(xlab = "成功次数", ylab = "比例", family = "Noto Serif SC")
lines(x = 0:10, y = p, type = "s") # 朝下的阶梯线
lines(x = 0:10, y = p, type = "l") # 折线
# points(x = 0:10, y = p, pch = 16, cex = .8) # 散点

# abline(a = 0, b = 0.1, col = "gray", lwd = 2, lty = 2) # 添加对称线
text(x = 5, y = 0.5, label = "置信带", cex = 1.5, srt = 45, family = "Noto Serif SC")
# points(x = 5, y = 0.5, col = "black", pch = 16) # 中心对称点
# points(x = 5, y = 0.5, col = "black", pch = 3) # 中心对称点

lines(x = 0:10, y = l, type = "S") # 朝上的阶梯线
lines(x = 0:10, y = l, type = "l") # 折线
# points(x = 0:10, y = l, pch = 16, cex = .8) # 散点

points(x = c(2, 2), y = c(0.03, 0.55), pch = 8, col = "black")
text(x = 2, y = 0.55, labels = "p2", pos = 1)
text(x = 2, y = 0.03, labels = "p1", pos = 3)
```


[Fisher 精确检验](https://en.wikipedia.org/wiki/Fisher's_exact_test)
