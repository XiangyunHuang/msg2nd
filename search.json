[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "现代统计图形（第二版）",
    "section": "",
    "text": "欢迎\n\n\n\n\n\n\n注意\n\n\n\n《现代统计图形》(赵鹏, 谢益辉, 和 黄湘云 2021) 因销量不错，出版社编辑对我们发出邀稿，本书是我独自对第二版的尝试。\n\n\n书中的代码字体采用美观的 Source Code Pro 字体， 为方便跨操作系统编译书籍电子版，正文的中文字体采用开源的 fandol 字体。 而本书图形中使用的 Noto 系列中英文字体来自 Google Fonts 字体库，分别是 Noto Sans 无衬线英文字体和 Noto Serif SC 宋体中文字体。 图 1 中的左、右子图分别展示 Base R 和 ggplot2 (Wickham 2016) 图形中中英文字体的效果。在图形中调用中文字体分两步走，先使用 sysfonts 包获取并注册 Noto 相关字体，然后在绘图的时候指定字体，并在代码块选项中启用 fig.showtext = TRUE，这样就能在 R Markdown 环境中优雅地绘制含中文的图形。如果在 R Console 中绘图则需加载 showtext 包，运行函数 showtext_auto()。\n\n代码\n# 准备 Noto 中英文字体\n# sysfonts::font_add_google(name = \"Noto Sans\", family = \"Noto Sans\")\n# sysfonts::font_add_google(name = \"Noto Serif SC\", family = \"Noto Serif CJK SC\")\n# 在 Base R 图形中使用 Noto 字体\nplot(pressure, type = \"b\", pch = 19, ann = FALSE, family = \"Noto Sans\")\ntitle(xlab = \"温度\", ylab = \"压力\", family = \"Noto Serif CJK SC\")\n# 在 ggplot2 图形中使用 Noto 字体\nlibrary(ggplot2)\nggplot(data = pressure, aes(x = temperature, y = pressure)) +\n  geom_line() +\n  geom_point(size = 2) +\n  labs(x = \"温度\", y = \"压力\") +\n  scale_x_continuous(breaks = seq(0, 400, by = 50)) +\n  theme_bw(base_size = 13) +\n  theme(\n    axis.title = element_text(family = \"Noto Serif CJK SC\"),\n    axis.title.x = element_text(\n      margin = margin(b = 0, l = 0, t = 20, r = 0)\n    ),\n    axis.title.y = element_text(\n      margin = margin(b = 0, l = 0, t = 0, r = 20)\n    ),\n    panel.border = element_rect(color = \"black\"),\n    panel.grid = element_blank(),\n    axis.ticks.length = unit(0.25, \"cm\"),\n    axis.text.x = element_text(\n      family = \"Noto Sans\", color = \"black\",\n      vjust = -1.5, size = rel(1.25)\n    ),\n    axis.text.y = element_text(\n      family = \"Noto Sans\", color = \"black\",\n      angle = 90, vjust = 1.5, hjust = 0.5,\n      size = rel(1.25)\n    )\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Base R 图形\n\n\n\n\n\n\n\n\n\n\n\n(b) ggplot2 图形\n\n\n\n\n\n\n\n图 1: 中英文字体设置\n\n\n\n图 2 是一幅手绘漫画风格的图形，展示了三种不同鸢尾花的萼片宽度和长度的关系。\n\n\n代码\n# brew tap homebrew/cask-fonts\n# brew install --cask font-xkcd\nif (xfun::is_macos()) {\n  sysfonts::font_add(\"xkcd\", regular = \"xkcd.otf\")\n} else {\n  sysfonts::font_add(\"xkcd\", regular = \"xkcd.ttf\")\n}\nggplot(data = iris, aes(Sepal.Length, Sepal.Width)) +\n  geom_point(aes(color = Species, shape = Species)) +\n  scale_color_grey() +\n  theme_bw(base_size = 13, base_family = \"xkcd\") +\n  theme(\n    panel.border = element_rect(color = \"black\"),\n    panel.grid = element_blank()\n  )\n\n\n\n\n\n\n\n\n图 2: 手绘漫画风格的图形\n\n\n\n\n\n如读者所见，本书不会局限于作图的工具，除了上面已经展示的 Base R 和 ggplot2，还会陆续用到 lattice (Sarkar 2008) 和 rgl 包，甚至会超出 R 语言的范畴，介绍 LaTeX 世界里的 TikZ 和 JavaScript 中的 WebGL 等。\n在掌握各类现代的绘图技术后，回归统计图形的落脚点，从数据传递的信息出发，选择合适的图形和实现工具，兼顾美观，到达「道」与「术」和谐统一的境界。\n\n\n\n\n\nSarkar, Deepayan. 2008. lattice: Multivariate Data Visualization with R. New York: Springer. http://lmdvr.r-forge.r-project.org.\n\n\nWickham, Hadley. 2016. ggplot2: Elegant Graphics for Data Analysis. 2nd 本. New York: Springer-Verlag. https://ggplot2-book.org/.\n\n\n赵鹏, 谢益辉, 和 黄湘云. 2021. 现代统计图形. 北京: 人民邮电出版社. https://bookdown.org/xiangyun/msg.",
    "crumbs": [
      "欢迎"
    ]
  },
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "前言",
    "section": "",
    "text": "既然是《现代统计图形》的第二版，和第一版的主要区别是什么？目标读者是否一样？\n我在本书每个章节开头都会给一条名人名言，不要笑，生活已经很苦了，写书让我感到快乐和慰藉。这些名人名言伴随了我心路成长的历程。\n我们希望目标读者学过一点微积分、线性代数和非专业的统计学，对数据分析和可视化，乃至整个数据科学都感兴趣。本书非常适合经济管理、新闻传播、社科医学、统计专业的高年级本科生和研究生，对从事数据相关工作的商业分析师和算法工程师会非常有帮助，对有志从事数据科学的其它专业学生和已从事相关工作的人也有价值。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#既然是现代统计图形的第二版和第一版的主要区别是什么目标读者是否一样",
    "href": "preface.html#既然是现代统计图形的第二版和第一版的主要区别是什么目标读者是否一样",
    "title": "前言",
    "section": "",
    "text": "全书的图形风格将更加的协调和美观，无论 Base R 还是 ggplot2 绘制的图形都要遵循这一点。\n全书的组织和内容更加体现应用性，将更多地从数据和应用场景出发，而不是从图形种类和技术出发。\n更加强调数据可视化在探索性、可重复性、沟通交流和信息传递中的重要性。\n全书图片采用灰度调色板统一配色，黑白印刷也不会出现图文颜色描述不匹配的情况，方便出版打印，也能一定程度上降低书籍的定价，部分图形提供彩版。\n尽量兼顾统计理论的严谨和统计图形的直观，对于有明显统计意义的图形都要讲述其统计原理，做到知其然且知其所以然。\n统计图形的历史不再单独成章介绍，而是在具体的数据分析和应用时介绍或者作为一个章节的片尾故事。\n在介绍统计理论和可视化理论的时候，尽可能多地使用 Base R 基础数据集，基础数据集涉及的知识范围很多很广，故事也多，且稳定可靠。应用部分尽可能多地采纳开放数据，现代工业数据背景，和读者有亲近感，有实际参考价值，有经验教训可期。\n应用部分，数据集取材于 BBC，经济学人，尽可能来源于真实场景，比如 kaggle 数学建模，天池比赛，黑子活动这样的 R 内置数据集也可以扩展到如今，分析的对象不做限制。目的：一是紧跟时代，二是加强读者对统计学的了解，向来从历史和人物的角度引入比较容易让人接受。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#国内外介绍统计图形的书肯定不止这一本本书独特的价值在哪里",
    "href": "preface.html#国内外介绍统计图形的书肯定不止这一本本书独特的价值在哪里",
    "title": "前言",
    "section": "国内外介绍统计图形的书肯定不止这一本，本书独特的价值在哪里？",
    "text": "国内外介绍统计图形的书肯定不止这一本，本书独特的价值在哪里？\n本书从数据和场景出发，应用性会非常强，其次，数据分析、可视化和信息展示的过程可重复，既照顾到技术的快速发展又有很强的稳定性，结合作者多年来从事数据科学工作的实践经验，从学以自用到学以致用，相信会很有参考意义。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你为什么要写这样一本书你的创作初衷是什么",
    "href": "preface.html#你为什么要写这样一本书你的创作初衷是什么",
    "title": "前言",
    "section": "你为什么要写这样一本书，你的创作初衷是什么？",
    "text": "你为什么要写这样一本书，你的创作初衷是什么？\n我在读本科学习数理统计的时候接触了 R 语言，自此和数据可视化结缘，曾也专注于统计理论的学习，但越学越觉得建立统计直觉和学习理论一样的重要。工作后，一直从事数据分析相关的工作，从本科以来就有记笔记的习惯，读研究生的时候接触了 rmarkdown 和 bookdown，线下笔记可以很好的线上化，分门别类，不少人也知道我的一些技术笔记在 Github 上迭代过好几轮，经年累月，受益匪浅，持续的技术和业务沉淀让我决心以出版书籍的标准再次整理笔记和素材。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#国内外相关书籍的概况如何",
    "href": "preface.html#国内外相关书籍的概况如何",
    "title": "前言",
    "section": "国内外，相关书籍的概况如何？",
    "text": "国内外，相关书籍的概况如何？\n早年比较经典的书籍包括《Graphics of Large Datasets: Visualizing a Million》(Antony Unwin 2006) 和《Handbook of Data Visualization》(Chen, Härdle, 和 Unwin 2008)。近些年，新的可视化工具和技术日趋成熟，《R Graphics》主要介绍了 R 语言环境中栅格绘图系统 (Murrell 2018)。在此基础上，衍生出 ggplot2 扩展包，它基于图形语法，建立了从数据到图形的映射。ggplot2: Elegant Graphics for Data Analysis 主要介绍了 ggplot2 绘图技法 (Wickham 2016)，紧接着出现了以 ggplot2 为主的图形食谱 R Graphics Cookbook (Chang 2018)，主要解决读者作图过程中常碰到的问题。而《Displaying Time Series, Spatial, and Space-Time Data with R》(Lamigueiro 2018) 针对时间序列数据、空间数据和时空数据提供了详细的介绍，《Interactive web-based data visualization with R, plotly, and shiny》(Sievert 2020) 着重介绍了以 plotly 和 shiny 为代表的图形交互能力。 Kieran Healy 的 Data Visualization: A practical introduction (Healy 2019) 和 Claus O. Wilke 的 Fundamentals of Data Visualization (Wilke 2019) 由浅入深地介绍了数据可视化的要素和原则，而 Thomas Rahlf 的《Data Visualisation with R》(Rahlf 2019) 提供了丰富的示例。国内陈为老师的《数据可视化》(陈为, 沈则潜, 和 陶煜波 2019) 也非常值得一看。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你为什么要讲创作的心路历程",
    "href": "preface.html#你为什么要讲创作的心路历程",
    "title": "前言",
    "section": "你为什么要讲创作的心路历程？",
    "text": "你为什么要讲创作的心路历程？\n因为我觉得过程比结果重要，身临其境才有感同身受，培养延迟满足感很重要， 2019年我在论坛发问：书应该怎么写才符合素质教育的理念？。 国内外有大量非常好的书籍介绍统计学史，一些基本概念的来龙去脉， 比如《Past, Present, and Future of Statistical Science》(Lin 等 2014)、 《Fisher, Neyman, and the Creation of Classical Statistics》(Lehmann 2011)、 《The Lady Tasting Tea: How Statistics Revolutionized Science In The Twentieth Century》(Salsburg 2001)、 《Statisticians of the Centuries》(Heyde 等 2001) 和 《Leading Personalities in Statistical Sciences: From The Seventeenth Century to The Present》 (Johnson 和 Kotz 1997)， 国内也有很多，比如《统计发展史》(陈善林 和 张浙 1987)、《数理统计学简史》(陈希孺 2000) 和《统计学漫话》(陈希孺 和 苏淳 2016)等， 还有人物传记类，比如《Neyman》(Reid 1982) 及其译作(Reid 1987)、《漫漫修远攻算路：方开泰自述》 (方开泰 2016) 和《道德文章垂范人间：纪念许宝騄先生百年诞辰》 (许宝騄先生纪念文集编委会编 2010)，IMS 的统计科学访谈文章1， 还有一些文章，比如吴建福老师的《从历史发展看中国统计发展方向》(吴建福 1986)和《统计学者的工作及风范：灵感、抱负、雄心》(吴建福 2011)，还有 2010年新办的杂志《数学文化》，2009年丘成桐、杨乐等主编的《数学与人文》 丛书等，统计之都 也有大量访谈形式的文章，非常值得一读。更多统计历史相关的材料见 https://github.com/sctyner/history_of_statistics，真是篇幅所限，没法一一列举。\n培养开阔的思维，广泛的人际关系和优秀的沟通能力，不走极端，专业技术只是决定你的起点，软实力将决定你的高度。以史为镜可知兴替，突破自己的局限，少犯一些错误。要认识到往往是时势造就了英雄，环境对人的影响很大，大到国家，小到团队组织，事情能否做成往往取决于环境，而不是个人能力。若能从历史中看到未来的变化趋势，顺势而为，则善莫大焉，只要在风口上，猪都能飞起来，更是屡见不鲜！\n最后，给一个开放的思考：Bernoulli 家族的教育教学有哪些值得学习的地方？他们的生平经历如何？是在什么样的成长环境下孕育如此之多的科学家？在历史的长河之中，一个家族中有一两位科学家不足为奇，但是好几代人，连续出现10多位科学家就很值得研究了。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你准备在书里介绍统计理论范围是什么深度如何",
    "href": "preface.html#你准备在书里介绍统计理论范围是什么深度如何",
    "title": "前言",
    "section": "你准备在书里介绍统计理论，范围是什么？深度如何？",
    "text": "你准备在书里介绍统计理论，范围是什么？深度如何？\n统计部分覆盖面是数理统计的常规内容，涉及抽样分布（常见正态、\\(t\\) 和\\(\\chi^2\\) 分布），参数估计（点估计、区间估计和估计方法三方面的内容）和假设检验（参数、非参数检验及其检验理论）。不会过多重复普通教材的内容，教材内已有的会点到即止，重点在彼此的联系，基础概念的深刻理解，又要保持通俗易懂。\n\n\n\n\n\n数理统计\n\n\n\n\n关于参数估计，我们走过了高斯时代的最小二乘估计、Karl Person 时代的矩估计和 Ronald A. Fisher 时代的极大似然估计。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你准备在书里介绍机器学习范围是什么深度如何",
    "href": "preface.html#你准备在书里介绍机器学习范围是什么深度如何",
    "title": "前言",
    "section": "你准备在书里介绍机器学习，范围是什么？深度如何？",
    "text": "你准备在书里介绍机器学习，范围是什么？深度如何？\n今年来机器学习和深度学习成为了国之显学，国内外教材如过江之鲫，我一学统计的，不揣浅陋列举几本，如 Bishop (2006);Goodfellow, Bengio, 和 Courville (2016);Mohri, Rostamizadeh, 和 Talwalkar (2018)。 结合自己在工作这几年的所见所闻，又考虑到本书的定位，理论的范围以 Spark 的机器学习库 为参照。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你多年从事数据相关的工作你怎么看待数据科学",
    "href": "preface.html#你多年从事数据相关的工作你怎么看待数据科学",
    "title": "前言",
    "section": "你多年从事数据相关的工作，你怎么看待数据科学？",
    "text": "你多年从事数据相关的工作，你怎么看待数据科学？\n我很多人都看过 Hadley Wickham 和 Garrett Grolemund 合著的《R for Data Science》(Wickham 和 Grolemund 2017)，书里对数据科学的描述大致如图 @ref(fig:data-science) 所示，实际上数据收集可不是调几个 R 包，不同学科，如经济管理会发问卷，物理做实体或模拟实验，互联网在 App 内埋点收集数据。收集数据之前要做好试验设计，试验设计之前要提出好问题，如何发现、定义和界定问题其实是最难的部分，不仅需要熟悉全链路的技术环节，还要知晓各个岗位的职责边界，既要像万花筒那样深根自己的领域，又要学会像八抓鱼那样获取团队、部门和公司内外的有效输入，还要以强大的执行力推动问题解决。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你写书的心路历程是怎样的经历过怎样的认知迭代",
    "href": "preface.html#你写书的心路历程是怎样的经历过怎样的认知迭代",
    "title": "前言",
    "section": "你写书的心路历程是怎样的？经历过怎样的认知迭代？",
    "text": "你写书的心路历程是怎样的？经历过怎样的认知迭代？\n探索数据科学的旅程如邓宁-克鲁格认知迭代曲线 @ref(fig:dk-curve)， 经历不知道自己不知道的愚昧阶段，知道自己不知道的绝望阶段，知道自己知道的开悟阶段，经过漫长的修行到达不知道自己知道的大师阶段。我可能还在愚昧的山峰，只是自己觉得自己正在从绝望的谷底开始往开悟之坡攀爬！\n我也经历了放弃，放弃一段时间后，偶然看到某篇文章、某本书或者某个讲座上某个人说过的某句话，灵光一现，又再捡起来，会有完全不同的想法冒出来，过程很奇妙，有柳暗花明又一村的感觉！比如书中关于二项分布的参数 \\(p\\) 在不同的区间估计下，参数 \\(p\\) 与覆盖概率的关系，见图@ref(fig:coverage)，其实，早在2020年5月就埋下伏笔了。\n我原以为自己是统计科班出身，研究生学习数理统计还算扎实，想必读几十年前关于数理统计的论文会比较容易，遂先从置信区间开始，哪知即遭当头一棒，C. J. Clopper 和 E. S. Pearson 在 1934 年合作的论文 Clopper 和 Pearson (1934) 我竟前前后后读了近两年时间才自觉明白。为什么呢？近百年过去了，一些提法和现在的书不同了，加之已有一些先入为主的概念阻碍了我，又是利用工作之余的时间在读，缺乏连续性，当年在学校里侧重知识的灌输而不是思维的训练，对基本概念缺乏追根溯源式的深入学习。\n\n\n\n\n\n邓宁-克鲁格认知迭代曲线",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#你写书的执行过程是怎样的你觉得自己的执行力如何",
    "href": "preface.html#你写书的执行过程是怎样的你觉得自己的执行力如何",
    "title": "前言",
    "section": "你写书的执行过程是怎样的？你觉得自己的执行力如何？",
    "text": "你写书的执行过程是怎样的？你觉得自己的执行力如何？\n\n\n\n\n\n执行过程\n\n\n\n\n广度是基础理论在各个应用场景开花结果，业务问题转化为数据问题、统计问题；深度是追根溯源和理清线索，找到区别和联系，以点带线，而后形成知识网；远度是回顾历史和展望未来，给出自己的预判和讨论。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#知识技术到应用的距离怎样的应用相关的伦理道德问题",
    "href": "preface.html#知识技术到应用的距离怎样的应用相关的伦理道德问题",
    "title": "前言",
    "section": "知识、技术到应用的距离？怎样的应用？相关的伦理道德问题？",
    "text": "知识、技术到应用的距离？怎样的应用？相关的伦理道德问题？\n学校作为教学的主要场所，很多人诟病当前的教育教学与社会实际脱节。学校需要批量化地生产高知识的劳动力，剥离业务背景的知识是有限的，教学可以规模化，在3-5年内速成。进入企业，可能要明白的是业务的商业逻辑是什么，业务阶段是什么，明白探索、进攻、发展、变革阶段会有什么特点，对组织和个人的影响是什么？机遇和挑战是什么？弄清楚业务问题，将业务问题转化为数据问题、统计问题、算法问题、产品问题和工程问题。\n另外一个，重点问题是技术应当以人为本，因为它是一把双刃剑， 互联网行业算法的益处就不多说了，算法的害处是被严重低估和忽视的，大家知道，互联网公司的大部分收入来自广告，广告的价值却源于每个人未来时间精力的投入。广告算法工程师应该不会希望将个性化广告投放技术应用到自己的家人身上，给自己、家庭和社会带来给多的焦虑吧！ 市面上很多的书籍教你如何掌握统计学习、机器学习、深度学习、大数据技术，而技术的好坏是由其应用的场景决定的。The Social Dilem 详细讲了算法智能的陷阱。最近，国家有关监管部门也派人到各大主要互联网公司调研个性化广告、推荐和搜索算法！\n\n\n\n\nAntony Unwin, Heike Hofmann, Martin Theus. 2006. Graphics of Large Datasets: Visualizing a Million. New York, NY: Springer-Verlag.\n\n\nBishop, Christopher. 2006. Pattern Recognition and Machine Learning. New York, NY: Springer. https://www.microsoft.com/en-us/research/people/cmbishop/prml-book/.\n\n\nChang, Winston. 2018. R Graphics Cookbook: Practical Recipes for Visualizing Data. 2nd 本. Sebastopol, California: O’Reilly Media, Inc. https://r-graphics.org/.\n\n\nChen, Chun-houh, Wolfgang Härdle, 和 Antony Unwin. 2008. Handbook of Data Visualization. Berlin, Heidelberg: Springer-Verlag.\n\n\nClopper, C. J., 和 E. S. Pearson. 1934. 《The Use of Confidence or Fiducial Limits Illustrated In The Case of The Binomial》. Biometrika 26 (4): 404–13. https://doi.org/10.1093/biomet/26.4.404.\n\n\nGoodfellow, Ian, Yoshua Bengio, 和 Aaron Courville. 2016. Deep Learning. MIT Press. https://www.deeplearningbook.org/.\n\n\nHealy, Kieran. 2019. Data Visualization: A Practical Introduction. Princeton, New Jersey: Princeton University Press. https://socviz.co/.\n\n\nHeyde, C. C., E. Seneta, P. Crépel, S. E. Fienberg, 和 J. Gani. 2001. Statisticians of the Centuries. New York, NY: Springer-Verlag. https://doi.org/10.1007/978-1-4613-0179-0.\n\n\nJohnson, Norman L., 和 Samuel Kotz, 编. 1997. Leading Personalities in Statistical Sciences: From The Seventeenth Century to The Present. John Wiley & Sons, Inc. https://doi.org/10.1002/9781118150719.\n\n\nLamigueiro, Oscar Perpinan. 2018. Displaying Time Series, Spatial, and Space-Time Data with R. 2nd 本. Boca Raton, Florida: Chapman; Hall/CRC. https://oscarperpinan.github.io/bookvis/.\n\n\nLehmann, Erich L. 2011. Fisher, Neyman, and the Creation of Classical Statistics. Springer New York. https://doi.org/10.1007/978-1-4419-9500-1.\n\n\nLin, Xihong, Christian Genest, David L. Banks, Geert Molenberghs, David W. Scott, 和 Jane-Ling Wang, 编. 2014. Past, Present, and Future of Statistical Science. Boca Raton, Florida: Chapman; Hall/CRC.\n\n\nMohri, Mehryar, Afshin Rostamizadeh, 和 Ameet Talwalkar. 2018. Foundations of Machine Learning. 2nd 本. Cambridge, Massachusetts: MIT Press. https://cs.nyu.edu/~mohri/mlbook/.\n\n\nMurrell, Paul. 2018. R Graphics. 3rd 本. Boca Raton, Florida: Chapman; Hall/CRC. https://www.stat.auckland.ac.nz/~paul/RG3e/.\n\n\nRahlf, Thomas. 2019. Data Visualisation with R. 2nd 本. New York, NY: Springer Nature. https://www.datavisualisation-r.com/.\n\n\nReid, Constance. 1982. Neyman. New York, NY: Springer-Verlag. https://doi.org/10.1007/978-1-4612-5754-7.\n\n\n———. 1987. 耐曼—现代统计学家. 编辑 袁运开, 张瑞琨, 和 应兴国. 翻译 姚慕生等. 上海: 上海翻译出版公司.\n\n\nSalsburg, David. 2001. The Lady Tasting Tea: How Statistics Revolutionized Science In The Twentieth Century. New York, NY: W. H. Freeman; Company.\n\n\nSievert, Carson. 2020. Interactive web-based data visualization with R, plotly, and shiny. 1st 本. Boca Raton, Florida: Chapman; Hall/CRC. https://plotly-r.com/.\n\n\nWickham, Hadley. 2016. ggplot2: Elegant Graphics for Data Analysis. 2nd 本. New York: Springer-Verlag. https://ggplot2-book.org/.\n\n\nWickham, Hadley, 和 Garrett Grolemund. 2017. R for Data Science. 1st 本. Sebastopol, California: O’Reilly Media, Inc. https://r4ds.had.co.nz/.\n\n\nWilke, Claus O. 2019. Fundamentals of Data Visualization: A Primer on Making Informative and Compelling Figures. Sebastopol, California: O’Reilly Media, Inc. https://clauswilke.com/dataviz/.\n\n\n吴建福. 1986. 《从历史发展看中国统计发展方向》. 数理统计与管理, 期 1: 1–7. https://doi.org/10.13860/j.cnki.sltj.1986.01.001.\n\n\n———. 2011. 《统计学者的工作及风范：灵感、抱负、雄心》. 应用概率统计, 期 2: 113–23.\n\n\n方开泰. 2016. 漫漫修远攻算路—方开泰自述. 第一版. 长沙: 湖南教育出版社.\n\n\n许宝騄先生纪念文集编委会编. 2010. 道德文章垂范人间：纪念许宝騄先生百年诞辰. 第一版. 北京: 北京大学出版社.\n\n\n陈为, 沈则潜, 和 陶煜波. 2019. 数据可视化. 第二版. 北京: 电子工业出版社. https://zjuvag.org/.\n\n\n陈善林, 和 张浙. 1987. 统计发展史. 上海: 立信会计图书用品社.\n\n\n陈希孺. 2000. 数理统计学简史. 第一版. 长沙: 湖南教育出版社.\n\n\n陈希孺, 和 苏淳. 2016. 统计学漫话. 第二版. 合肥, 安徽: 中国科学技术大学出版社.",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "preface.html#footnotes",
    "href": "preface.html#footnotes",
    "title": "前言",
    "section": "",
    "text": "https://imstat.org/journals-and-publications/statistical-science/conversations/↩︎",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "visualization-basic.html",
    "href": "visualization-basic.html",
    "title": "1  ggplot2 入门",
    "section": "",
    "text": "1.1 图层\n2006 年 Hans Rosling（汉斯·罗琳）在 TED 做了一场精彩的演讲 — The best stats you’ve ever seen。演讲中展示了一系列生动形象的动画，用数据记录的事实帮助大家理解世界的变化，可谓是动态图形领域的惊世之作。时至今日，已经超过 1500 万人观看，产生了十分广泛的影响。下面从数据源头 — 世界银行获取数据，整理后取名 gapminder。本节将基于 gapminder 数据集介绍 ggplot2 绘图的基础知识，包括图层、标签、刻度、配色、图例、主题、文本、分面、字体、动画和组合等 11 个方面，理解这些有助于绘制和加工各种各样的统计图形，可以覆盖日常所需。gapminder 数据集以数据框的形式存储在 R 软件运行环境中，一共 4950 行，7 列。篇幅所限，下 表 1.1 展示该数据集的部分内容，表中人均 GDP 和预期寿命两列四舍五入保留一位小数。\n在 R 环境中，加载 gapminder 数据集后，可以用 str() 函数查看数据集 gapminder 各个列的数据类型和部分属性值。\n其中，country（国家或地区）是字符型变量，region （区域）是因子型变量，income_level（收入水平）是有序的因子型变量，year （年份）、 pop （人口总数）、lifeExp （出生时的预期寿命，单位：岁）和 gdpPercap （人均 GDP，单位：美元）是数值型变量。\nggplot2 绘图必须包含以下三个要素，缺少任何一个，图形都是不完整的。\n下面逐一说明三个要素的作用，为简单起见，从数据集 gapminder 中选取 2007 年的数据。\n图 1.1 (a) 仅提供数据，只渲染出来一个绘图区域。 图 1.1 (b) 仅提供数据和映射，将变量 gdpPercap 映射给横轴，变量 lifeExp 映射给纵轴，继续渲染出来横、纵坐标轴及标签。 图 1.1 (c) 提供了数据、映射和图层三要素，观察值根据几何图层 geom_point() 将几何元素 「点」渲染在绘图区域上，形成散点图。函数 ggplot() 和函数 geom_point() 之间是以加号 + 连接的。无论最终产出的图形如何复杂，这个模式贯穿 ggplot2 绘图。\n10 多年来，ggplot2 包陆续添加了很多几何图层，目前支持的有 53 个，如下：\n也正因这些丰富多彩的图层，ggplot2 可以非常便捷地做各种数据探索和展示工作。从时间序列数据、网络社交数据到文本数据、空间数据，乃至时空数据都有它大显身手的地方。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-layer",
    "href": "visualization-basic.html#sec-layer",
    "title": "1  ggplot2 入门",
    "section": "",
    "text": "数据，前面已经重点介绍和准备了；\n映射，数据中的变量与几何元素的对应关系；\n图层，至少需要一个图层用来渲染观察值。\n\n\nlibrary(ggplot2)\ngapminder_2007 &lt;- gapminder[gapminder$year == 2007, ]\nggplot(data = gapminder_2007)\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp))\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point()\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(size = pop))\n\n\n\n\n\n\n\n\n\n\n\n(a) 只有数据\n\n\n\n\n\n\n\n\n\n\n\n(b) 只有数据和坐标映射\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 数据、坐标映射和点图层\n\n\n\n\n\n\n\n\n\n\n\n(d) 数据、坐标映射、点图层和视觉映射（可选）\n\n\n\n\n\n\n\n图 1.1: ggplot2 绘图三要素\n\n\n\n\n\n\n\n\n表 1.2: ggplot2 包可以绘制丰富的统计图形\n\n\n\n\n\ngeom_abline\ngeom_dotplot\ngeom_qq_line\n\n\ngeom_area\ngeom_errorbar\ngeom_quantile\n\n\ngeom_bar\ngeom_errorbarh\ngeom_raster\n\n\ngeom_bin_2d\ngeom_freqpoly\ngeom_rect\n\n\ngeom_bin2d\ngeom_function\ngeom_ribbon\n\n\ngeom_blank\ngeom_hex\ngeom_rug\n\n\ngeom_boxplot\ngeom_histogram\ngeom_segment\n\n\ngeom_col\ngeom_hline\ngeom_sf\n\n\ngeom_contour\ngeom_jitter\ngeom_sf_label\n\n\ngeom_contour_filled\ngeom_label\ngeom_sf_text\n\n\ngeom_count\ngeom_line\ngeom_smooth\n\n\ngeom_crossbar\ngeom_linerange\ngeom_spoke\n\n\ngeom_curve\ngeom_map\ngeom_step\n\n\ngeom_density\ngeom_path\ngeom_text\n\n\ngeom_density_2d\ngeom_point\ngeom_tile\n\n\ngeom_density_2d_filled\ngeom_pointrange\ngeom_violin\n\n\ngeom_density2d\ngeom_polygon\ngeom_vline\n\n\ngeom_density2d_filled\ngeom_qq",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-label",
    "href": "visualization-basic.html#sec-label",
    "title": "1  ggplot2 入门",
    "section": "1.2 标签",
    "text": "1.2 标签\n用函数 labs() 可以添加横轴、纵轴、图例的标题，整个图片的标题和副标题等。下图 图 1.2 (a) 是默认设置下显示的标签内容，而 图 1.2 (b) 是用户指定标签内容后的显示效果。\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(color = region))\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(color = region)) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", tag = \"标签\",\n       title = \"这里是标题\", caption = \"这是图形说明\", \n       subtitle = \"这里是副标题\", color = \"图例标题\")\n\n\n\n\n\n\n\n\n\n\n\n(a) 默认设置\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) 自定义标签\n\n\n\n\n\n\n\n图 1.2: 添加标签",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-scale",
    "href": "visualization-basic.html#sec-scale",
    "title": "1  ggplot2 入门",
    "section": "1.3 刻度",
    "text": "1.3 刻度\n\n有时候 图 1.1 (c) 看起来不太好，收入低的国家太多，聚集在一起，重叠覆盖比较严重。而高收入国家相对较少，分布稀疏，距离低收入比较远，数据整体的分布很不平衡。此时，可以考虑对横轴标度做一些变换，常用的有以 10 为底的对数变换，如 图 1.3 。\n\nlibrary(scales)\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10() +\n  labs(x = \"人均 GDP\", y = \"预期寿命\")\n\n\n\n\n\n\n\n图 1.3: 人均 GDP 做对数变换\n\n\n\n\n\n为了更加醒目地展示横轴做了对数变换，需要添加对应的刻度标签。scales 包 (H. Wickham 和 Seidel 2022) 提供很多刻度标签支持，比如函数 label_log() 默认提供以 10 为底的刻度标签，如 图 1.4 。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10(labels = label_log()) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\")\n\n\n\n\n\n\n\n图 1.4: 刻度标签随数据变换调整\n\n\n\n\n\n这其实还不够，有的刻度标签含义不够显然，且看 图 1.4 的横轴第一个刻度标签 \\(10^{2.48}\\) 是用来替换 图 1.3 的横轴第一个刻度标签 300。10 的 2.48 次方可不容易看出是 300 的意思，实际上它等于 302。因此，结合人均 GDP 的实际范围，有必要适当调整横轴显示范围，这可以在函数 scale_x_log10() 中设置参数 limits，横轴刻度标签会随之适当调整，调整后的效果如 图 1.5 。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\")\n\n\n\n\n\n\n\n图 1.5: 设置数据展示范围\n\n\n\n\n\n根据横轴所代表的人均 GDP （单位：美元）的实际含义，其实，可以进一步，添加更多的信息，即刻度标签带上数量单位，此处是美元符号。scales 包提供的函数 label_dollar() 可以实现，效果如 图 1.6 。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10(labels = label_dollar(), limits = c(100, 110000)) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\")\n\n\n\n\n\n\n\n图 1.6: 设置数据展示范围\n\n\n\n\n\n最后，有必要添加次刻度线作为辅助参考线。图中点与点之间的横向距离代表人均 GDP 差距，以 10 为底的对数变换不是线性变化的，肉眼识别起来有点困难。从 100 美元到 100000 美元，在 100 美元、1000 美元、10000 美元和 100000 美元之间均添加 10 条次刻度线，每个区间内相邻的两条次刻度线之差保持恒定。下面构造刻度线的位置，了解原值和对数变换后的对应关系。\n\n# 刻度线位置\nmb &lt;- unique(as.numeric(1:10 %o% 10^(1:4)))\n# 对数变换后\nlog10(mb)\n#&gt;  [1] 1.000000 1.301030 1.477121 1.602060 1.698970 1.778151 1.845098\n#&gt;  [8] 1.903090 1.954243 2.000000 2.301030 2.477121 2.602060 2.698970\n#&gt; [15] 2.778151 2.845098 2.903090 2.954243 3.000000 3.301030 3.477121\n#&gt; [22] 3.602060 3.698970 3.778151 3.845098 3.903090 3.954243 4.000000\n#&gt; [29] 4.301030 4.477121 4.602060 4.698970 4.778151 4.845098 4.903090\n#&gt; [36] 4.954243 5.000000\n# 刻度线位置\nformat(mb, big.mark = \",\", scientific = 999)\n#&gt;  [1] \"     10\" \"     20\" \"     30\" \"     40\" \"     50\" \"     60\"\n#&gt;  [7] \"     70\" \"     80\" \"     90\" \"    100\" \"    200\" \"    300\"\n#&gt; [13] \"    400\" \"    500\" \"    600\" \"    700\" \"    800\" \"    900\"\n#&gt; [19] \"  1,000\" \"  2,000\" \"  3,000\" \"  4,000\" \"  5,000\" \"  6,000\"\n#&gt; [25] \"  7,000\" \"  8,000\" \"  9,000\" \" 10,000\" \" 20,000\" \" 30,000\"\n#&gt; [31] \" 40,000\" \" 50,000\" \" 60,000\" \" 70,000\" \" 80,000\" \" 90,000\"\n#&gt; [37] \"100,000\"\n\n函数 scale_x_log10() 提供参数 minor_breaks 设定刻度线的位置。最终效果如 图 1.7 。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point() +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\")\n\n\n\n\n\n\n\n图 1.7: 添加次刻度线，提供更多参考",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-color",
    "href": "visualization-basic.html#sec-color",
    "title": "1  ggplot2 入门",
    "section": "1.4 配色",
    "text": "1.4 配色\n好的配色可以让图形产生眼前一亮的效果，R 语言社区在统计图形领域深耕 20 多年，陆续涌现很多专门调色的 R 包，常见的有：\n\nRColorBrewer (Neuwirth 2022) (https://github.com/axismaps/colorbrewer/)\nmunsell (C. Wickham 2018) (https://github.com/cwickham/munsell/)\ncolorspace (Zeileis 等 2020) (https://colorspace.r-forge.r-project.org/)\npaletteer (Hvitfeldt 2021) (https://github.com/EmilHvitfeldt/paletteer)\nscico (Pedersen 和 Crameri 2022) (https://github.com/thomasp85/scico)\nviridis (Garnier 等 2021) (https://github.com/sjmgarnier/viridis/)\nviridisLite (Garnier 等 2021) (https://github.com/sjmgarnier/viridisLite/)\ncolormap (Karambelkar 2016) (https://github.com/bhaskarvk/colormap)\n\nggplot2 提供多种方式给图形配色，最常见的要数函数 scale_color_brewer()，它调用 RColorBrewer 包制作离散型的调色板，根据离散型变量的具体情况，可分为发散型 qualitative、对撞型 Diverging、有序型 Sequential。在图 图 1.7 的基础上，将分类型的区域变量映射给散点的颜色，即得到 图 1.8 。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(color = region)) +\n  scale_color_brewer(palette = \"Set1\") +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", color = \"区域\")\n\n\n\n\n\n\n\n图 1.8: 使用 RColorBrewer 包提供的 Set1 调色板\n\n\n\n\n\n另一种方式是调用函数 scale_color_manual()，需要用户给分类变量值逐个指定颜色，即提供一个命名的向量，效果如 图 1.9 。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(color = region)) +\n  scale_color_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", color = \"区域\")\n\n\n\n\n\n\n\n图 1.9: 手动挨个指定分类变量的颜色",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-legend",
    "href": "visualization-basic.html#sec-legend",
    "title": "1  ggplot2 入门",
    "section": "1.5 图例",
    "text": "1.5 图例\n在 图 1.8 的基础上，继续将每个国家的人口总数映射给点的大小，绘制气泡图。此时有两个视觉映射变量 — 离散型的变量 country （国家）和连续型的变量 pop （人口总数）。不仅仅是图层函数 geom_point()，所有的几何图层都提供参数 show.legend 来控制图例的显示或隐藏。传递命名逻辑向量还可以在多个图例中选择性保留。 图 1.10 在两个图例中保留一个，即人口总数。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(color = region, size = pop),\n    show.legend = c(color = FALSE, size = TRUE)\n  ) +\n  scale_color_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", size = \"人口总数\")\n\n\n\n\n\n\n\n图 1.10: 在两个图例中保留一个\n\n\n\n\n\n全世界各个国家的人口总数从百万级横跨到十亿级，根据此实际情况，适当调整图例刻度标签是很有必要的，可以让图例内容更具可读性。 图 1.11 是修改图例刻度标签后的效果，其中 M 表示 Million（百万），B 表示 Billion （十 亿）。\n\nggplot(data = gapminder_2007, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(color = region, size = pop),\n    show.legend = c(color = FALSE, size = TRUE)\n  ) +\n  scale_color_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12), labels = label_number(scale_cut = cut_short_scale())) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", size = \"人口总数\")\n\n\n\n\n\n\n\n图 1.11: 修改图例刻度标签",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-theme",
    "href": "visualization-basic.html#sec-theme",
    "title": "1  ggplot2 入门",
    "section": "1.6 主题",
    "text": "1.6 主题\n主题就是一系列风格样式的集合，提前设定标题、文本、坐标轴、图例等元素的默认参数，供后续调用。10 年来，R 语言社区陆续出现很多主题包。\n\nggthemes (Arnold 2021) 收集了网站（如 Fivethirtyeight）、杂志（如《经济学家》）、软件（如 Stata）等的配色主题，打包成可供 ggplot2 绘图的主题，更多内容见 (https://github.com/jrnold/ggthemes)\nggsci (Xiao 2018) 包收集了多份期刊杂志的图形配色，将其融入 ggplot2 绘图主题中，更多内容见 (https://github.com/road2stat/ggsci)。\nggpubr (Kassambara 2022) 包在 ggplot2 之上封装一套更加易用的函数，可以快速绘制出版级的统计图形 (https://github.com/kassambara/ggpubr)。\nggcharts (Neitmann 2020) 包类似 ggpubr 包，也提供一套更加快捷的函数接口，缩短数据可视化的想法与实际图形的距离，更多内容见 (https://github.com/thomas-neitmann/ggcharts)。\nggthemr (Tobin 2020) 是比较早的 ggplot2 主题包，上游依赖少，更多内容见 (https://github.com/Mikata-Project/ggthemr)。\nggtech (Bion 2018) 包收集了许多科技公司的设计风格，将其制作成可供 ggplot2 绘图使用的主题，更多内容见 (https://github.com/ricardo-bion/ggtech)。\nbbplot (Stylianou 等 2022) 为 BBC 新闻定制的一套主题，更多内容见 (https://github.com/bbc/bbplot)。\npilot (Hawkins 2022) 包提供一套简洁的 ggplot2 主题，特别是适合展示分类、离散型数据，更多内容见 (https://github.com/olihawkins/pilot)。\nggthemeassist (Gross 和 Ottolinger 2016) 包提供 RStudio IDE 插件，帮助用户以鼠标点击的交互方式设置 ggplot2 图形的主题样式，更多内容见 (https://github.com/calligross/ggthemeassist)。\n\n在 图 1.11 的基础上，以 ggplot2 包内置的主题 theme_classic() 替换默认的主题，效果如下 图 1.12 ，这是一套非常经典的主题，它去掉所有的背景色和参考系，显得非常简洁。\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(\n    data = function(x) subset(x, year == 2007),\n    aes(fill = region, size = pop), shape = 21, col = \"white\",\n    show.legend = c(fill = TRUE, size = FALSE)\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  theme_classic() +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.12: ggplot2 内置的经典主题风格\n\n\n\n\n\n在已有主题的基础上，还可以进一步细微调整，比如，将图例移动至绘图区域的下方，见 图 1.13 。\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(\n    data = function(x) subset(x, year == 2007),\n    aes(fill = region, size = pop), shape = 21, col = \"white\",\n    show.legend = c(fill = TRUE, size = FALSE)\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  theme_classic() +\n  theme(legend.position = \"bottom\") +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.13: 图例置于图形下方\n\n\n\n\n\n或者用户觉得合适的任意位置。\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(\n    data = function(x) subset(x, year == 2007),\n    aes(fill = region, size = pop), shape = 21, col = \"white\",\n    show.legend = c(fill = TRUE, size = FALSE)\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.875, 0.3)) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.14: 微调图例位置\n\n\n\n\n\n或者更换其它主题，比如 ggthemes 包内置极简主题 theme_tufte()，它仅保留主刻度线，更加凸显数据。\n\nlibrary(ggthemes)\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(\n    data = function(x) subset(x, year == 2007),\n    aes(fill = region, size = pop),\n    show.legend = c(fill = TRUE, size = FALSE),\n    shape = 21, col = \"white\"\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  theme_tufte(base_family = \"sans\") +\n  theme(\n    legend.position = \"inside\", \n    legend.position.inside =  c(0.875, 0.3), \n    legend.title = element_text(family = \"Noto Sans CJK SC\"),\n    legend.text = element_text(family = \"Noto Sans CJK SC\"),\n    axis.title = element_text(family = \"Noto Sans CJK SC\")) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.15: ggthemes 的极简主题 Tufte",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-annotation",
    "href": "visualization-basic.html#sec-annotation",
    "title": "1  ggplot2 入门",
    "section": "1.7 注释",
    "text": "1.7 注释\n注释可以是普通文本，数学公式，还可以是图形照片、表情包。注释功能非常强大，但也是非常灵活，往往使用起来颇费功夫，需要结合数据情况，从图形所要传递的信息出发，适当添加。R 语言社区陆续出现一些扩展包，让用户使用起来更方便些。\n\nggrepel (Slowikowski 2021) 包可以通过添加一定距离的扰动，可以缓解文本重叠的问题，更多内容见 (https://github.com/slowkow/ggrepel)。\nggtext (Wilke 2020) 包支持以 Markdown 语法添加丰富的文本内容，更多内容见 (https://github.com/wilkelab/ggtext)。\nstring2path (Yutani 2022) 包字体轮廓生成路径，注释文本随路径变化，更多内容见 (https://github.com/yutannihilation/string2path)。\nggimage (Yu 2022) 包提供图像图层，实现以图片代替散点的效果，图片还可以是表情包，更多内容见 (https://github.com/GuangchuangYu/ggimage)。\n\n在 图 1.15 的基础上，给人口总数大于 2 亿的国家添加文本注释。这可以用 ggplot2 包提供的文本图层函数 geom_text() 实现，效果如 图 1.16 。\n\nlibrary(ggrepel)\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(\n    data = function(x) subset(x, year == 2007),\n    aes(fill = region, size = pop),\n    show.legend = c(fill = TRUE, size = FALSE),\n    shape = 21, col = \"white\"\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  geom_text(\n    data = function(x) subset(x, year == 2007 & pop &gt;= 20 * 10^7),\n    aes(label = country), show.legend = FALSE\n  ) +\n  scale_size(range = c(2, 12)) +\n  theme_tufte(base_family = \"sans\") +\n  theme(\n    legend.position = \"inside\", \n    legend.position.inside =  c(0.9, 0.3), \n    legend.title = element_text(family = \"Noto Sans CJK SC\"),\n    legend.text = element_text(family = \"Noto Sans CJK SC\"),\n    axis.title = element_text(family = \"Noto Sans CJK SC\")) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.16: 添加文本注释\n\n\n\n\n\n当需要给许多点添加文本注释时，就难以避免地遇到注释文本重叠的问题。比如给人口总数大于 5000 万的国家添加文本注释，此时，适合使用 ggrepel 包，调用函数 geom_text_repel() — 这是一个新的文本图层，通过添加适当的位移缓解文本重叠问题。\n\nlibrary(ggrepel)\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(data = function(x) subset(x, year == 2007),\n             aes(fill = region, size = pop),\n    show.legend = c(fill = TRUE, size = FALSE),\n    shape = 21, col = \"white\"\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_x_log10(\n    labels = label_dollar(), minor_breaks = mb, limits = c(100, 110000)\n  ) +\n  geom_text_repel(\n    data = function(x) subset(x, year == 2007 & pop &gt;= 5 * 10^7),\n    aes(label = country), size = 3, max.overlaps = 50,\n    segment.colour = \"gray\", seed = 2022, show.legend = FALSE\n  ) +\n  scale_size(range = c(2, 12)) +\n  theme_tufte(base_family = \"sans\") +\n  theme(\n    legend.position = \"inside\", \n    legend.position.inside =  c(0.9, 0.3), \n    legend.title = element_text(family = \"Noto Sans CJK SC\"),\n    legend.text = element_text(family = \"Noto Sans CJK SC\"),\n    axis.title = element_text(family = \"Noto Sans CJK SC\")) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.17: 缓解文本注释相互覆盖的问题",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-facet",
    "href": "visualization-basic.html#sec-facet",
    "title": "1  ggplot2 入门",
    "section": "1.8 分面",
    "text": "1.8 分面\nggplot2 包有两个函数 facet_wrap() 和 facet_grid() 都可以用来实现分面操作，分面的目的是将数据切分，一块一块地展示。下面在 图 1.15 的基础上，按收入水平变量分面，即将各个国家或地区按收入水平分开，效果如 图 1.18 所示。facet_grid() 与 facet_wrap() 的效果是类似的，就不再赘述了。\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(data = function(x) subset(x, year == 2007),\n             aes(fill = region, size = pop),\n    show.legend = c(fill = TRUE, size = FALSE),\n    shape = 21, col = \"white\"\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +\n  facet_wrap(facets = ~income_level, ncol = 2) +\n  theme_classic() +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.18: 按收入水平变量分面\n\n\n\n\n\n在函数 facet_wrap() 内设置不同的参数值，会有不同的排列效果。设置 ncol = 3，意味着排成 3 列，而分类变量 continent 总共有 5 种不同的类别，因此将会是 3 列 2 行的布局，效果如下 图 1.19 。\n\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(data = function(x) subset(x, year == 2007),\n             aes(fill = region, size = pop),\n    show.legend = c(fill = TRUE, size = FALSE),\n    shape = 21, col = \"white\"\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12)) +\n  scale_x_log10(labels = label_log(), limits = c(100, 110000)) +\n  facet_wrap(facets = ~income_level, ncol = 3) +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.9, 0.2)) +\n  labs(x = \"人均 GDP\", y = \"预期寿命\", fill = \"区域\")\n\n\n\n\n\n\n\n图 1.19: 按区域变量分面",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-animate",
    "href": "visualization-basic.html#sec-animate",
    "title": "1  ggplot2 入门",
    "section": "1.9 动画",
    "text": "1.9 动画\n从 1991 年至 2020 年，gapminder 数据集一共是 30 年的数据。根据 2007 年的数据绘制了 图 1.20 ，每年的数据绘制一幅图像，30 年总共可获得 30 帧图像，再以每秒播放 6 帧图像的速度将 30 帧图像合成 GIF 动画。因此，设置这个动画总共 30 帧，每秒播放的图像数为 6。\n\noptions(gganimate.nframes = 30, gganimate.fps = 6)\n\ngganimate 包提供一套代码风格类似 ggplot2 包的动态图形语法，可以非常顺滑地与之连接。在了解了 ggplot2 绘制图形的过程后，用 gganimate 包制作动画是非常容易的。gganimate 包会调用 gifski (https://github.com/r-rust/gifski) 包来合成动画，因此，除了安装 gganimate 包，还需要安装 gifski 包。接着，在已有的 ggplot2 绘图代码基础上，再追加一个转场图层函数 transition_time()，这里是按年逐帧展示图像，因此，其转场的时间变量为 gapminder 数据集中的变量 year。\n\nlibrary(gganimate)\nggplot(data = gapminder, aes(x = gdpPercap, y = lifeExp)) +\n  geom_point(aes(fill = region, size = pop),\n    show.legend = c(fill = TRUE, size = FALSE), \n    alpha = 0.65, shape = 21, col = \"white\"\n  ) +\n  scale_fill_manual(values = c(\n    `拉丁美洲与加勒比海地区` = \"#E41A1C\", `撒哈拉以南非洲地区` = \"#377EB8\",\n    `欧洲与中亚地区` = \"#4DAF4A\", `中东与北非地区` = \"#984EA3\",\n    `东亚与太平洋地区` = \"#FF7F00\", `南亚` = \"#FFFF33\", `北美` = \"#A65628\"\n  )) +\n  scale_size(range = c(2, 12), labels = label_number(scale_cut = cut_short_scale())) +\n  scale_x_log10(labels = label_log(), limits = c(10, 130000)) +\n  facet_wrap(facets = ~income_level) +\n  theme_classic() +\n  labs(\n    title = \"{frame_time} 年\", x = \"人均 GDP\",\n    y = \"预期寿命\", size = \"人口总数\", fill = \"区域\"\n  ) +\n  transition_time(time = year)\n\n\n\n\n\n\n\n图 1.20: 制作动画",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-combine",
    "href": "visualization-basic.html#sec-combine",
    "title": "1  ggplot2 入门",
    "section": "1.10 组合",
    "text": "1.10 组合\n将多幅小图组合起来构成一幅大图也是常见的需求，常见于出版级、产品级的作品中。组合涉及到布局，布局涉及到层次。有的组合图是从不同角度呈现数据，有的组合图是从传递信息的主次出发，等等。patchwork 包是非常流行的一个基于 ggplot2 的用于图形组合的 R 包，下面基于 faithful 数据展示绘制组合图形的过程。\n首先根据喷发时间将 faithful 数据分成两组。\n\n# 根据喷发时间将数据分成两组\nfaithful &lt;- transform(faithful, group = ifelse(eruptions &gt; 3, \"A\", \"B\"))\n\n绘制分组散点图，叠加二维核密度曲线。\n\n# 绘制分组散点图\nscatterplot &lt;- ggplot(faithful, aes(eruptions, waiting, color = group)) +\n  geom_point() +\n  geom_density_2d() +\n  theme_classic() +\n  theme(axis.text = element_blank(), axis.title = element_blank())\n\n将上图中的图例单独抽取出来，作为一个子图。\n\n# https://stackoverflow.com/questions/46079033/\n# Extract legend from ggplot object\nextract_legend &lt;- function(gg) {\n  grobs &lt;- ggplot_gtable(ggplot_build(gg))\n  foo &lt;- which(sapply(grobs$grobs, function(x) x$name) == \"guide-box\")\n  grobs$grobs[[foo]]\n}\nlegend &lt;- extract_legend(scatterplot)\n\n获得图例后，原图中不需要图例了。\n\nscatterplot &lt;- scatterplot + theme(legend.position = \"none\")\n\n准备两个箱线图分别描述 faithful 数据集中的等待时间 waiting 和喷发时间 eruptions 。\n\nboxplot_left &lt;- ggplot(faithful, aes(group, waiting, fill = group)) +\n  geom_boxplot() +\n  theme_classic() +\n  theme(\n    legend.position = \"none\", axis.ticks.x = element_blank(),\n    axis.text.x = element_blank(), axis.title.x = element_blank()\n  )\n\nboxplot_bottom &lt;- ggplot(faithful, aes(group, eruptions, fill = group)) +\n  geom_boxplot() +\n  theme_classic() +\n  theme(\n    legend.position = \"none\", axis.ticks.y = element_blank(),\n    axis.text.y = element_blank(), axis.title.y = element_blank()\n  ) +\n  coord_flip()\n\n加载 patchwork 包，使用函数 wrap_plots() 组合 boxplot_left 、scatterplot 、legend 和 boxplot_bottom 四个子图，最终效果见下图。\n\nlibrary(patchwork)\ntop &lt;- wrap_plots(boxplot_left, scatterplot, ncol = 2, widths = c(0.2, 0.8))\nbottom &lt;- wrap_plots(legend, boxplot_bottom, ncol = 2, widths = c(0.22, 0.8))\nfinal &lt;- wrap_plots(top, bottom, nrow = 2, heights = c(0.8, 0.2))\nfinal\n\n\n\n\n\n\n\n图 1.21: patchwork 组合多幅子图\n\n\n\n\n\n主图是占据着最大篇幅的叠加二维密度曲线的散点图，展示数据的二维分布，两个箱线图辅助展示等待时间 waiting 和喷发时间 eruptions 的分布，而左下角的图例是次要的说明。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-basic.html#sec-arts",
    "href": "visualization-basic.html#sec-arts",
    "title": "1  ggplot2 入门",
    "section": "1.11 艺术",
    "text": "1.11 艺术\nGeorgios Karamanis 基于 R 语言和扩展包 ggforce 制作了一系列生成艺术（Generative Arts）作品。下图是 ggforce 包的 4 个图层函数 geom_regon()、 geom_spiro()、 geom_diagonal() 和 geom_spoke() 分别生成的四幅图片。\nlibrary(ggforce)\ns &lt;- 900\nggplot() +\n  geom_regon(aes(\n    x0 = cos((1:s) / 57), y0 = sin((1:s) / 57),\n    sides = 6, r = cos((1:s) / 24),\n    angle = cos((1:s) / 23), color = 1:s %% 15\n  ),\n  linewidth = 0.2, fill = NA, linetype = \"twodash\"\n  ) +\n  scale_color_viridis_c(option = 15, guide = \"none\") +\n  coord_fixed() +\n  theme_void()\n\nr &lt;- seq(1, 11, 0.1)\nggplot() +\n  geom_spiro(aes(r = r, R = r * 20, d = r^2, outer = T, color = r %% 10), linewidth = 3) +\n  scale_color_viridis_c(option = \"turbo\") +\n  coord_fixed() +\n  theme_void() +\n  theme(legend.position = \"none\")\n\ns &lt;- 1200\nggplot() +\n  geom_diagonal(aes(\n    x = cos(seq(0, pi, length.out = s)),\n    y = sin(seq(0, pi, length.out = s)),\n    xend = cos(seq(0, 360 * pi, length.out = s)),\n    yend = sin(seq(0, 360 * pi, length.out = s))\n  ),\n  linewidth = 0.1, strength = 1\n  ) +\n  coord_fixed() +\n  theme_void()\n\ne &lt;- 1e-3\ns &lt;- 1e4\nt &lt;- pi / 2 * cumsum(seq(e, -e, length.out = s))^3\nggplot() +\n  geom_spoke(aes(\n    x = cumsum(cos(t)), y = cumsum(sin(t)),\n    angle = t, color = t, radius = 1:s %% 500\n  ), alpha = 0.5) +\n  scale_color_distiller(palette = 15, guide = \"none\") +\n  coord_fixed() +\n  theme_void()\n\n\n\n\n\n\n\n\n\n\n\n(a) 函数 geom_regon()\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 geom_spiro()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 函数 geom_diagonal()\n\n\n\n\n\n\n\n\n\n\n\n(d) 函数 geom_spoke()\n\n\n\n\n\n\n\n图 1.22: R 语言与生成艺术\n\n\n\n需要充满想象，或借助数学、物理方程，或借助算法、数据生成。好看，但没什么用的生成艺术作品。\n\nhttps://art-from-code.netlify.app/\nhttps://clauswilke.com/art/project/before-after\nhttps://clauswilke.com/art/\nhttps://art.djnavarro.net/\nhttps://www.data-imaginist.com/art\n\n\n\n\n\nArnold, Jeffrey B. 2021. ggthemes: Extra Themes, Scales and Geoms for ggplot2. https://CRAN.R-project.org/package=ggthemes.\n\n\nBion, Ricardo. 2018. ggtech: ggplot2 tech themes and scales.\n\n\nGarnier, Simon, Ross, Noam, Rudis, Robert, Camargo, 等. 2021. viridis: Colorblind-Friendly Color Maps for R. https://doi.org/10.5281/zenodo.4679424.\n\n\nGross, Calli, 和 Philipp Ottolinger. 2016. ggThemeAssist: Add-in to Customize ggplot2 Themes. https://CRAN.R-project.org/package=ggThemeAssist.\n\n\nHawkins, Oliver. 2022. pilot: A minimal ggplot2 theme with an accessible discrete color palette. https://github.com/olihawkins/pilot.\n\n\nHvitfeldt, Emil. 2021. paletteer: Comprehensive Collection of Color Palettes. https://github.com/EmilHvitfeldt/paletteer.\n\n\nKarambelkar, Bhaskar. 2016. colormap: Color Palettes using Colormaps Node Module. https://CRAN.R-project.org/package=colormap.\n\n\nKassambara, Alboukadel. 2022. ggpubr: ggplot2 Based Publication Ready Plots. https://CRAN.R-project.org/package=ggpubr.\n\n\nNeitmann, Thomas. 2020. ggcharts: Shorten the Distance from Data Visualization Idea to Actual Plot. https://CRAN.R-project.org/package=ggcharts.\n\n\nNeuwirth, Erich. 2022. RColorBrewer: ColorBrewer Palettes. https://CRAN.R-project.org/package=RColorBrewer.\n\n\nPedersen, Thomas Lin, 和 Fabio Crameri. 2022. scico: Colour Palettes Based on the Scientific Colour-Maps. https://CRAN.R-project.org/package=scico.\n\n\nSlowikowski, Kamil. 2021. ggrepel: Automatically Position Non-Overlapping Text Labels with ggplot2. https://CRAN.R-project.org/package=ggrepel.\n\n\nStylianou, Nassos, Will Dahlgreen, Robert Cuffe, Tom Calver, 和 Ransome Mpini. 2022. bbplot: making ggplot2 graphics in BBC NEWS style.\n\n\nTobin, Ciaran. 2020. ggthemr: Themes for ggplot2.\n\n\nWickham, Charlotte. 2018. munsell: Utilities for Using Munsell Colours. https://CRAN.R-project.org/package=munsell.\n\n\nWickham, Hadley, 和 Dana Seidel. 2022. scales: Scale Functions for Visualization. https://CRAN.R-project.org/package=scales.\n\n\nWilke, Claus O. 2020. ggtext: Improved Text Rendering Support for ggplot2. https://CRAN.R-project.org/package=ggtext.\n\n\nXiao, Nan. 2018. ggsci: Scientific Journal and Sci-Fi Themed Color Palettes for ggplot2. https://CRAN.R-project.org/package=ggsci.\n\n\nYu, Guangchuang. 2022. ggimage: Use Image in ggplot2. https://CRAN.R-project.org/package=ggimage.\n\n\nYutani, Hiroaki. 2022. string2path: Rendering Font into data.frame. https://CRAN.R-project.org/package=string2path.\n\n\nZeileis, Achim, Jason C. Fisher, Kurt Hornik, Ross Ihaka, Claire D. McWhite, Paul Murrell, Reto Stauffer, 和 Claus O. Wilke. 2020. 《colorspace: A Toolbox for Manipulating and Assessing Colors and Palettes》. Journal of Statistical Software 96 (1): 1–49. https://doi.org/10.18637/jss.v096.i01.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>ggplot2 入门</span>"
    ]
  },
  {
    "objectID": "visualization-intermediate.html",
    "href": "visualization-intermediate.html",
    "title": "2  基础图形",
    "section": "",
    "text": "2.1 描述趋势\n本章按照图形作用分类介绍各种各样的统计图形，每个小节包含 5-8 个常用的图形，每个图形会结合数据说明其作用、绘制代码。希望借助真实的数据引发读者兴趣，提出问题，探案数据，讲故事，将其应用于其它场景，举一反三。除了数据获取、清理和预处理的工作外，从原始数据出发，还将穿插介绍图形绘制相关的数据操作，比如适当的分组计算、数据重塑等操作。当然，不可能逐行给出代码的说明和使用，因为这会显得非常累赘。探索数据和绘制图形的过程中，会有很多的中间代码，这些也不再展示了，仅给出最终展示图，但会做适当说明。\nGNU R 是一个自由的统计计算和统计绘图环境，最初由新西兰奥克兰大学统计系的 Ross Ihaka 和 Robert Gentleman 共同开发。1997 年之后，成立了一个 R Core Team（R 语言核心团队），他们在版本控制系统 Apache Subversion上一起协作开发至今。25 年—四分之一个世纪过去了，下面分析他们留下的一份开发日志，了解一段不轻易为人所知的故事。\n首先，下载 1997 年至今约 25 年的原始代码提交日志数据。下载数据的代码如下，它是一行 Shell 命令，可在 MacOS 或 Ubuntu 等 Linux 系统的终端里运行，借助 Apache Subversion 软件，将提交日志导出为 XML 格式 的数据文件，保存在目录 data-raw/ 下，文件名为 svn_trunk_log_2022.xml，本书网页版随附。\nsvn log --xml --verbose -r 6:83528 \\\n  https://svn.r-project.org/R/trunk &gt; data-raw/svn_trunk_log_2022.xml\n去掉没什么信息的前5次代码提交记录：初始化仓库，上传原始的 R 软件源码等。 从 Ross Ihaka 在 1997-09-18 提交第 1 次代码改动开始，下载所有的提交日志。截至 2022-12-31，代码最新版本号为 83528，意味着代码仓库已存在 8 万多次提交。\n下载数据后，借助 xml2 包预处理这份 XML 格式数据，提取最重要的信息，谁在什么时间做了什么改动。经过一番操作后，将清洗干净的数据保存到目录 data/ 下，以 R 软件特有的文件格式保存为 svn-trunk-log-2022.rds，同样与书随附。这样下来，原 XML 格式保存的 35 M 文件减少为 1 M 多，极大地减少存储空间，方便后续的数据探索和可视化。下面是这份日志数据最初的两行：\nsvn_trunk_log &lt;- readRDS(file = \"data/svn-trunk-log-2022.rds\")\nhead(svn_trunk_log, 2)\n#&gt;   revision author               stamp\n#&gt; 1        6  ihaka 1997-09-18 04:41:25\n#&gt; 2        7  ihaka 1997-09-18 04:42:42\n#&gt;                                  msg\n#&gt; 1 New predict.lm from Peter Dalgaard\n#&gt; 2             Updated release number\n一共是四个字段，分别是代码提交时记录的版本号 revision，提交代码的人 author，提交代码的时间 stamp 和提交代码时伴随的说明 msg。接下来，带着问题一起探索开源自由的统计软件 R 过去 25 年波澜壮阔的历史！",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>基础图形</span>"
    ]
  },
  {
    "objectID": "visualization-intermediate.html#sec-visualize-data-trend",
    "href": "visualization-intermediate.html#sec-visualize-data-trend",
    "title": "2  基础图形",
    "section": "",
    "text": "2.1.1 折线图\n\n\n\n\n\n\n\n提示\n\n\n\n不再介绍每个函数、每个参数和每行代码的作用，而是重点阐述折线图的作用，以及如何解读数据，阐述解读的思路和方向，建立起数据分析的思维。将重点放在这些方面，有助于书籍存在的长远意义，又结合了最真实的背景和原始数据，相信对实际工作的帮助会更大。而对于使用到统计方法的函数，则详加介绍，展示背后的实现细节，而不是调用函数做调包侠。\n\n\n折线图的意义是什么？在表达趋势变化，趋势的解读很重要。先来了解一下总体趋势，即过去 25 年里代码提交次数的变化情况。数据集 svn_trunk_log 没有年份字段，但时间字段 stamp 隐含了年份信息，因此，新生成一个字段 year 将年份信息从 stamp 提取出来。\n\nsvn_trunk_log &lt;- within(svn_trunk_log, {\n  # 提取日期、月份、年份、星期、第几周、第几天等时间成分\n  year &lt;- as.integer(format(stamp, \"%Y\"))\n  date &lt;- format(stamp, format = \"%Y-%m-%d\", tz = \"UTC\")\n  month &lt;- format(stamp, format = \"%m\", tz = \"UTC\")\n  hour &lt;- format(stamp, format = \"%H\", tz = \"UTC\")\n  week &lt;- format(stamp, format = \"%U\", tz = \"UTC\")\n  wday &lt;- format(stamp, format = \"%a\", tz = \"UTC\")\n  nday &lt;- format(stamp, format = \"%j\", tz = \"UTC\")\n})\n# 代码维护者 ID 和姓名对应\nctb_map &lt;- c(\n  \"bates\" = \"Douglas Bates\", \"deepayan\" = \"Deepayan Sarkar\",\n  \"duncan\" = \"Duncan Temple Lang\", \"falcon\" = \"Seth Falcon\",\n  \"guido\" = \"Guido Masarotto\", \"hornik\" = \"Kurt Hornik\",\n  \"iacus\" = \"Stefano M. Iacus\", \"ihaka\" = \"Ross Ihaka\",\n  \"jmc\" = \"John Chambers\", \"kalibera\" = \"Tomas Kalibera\",\n  \"lawrence\" = \"Michael Lawrence\", \"leisch\" = \"Friedrich Leisch\",\n  \"ligges\" = \"Uwe Ligges\", \"luke\" = \"Luke Tierney\",\n  \"lyndon\" = \"Others\", \"maechler\" = \"Martin Maechler\",\n  \"mike\" = \"Others\", \"morgan\" = \"Martin Morgan\",\n  \"murdoch\" = \"Duncan Murdoch\", \"murrell\" = \"Paul Murrell\",\n  \"pd\" = \"Peter Dalgaard\", \"plummer\" = \"Martyn Plummer\",\n  \"rgentlem\" = \"Robert Gentleman\", \"ripley\" = \"Brian Ripley\",\n  \"smeyer\" = \"Sebastian Meyer\", \"system\" = \"Others\",\n  \"tlumley\" = \"Thomas Lumley\", \"urbaneks\" = \"Simon Urbanek\"\n)\nsvn_trunk_log$author &lt;- ctb_map[svn_trunk_log$author]\n\n接着，调用分组聚合函数 aggregate() 统计各年的代码提交量。\n\ntrunk_year &lt;- aggregate(data = svn_trunk_log, revision ~ year, FUN = length)\n\n然后，将数据集 trunk_year 以折线图展示，如 图 2.1 所示。\n\nlibrary(ggplot2)\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_line() +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n图 2.1: 过去 25 年代码提交次数的变化情况\n\n\n\n\n\n为什么呈现这样的变化趋势？我最初想到的是先逐步增加，然后下降一会儿，再趋于平稳。这比较符合软件从快速迭代开发期，过渡到成熟稳定期的生命周期。接着，从小时趋势图观察代码提交量的变化，发现有高峰有低谷，上午高峰，晚上低峰，但也并不是所有年份都一致，这是因为开发者来自世界各地，位于不同的时区。\n\naggregate(data = svn_trunk_log, revision ~ year + hour, length) |&gt; \n  ggplot(aes(x = hour, y = revision, group = year)) +\n  geom_line() +\n  geom_line(data = function(x) subset(x, year &lt; 2006),\n            aes(color = as.character(year))) +\n  theme_classic() +\n  labs(x = \"时段\", y = \"提交量\", color = \"年份\")\n\n\n\n\n\n\n\n图 2.2: 提交代码的时段分布\n\n\n\n\n\n最后，观察代码提交量的月趋势图，12月和次年1月、7-8 月份提交量迎来小高峰，应该是教授们放寒暑假。\n\naggregate(data = svn_trunk_log, revision ~ year + month, length) |&gt;\n  transform(date = as.Date(paste(year, month, \"01\", sep = \"-\"))) |&gt;\n  ggplot(aes(x = date, y = revision)) +\n  geom_point(aes(color = factor(year)), show.legend = F, size = 0.75) +\n  geom_line(aes(color = factor(year)), show.legend = F) +\n  scale_x_date(date_minor_breaks = \"1 year\") +\n  theme_classic() +\n  theme(panel.grid.minor.x = element_line()) +\n  labs(x = \"时间（月粒度）\", y = \"提交量\")\n\n\n\n\n\n\n\n图 2.3: 提交代码的月份分布\n\n\n\n\n\n\n\n2.1.2 瀑布图\n相比于折线图，瀑布图将变化趋势和增减量都展示了，如 图 2.4 所示，每年的提交量就好像瀑布上的水，图中每一段水柱表示当期相对于上一期的增减量。瀑布图是用矩形图层 geom_rect() 构造的，数据点作为矩形对角点，对撞型的颜色表示增减。\n\ntrunk_year &lt;- trunk_year[order(trunk_year$year), ]\n\ntrunk_year_tmp &lt;- data.frame(\n  xmin = trunk_year$year[-length(trunk_year$year)],\n  ymin = trunk_year$revision[-length(trunk_year$revision)],\n  xmax = trunk_year$year[-1],\n  ymax = trunk_year$revision[-1],\n  fill = trunk_year$revision[-1] - trunk_year$revision[-length(trunk_year$revision)] &gt; 0\n)\n\nggplot() +\n  geom_rect(\n    data = trunk_year_tmp,\n    aes(xmin = xmin, ymin = ymin, xmax = xmax, ymax = ymax, fill = fill\n), \n    show.legend = FALSE\n  ) +\n  geom_point(\n    data = trunk_year, aes(x = year, y = revision), size = 0.75\n  ) +\n  scale_fill_brewer(palette = \"Set2\") +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n图 2.4: 25 年代码逐年提交量的变化趋势\n\n\n\n\n\nggTimeSeries 包 (Kothari 2022) (https://github.com/thecomeonman/ggTimeSeries) 提供统计图层 stat_waterfall() 实现类似的瀑布图，如 图 2.5 所示。\n\nlibrary(ggTimeSeries)\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  stat_waterfall() +\n  scale_fill_brewer(palette = \"Set2\") +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n图 2.5: 矩形图层构造瀑布图\n\n\n\n\n\n\n\n2.1.3 曲线图\n\n将散点以线段逐个连接起来，形成折线图，刻画原始的变化，而曲线图的目标是刻画潜在趋势。有两种画法，其一从代数的角度出发，做插值平滑，在相邻两点之间以一条平滑的曲线连接起来；其二从统计的角度出发，做趋势拟合，通过线性或非线性回归，获得变化趋势，以图呈现，使得散点之中隐藏的趋势更加清晰。\nggplot2 (Wickham 2016) 包提供函数 geom_smooth() 拟合散点图中隐含的趋势，通过查看函数 geom_smooth() 的帮助文档，可以了解其内部调用的统计方法。默认情况下，采用局部多项式回归拟合方法，内部调用了函数 loess() 来拟合趋势，如 图 2.6 所示。\n\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(data = subset(trunk_year, year != 1997)) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n#&gt; `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n图 2.6: 过去 25 年代码提交次数的变化情况\n\n\n\n\n\n类似大家熟悉的线性回归拟合函数 lm()，函数 loess() 也是基于类似的使用语法。下面继续以此数据为例，了解该函数的使用，继而了解 ggplot2 绘制平滑曲线图背后的统计方法。1997 年是不完整的，不参与模型参数的估计。\n\ntrunk_year_loess &lt;- loess(revision ~ year,\n  data = subset(trunk_year, year != 1997),\n  span = 0.75, degree = 2, method = \"loess\",\n  family = \"symmetric\",\n  control = loess.control(surface = \"direct\", iterations = 4)\n)\n\n下面通过设定函数 geom_smooth() 的参数，可以达到一样的效果，见下 图 2.7\n\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(method = \"loess\", formula = \"y~x\",\n    method.args = list(\n      span = 0.75, degree = 2, family = \"symmetric\",\n      control = loess.control(surface = \"direct\", iterations = 4)\n    ), data = subset(trunk_year, year != 1997)) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n图 2.7: 过去 25 年代码提交次数的变化情况\n\n\n\n\n\nmethod = \"loess\" 意味着调用了一种非参数的回归方法，即局部估计散点平滑 （locally estimated scatterplot smoothing），另一个与之类似的回归方法是局部加权散点平滑 （locally weighted scatterplot smoothing），简称 lowess 。1991 年 Jerome Friedman 提出多元适应性回归样条（Multivariate Adaptive Regression Splines），R 语言社区对应功能的扩展包是 earth 。\n除了 method = \"loess\"，函数 geom_smooth() 支持的统计方法还有很多，比如非线性回归拟合 nls()\n\ntrunk_year_nls &lt;- nls(revision ~ a * (year - 1996)^2 + b,\n  data = subset(trunk_year, year != 1997),\n  start = list(a = -0.1, b = 1000)\n)\n\n采用一元二次非线性回归拟合方法，效果如 图 2.8 所示。\n\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(\n    method = \"nls\", \n    formula = \"y ~ a * (x - 1996)^2 + b\",\n    method.args = list(\n      start = list(a = -0.1, b = 1000)\n    ), se = FALSE, \n    data = subset(trunk_year, year != 1997),\n  ) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n图 2.8: 过去 25 年代码提交次数的变化情况\n\n\n\n\n\n\n\n\n\n\n\n注意\n\n\n\n在函数 geom_smooth() 内调用非线性回归拟合方法时，暂不支持提供置信区间。\n\n\n即便在不清楚统计原理的情况下，也不难看出 图 2.7 和 图 2.8 的差异，局部多项式回归捕捉到了更多的信息，特别是起步阶段的上升趋势，以及 2000-2005 年的高峰特点。\n\nsummary(trunk_year_loess)\n#&gt; Call:\n#&gt; loess(formula = revision ~ year, data = subset(trunk_year, year != \n#&gt;     1997), span = 0.75, degree = 2, family = \"symmetric\", method = \"loess\", \n#&gt;     control = loess.control(surface = \"direct\", iterations = 4))\n#&gt; \n#&gt; Number of Observations: 25 \n#&gt; Equivalent Number of Parameters: 4.53 \n#&gt; Residual Scale Estimate: 308.4 \n#&gt; Trace of smoother matrix: 4.97  (exact)\n#&gt; \n#&gt; Control settings:\n#&gt;   span     :  0.75 \n#&gt;   degree   :  2 \n#&gt;   family   :  symmetric      iterations = 4\n#&gt;   surface  :  direct\n#&gt;   normalize:  TRUE\n#&gt;  parametric:  FALSE\n#&gt; drop.square:  FALSE\n\n\nsummary(trunk_year_nls)\n#&gt; \n#&gt; Formula: revision ~ a * (year - 1996)^2 + b\n#&gt; \n#&gt; Parameters:\n#&gt;    Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; a   -2.9625     0.4555  -6.504 1.23e-06 ***\n#&gt; b 3070.0890   147.1920  20.858  &lt; 2e-16 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 471.8 on 23 degrees of freedom\n#&gt; \n#&gt; Number of iterations to convergence: 1 \n#&gt; Achieved convergence tolerance: 2.808e-08\n\n非线性回归模型带有 2 个参数，一共 26 个观察值，因此，自由度为 26 - 2 = 24。 RSE 残差平方和的标准差为\n\n# 非线性回归的残差平方和的标准差\nsqrt(sum(residuals(trunk_year_nls)^2)/24)\n#&gt; [1] 461.8963\n\n以平滑曲线连接相邻的散点，可以构造一个插值方法给函数 geom_smooth()，如下示例基于样条插值函数 spline()。样条源于德国宝马工程师，车辆外壳弧线，那些拥有非常漂亮的弧线，越光滑，与空气的摩擦阻力越小，车辆的气动外形更加符合流体力学的要求，加工打磨更加困难，往往价值不菲。美感是相通的，即使不懂车标，通过气动外形，也能识别出车辆的档次。\nggplot2 包支持的平滑方法有很多，如借助函数 splinefun() 构造样条插值获得平滑曲线，调用 mgcv 包的函数 gam() ，调用 ggalt 包的函数 geom_xspline() 。\nxxspline &lt;- function(formula, data, ...) {\n  dat &lt;- model.frame(formula, data)\n  res &lt;- splinefun(dat[[2]], dat[[1]])\n  class(res) &lt;- \"xxspline\"\n  res\n}\n\npredict.xxspline &lt;- function(object, newdata, ...) {\n  object(newdata[[1]])\n}\n\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(\n    formula = \"y~x\",\n    method = xxspline, se = FALSE,\n    data = subset(trunk_year, year != 1997)\n  ) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(\n    formula = y ~ s(x, k = 12),\n    method = \"gam\", se = FALSE,\n    data = subset(trunk_year, year != 1997)\n  ) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\nggplot(data = trunk_year, aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(\n    method = \"lm\", \n    formula = \"y ~ poly((x - 1996), 3)\",\n    se = FALSE, \n    data = subset(trunk_year, year != 1997),\n  ) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n\n\n\n\n(a) 自定义样条插值 spline\n\n\n\n\n\n\n\n\n\n\n\n(b) 广义可加模型样条拟合\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 自由度为 3 的正交多项式拟合\n\n\n\n\n\n\n\n图 2.9: 过去 25 年代码提交次数的变化情况\n\n\n\n数学公式表达的统计模型与 R 语言表达的计算公式的对应关系见下 表 2.1 ，更多详情见帮助文档 ?formula。\n\n\n\n表 2.1: 数学公式与 R 语言表示的计算公式\n\n\n\n\n\n\n\n\n\n数学公式\nR 语言计算公式\n\n\n\n\n\\(y = \\beta_0\\)\ny ~ 1\n\n\n\\(y = \\beta_0 + \\beta_1 x_1\\)\ny ~ 1 + x1 或 y ~ x1 或 y ~ x1 + x1^2\n\n\n\\(y = \\beta_1 x_1\\)\ny ~ 0 + x1 或 y ~ -1 + x1\n\n\n\\(y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2\\)\ny ~ x1 + x2\n\n\n\\(y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_1 x_2\\)\ny ~ x1 * x2\n\n\n\\(y = \\beta_0 + \\beta_1 x_1 x_2\\)\ny ~ x1:x2\n\n\n\\(y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_1 x_2\\)\ny ~ x1 + x2 + x1:x2\n\n\n\\(y = \\beta_0 + \\sum_{i=1}^{999}\\beta_i x_i\\)\ny ~ .\n\n\n\\(y = \\beta_0 + \\beta_1 x + \\beta_2 x^5\\)\ny ~ x + I(x^5)\n\n\n\\(y = \\beta_0 + \\beta_1 x + \\beta_2 x^2\\)\ny ~ x + I(x^2)\n\n\n\\(y = \\beta_0 + \\beta_1 x + \\beta_2 x^2\\)\ny ~ poly(x, degree = 2, raw = TRUE)\n\n\n\n\n\n\n\n\n2.1.4 流线图\n流线图（Stream Graph）是堆积面积图（Stacked Area Graph）的一种变体，适合描述时间序列数据的趋势。ggplot2 扩展包 ggstream 可以制作流线图，如下图所示。\n\nlibrary(ggstream)\ntrunk_year_author &lt;- aggregate(data = svn_trunk_log, revision ~ year + author, FUN = length)\nggplot(trunk_year_author, aes(x = year, y = revision, fill = author)) +\n  geom_stream() +\n  theme_classic() +\n  theme(legend.position = \"bottom\") +\n  labs(x = \"年份\", y = \"提交量\", fill = \"贡献者\")\n\n\n\n\n\n\n\n图 2.10: 各开发者的提交量趋势\n\n\n\n\n\n\n\n2.1.5 曲面图\nggplot2 包暂不支持绘制三维曲面图，而 lattice 包支持，但也是非常有限的支持。lattice 包和 ggplot2 包都是基于图形语法的，层层叠加就必然会出现覆盖，只有在绘制函数型数据的图像时是合适的，因为覆盖少，即使覆盖也不妨碍趋势的表达。根据不同的使用场景有两个更好的选择，基于 OpenGL 的真三维图形可以用 rayrender 和 rayshader 包绘制，而基于 JavaScripts 的交互式三维图形可以用 rgl 或 plotly 包绘制。\n下 图 2.11 是用 lattice 包的 wireframe() 函数绘制的，这是一个三维曲面透视图，三维图形有时候并不能很好地表达数据，或者数据并不适合用三维图形表示。数据本身并没有那么明显的趋势规律，同样也会体现不出三维图形的表达能力。大部分情况下，我们应当避免使用静态的三维图形，但函数型数据是适合用三维图形来表达的。\n\n\n代码\ntrunk_year_week &lt;- aggregate(data = svn_trunk_log, revision ~ year + week, FUN = length)\nlibrary(lattice)\nwireframe(\n  data = trunk_year_week, revision ~ year * as.integer(week),\n  shade = TRUE, drape = FALSE,\n  xlab = \"年份\",\n  ylab = \"第几周\",\n  zlab = list(\"提交量\", rot = 90),\n  scales = list(\n    arrows = FALSE, col = \"black\"\n  ),\n  # 减少三维图形的边空\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -.6, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -.8, units = \"inches\"),\n      top.padding = list(x = -1.0, units = \"inches\")\n    )\n  ),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = -60, x = -70, y = 0)\n)\n\n\n\n\n\n\n\n\n图 2.11: 25 年代码提交量变化趋势图\n\n\n\n\n\n每周的代码提交量受影响因素多，不确定性多，波动表现尖锐高频，上图反而对整体趋势的表达不够简洁清晰。按年、月统计提交量平均掉了每日的波动，反而可以体现更大的周期性和趋势性。下面绘制三维柱形图，三维图形天然给人有更加直观的感觉，毕竟立体。latticeExtra 包提供三维柱形图图层 panel.3dbars()，如 图 2.12 所示。\n\n\n代码\n# 按年、月分组统计代码提交量\ntrunk_year_month &lt;- aggregate(\n  data = svn_trunk_log,\n  revision ~ year + month, FUN = length\n)\n# 数据转化为矩阵类型\ntrunk_year_month_m &lt;- matrix(\n  data = trunk_year_month[trunk_year_month$year &gt; 1998, \"revision\"],\n  ncol = 12, nrow = 24, byrow = FALSE,\n  dimnames = list(\n    1999:2022, # 行\n    1:12 # 列\n  )\n)\n# 绘制三维柱形图\ncloud(trunk_year_month_m,\n  panel.3d.cloud = latticeExtra::panel.3dbars,\n  col.facet = \"red\", # 柱子的颜色\n  col = \"gray90\",\n  xbase = 0.5, ybase = 0.5, # 柱子的大小\n  scales = list(\n    arrows = FALSE, col = \"black\",\n    # tck 刻度线的长度\n    tck = c(0.7, 1.5, 1),\n    # distance 控制标签到轴的距离\n    distance = c(1.2, 0.6, 0.8)\n  ),\n  # rot 旋转轴标签\n  xlab = list(\"年份\", rot = -45), ylab = list(\"月份\", rot = 45),\n  zlab = list(\"提交量\", rot = 90),\n  # 减少三维图形的边空\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -.6, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -.8, units = \"inches\"),\n      top.padding = list(x = -1.0, units = \"inches\")\n    )\n  ),\n  # 去掉边框\n  par.settings = list(\n    axis.line = list(col = \"transparent\"),\n    layout.widths = list(ylab.axis.padding = 0)\n  ),\n  screen = list(z = -45, x = -30, y = 0)\n)\n\n\n\n\n\n\n\n\n图 2.12: 25 年代码提交量变化趋势图\n\n\n\n\n\n\n\n2.1.6 热力图\n图 2.13 提交量变化趋势\n\nggplot(data = trunk_year_week, aes(x = as.integer(week) , y = year, fill = revision)) +\n  geom_tile(linewidth = 0.4) +\n  scale_fill_viridis_c(option = \"C\") +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  theme_classic() +\n  labs(x = \"第几周\", y = \"年份\", fill = \"提交量\")\n\n\n\n\n\n\n\n图 2.13: 25 年代码提交量变化热力图\n\n\n\n\n\n图层 scale_x_continuous() 中设置 expand = c(0, 0) 可以去掉数据与 x 轴之间的空隙。 或者添加坐标参考系图层 coord_cartesian()，设置参数 expand = FALSE 同时去掉横纵轴与数据之间的空隙。\n\naggregate(data = svn_trunk_log, revision ~ year + month, length) |&gt;\n  ggplot(aes(x = month, y = year, fill = revision)) +\n  geom_tile(linewidth = 0.4) +\n  scale_fill_viridis_c(option = \"C\") +\n  coord_cartesian(expand = FALSE) +\n  theme_classic() +\n  labs(x = \"月份\", y = \"年份\", fill = \"提交量\")\n\n\n\n\n\n\n\n图 2.14: 25 年代码提交量变化热力图\n\n\n\n\n\n\n\n2.1.7 日历图\n更加直观地展示出节假日、休息工作日、寒暑假，比如描述学生学习规律、需求的季节性变化、周期性变化。\n\n# 星期、月份缩写\nweek.abb &lt;- c(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\")\nmonth.abb &lt;- c(\n  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"\n)\n# 按年、星期、第几周聚合统计提交量数据\nsvn_trunk_year &lt;- aggregate(\n  revision ~ year + wday + week, FUN = length,\n  data = svn_trunk_log, subset = year %in% 2018:2022\n)\n# 第几周转为整型数据\n# 周几转为因子型数据\nsvn_trunk_year &lt;- within(svn_trunk_year, {\n   week = as.integer(week)\n   wday = factor(wday, labels = week.abb)\n})\n\n\nggplot(data = svn_trunk_year, aes(\n  x = week, y = wday, fill = cut(revision, breaks = 5 * 0:5)\n)) +\n  geom_tile(color = \"white\", linewidth = 0.5) +\n  scale_fill_brewer(palette = \"Greens\") +\n  scale_x_continuous(\n    expand = c(0, 0), breaks = seq(1, 52, length = 12), labels = month.abb\n  ) +\n  facet_wrap(~year, ncol = 1) +\n  theme_minimal() +\n  labs(x = \"月份\", y = \"星期\", fill = \"提交量\")\n\n\n\n\n\n\n\n图 2.15: 最近 5 年休息和工作日打码活跃度\n\n\n\n\n\n经过了解 svn_trunk_year 2018 - 2022 年每天提交量的范围是 0 次到 21 次，0 次表示当天没有提交代码，SVN 上也不会有日志记录。因此，将提交量划分为 5 档\n\n\n2.1.8 棋盘图\n棋盘图一般可以放所有时间节点的聚合信息，格点处为落的子\n该数据集的存储结构很简单，是一个两列的数据框，它的一些属性如下：\n\nstr(rversion)\n#&gt; 'data.frame':    140 obs. of  2 variables:\n#&gt;  $ version: chr  \"0.49\" \"0.50-a1\" \"0.50-a4\" \"0.60.0\" ...\n#&gt;  $ date   : chr  \"1997-04-23\" \"1997-07-22\" \"1997-09-10\" \"1997-12-04\" ...\n\n做一点数据处理，将 date 字段转为日期类型，并从日期中提取年、月信息。\n\nrversion$date &lt;- as.Date(rversion$date, format = \"%Y-%m-%d\", tz = \"UTC\")\nrversion$year &lt;- format(rversion$date, \"%Y\")\nrversion$month &lt;- format(rversion$date, \"%m\")\n\n统计过去 25 年里每月的发版次数，如图 图 2.16\n\naggregate(data = rversion, version ~ year + month, length) |&gt;\n  ggplot(aes(x = month, y = year)) +\n  geom_label(aes(label = version, fill = version),\n    show.legend = F, color = \"white\") +\n  scale_fill_viridis_c(option = \"D\", begin = 0.2, end = 0.8) +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray95\")) +\n  labs(x = \"月份\", y = \"年份\")\n\n\n\n\n\n\n\n图 2.16: 25 年 R 软件发版情况\n\n\n\n\n\n\n\n2.1.9 时间线图\n时间线图非常适合回顾过去，展望未来，讲故事\n时间线图展示信息的层次和密度一般由时间跨度决定。时间跨度大时，展示重点节点信息，时间跨度小时，重点和次重点信息都可以放。从更加宏观的视角，厘清发展脉络，比如近两年的 R 软件发版情况。\n本节用到一个数据集 rversion，记录了历次 R 软件发版时间及版本号，见 表 2.2\n\n\n\n\n表 2.2: R 软件发版数据集（部分）\n\n\n\n\n\n\n版本号\n发版日期\n发版年份\n发版月份\n\n\n\n\n0.49\n1997-04-23\n1997\n04\n\n\n0.50-a1\n1997-07-22\n1997\n07\n\n\n0.50-a4\n1997-09-10\n1997\n09\n\n\n0.60.0\n1997-12-04\n1997\n12\n\n\n0.60.1\n1997-12-07\n1997\n12\n\n\n0.61.0\n1997-12-22\n1997\n12\n\n\n\n\n\n\n\n\n\nrversion_tl &lt;- within(rversion, {\n  # 版本号为 x.0.0 为重大版本 big\n  # 版本号为 x.1.0 x.12.0 x.20.0 为主要版本 major\n  # 版本号为 x.0.1 为次要版本 minor\n  status &lt;- ifelse(grepl(pattern = \"*\\\\.0\\\\.0\", x = version), \"big\", version)\n  status &lt;- ifelse(grepl(pattern = \"*\\\\.[1-9]{1,2}\\\\.0$\", x = status), \"major\", status)\n  status &lt;- ifelse(!status %in% c(\"big\", \"major\"), \"minor\", status)\n})\npositions &lt;- c(0.5, -0.5, 1.0, -1.0, 1.5, -1.5)\ndirections &lt;- c(1, -1)\n# 位置\nrversion_pos &lt;- data.frame(\n  # 只要不是同一天发布的版本，方向相对\n  date = unique(rversion_tl$date),\n  position = rep_len(positions, length.out = length(unique(rversion_tl$date))),\n  direction = rep_len(directions, length.out = length(unique(rversion_tl$date)))\n)\n# 原始数据上添加方向和位置信息\nrversion_df &lt;- merge(x = rversion_tl, y = rversion_pos, by = \"date\", all = TRUE)\n# 最重要的状态放在最后绘制到图上\nrversion_df &lt;- rversion_df[with(rversion_df, order(date, status)), ]\n\n选取一小段时间内的发版情况，比如最近的三年 — 2020 - 2022 年\n\n# 选取 2020 - 2022 年的数据\nsub_rversion_df&lt;- rversion_df[rversion_df$year %in% 2020:2022, ]\n# 月份注释\nmonth_dat &lt;- data.frame(\n  date = seq(from = as.Date('2020-01-01'), to = as.Date('2022-12-31'), by = \"3 month\")\n)\nmonth_dat &lt;- within(month_dat, {\n  month = format(date, \"%b\")\n})\n# 年份注释\nyear_dat &lt;- data.frame(\n  date = seq(from = as.Date('2020-01-01'), to = as.Date('2022-12-31'), by = \"1 year\")\n)\nyear_dat &lt;- within(year_dat, {\n  year = format(date, \"%Y\")\n})\n\n图 2.17 展示 2020-2022 年 R 软件发版情况\n\nggplot(data = sub_rversion_df) +\n  geom_segment(aes(x = date, y = 0, xend = date, yend = position)) +\n  geom_hline(yintercept = 0, color = \"black\", linewidth = 1) +\n  geom_label(\n    aes(x = date, y = position, label = version, color = status),\n    show.legend = FALSE\n  ) +\n  geom_point(aes(x = date, y = 0, color = status),\n    size = 3, show.legend = FALSE\n  ) +\n  geom_text(\n    data = month_dat, aes(x = date, y = 0, label = month), vjust = 1.5\n  ) +\n  geom_text(\n    data = year_dat, aes(x = date, y = 0, label = year), vjust = -0.5\n  ) +\n  theme_void()\n\n\n\n\n\n\n\n图 2.17: 2020-2022 年 R 软件发版情况\n\n\n\n\n\n图中红色标注的是里程碑式的重大版本，绿色标注的是主要版本，蓝色标注的次要版本，小修小补，小版本更新。\n当时间跨度非常大时，比如过去 25 年，那就只能放重大版本和主要版本信息了，时间上月份信息就不能用名称简写，而用数字更加合适。而且还得竖着放，同时添加那个版本最有影响力的改动。相比于，棋盘图，这是时间线图的优势。\n\nsub_rversion_df2 &lt;- rversion_df[rversion_df$status %in% c(\"big\", \"major\"), ]\nggplot(data = sub_rversion_df2) +\n  geom_segment(aes(x = 0, y = date, xend = position, yend = date, color = status),\n    show.legend = F\n  ) +\n  geom_vline(xintercept = 0, color = \"black\", linewidth = 1) +\n  geom_label(\n    aes(x = position, y = date, label = version, color = status),\n    show.legend = FALSE\n  ) +\n  geom_point(aes(x = 0, y = date, color = status), size = 3, show.legend = FALSE) +\n  geom_text(\n    aes(x = 0, y = as.Date(format(date, \"%Y-01-01\")), label = year),\n    hjust = -0.1\n  ) +\n  theme_void()\n\n\n\n\n\n\n\n图 2.18: 25 年里 R 软件重大及主要版本发布情况\n\n\n\n\n\n在 R 语言诞生的前 5 年里，每年发布 3 个主要版本，这 5 年是 R 软件活跃开发的时期。而 2003-2012 年的这 10 年，基本上每年发布 2 个主要版本。2013-2022 年的这 10 年，基本上每年发布 1 个主要版本。\ntimevis 包基于 JavaScript 库 Vis 的 vis-timeline 模块，可以 创建交互式的时间线图，支持与 Shiny 应用集成。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>基础图形</span>"
    ]
  },
  {
    "objectID": "visualization-intermediate.html#sec-visualize-data-comparisons",
    "href": "visualization-intermediate.html#sec-visualize-data-comparisons",
    "title": "2  基础图形",
    "section": "2.2 描述对比",
    "text": "2.2 描述对比\n数据来自中国国家统计局发布的2021年统计年鉴，\n\n\n\n\n表 2.3: 中国各年龄段的性别比数据（部分）\n\n\n\n\n\n\n年龄\n人口数/男\n人口数/女\n性别比（女=100）\n区域\n\n\n\n\n0-4\n16078524\n14523013\n110.71\n城市\n\n\n5-9\n17172999\n15087731\n113.82\n城市\n\n\n10-14\n14619691\n12727731\n114.86\n城市\n\n\n15-19\n17249362\n15404683\n111.97\n城市\n\n\n20-24\n19776472\n18481665\n107.01\n城市\n\n\n25-29\n22937131\n21478748\n106.79\n城市\n\n\n\n\n\n\n\n\n对比的是什么？城市、镇和乡村的性别分布，是否失衡？在哪个年龄段表现很失衡？\n\n2.2.1 柱形图\n分年龄段比较城市、镇和乡村的性别比数据\n\nggplot(data = china_age_sex, aes(x = `年龄`, y = `性别比（女=100）`, fill = `区域`)) +\n  geom_hline(yintercept = 100, color = \"gray\", lty = 2, linewidth = 1) +\n  geom_col(position = \"dodge2\", width = 0.75) +\n  theme_bw()\n\n\n\n\n\n\n\n图 2.19: 分年龄段比较城市、镇和乡村的性别比数据\n\n\n\n\n\n考虑到数据本身的含义，一般来说，性别比不可能从 0 开始，除非现实中出现了《西游记》里的女儿国。因此，将纵轴的范围，稍加限制，从 性别比为 70 开始，目的是突出城市、镇和乡村的差异。\n\nggplot(data = china_age_sex, aes(x = `年龄`, y = `性别比（女=100）`, fill = `区域`)) +\n  geom_hline(yintercept = 100, color = \"gray\", lty = 2, linewidth = 1) +\n  geom_col(position = \"dodge2\", width = 0.75) +\n  coord_cartesian(ylim = c(70, 130)) +\n  theme_bw()\n\n\n\n\n\n\n\n图 2.20: 分年龄段比较城市、镇和乡村的性别比数据\n\n\n\n\n\n\n\n2.2.2 条形图\n将柱形图横过来即可得到条形图，横过来的好处主要体现在分类很多的时候，留足空间给年龄分组的分类标签，从左到右，从上往下也十分符合大众的阅读习惯\n\nggplot(data = china_age_sex, aes(x = `性别比（女=100）`, y = `年龄`, fill = `区域`)) +\n  geom_vline(xintercept = 100, color = \"gray\", lty = 2, linewidth = 1) +\n  geom_col(position = \"dodge2\", width = 0.75) +\n  coord_cartesian(xlim = c(70, 130)) +\n  theme_bw()\n\n\n\n\n\n\n\n图 2.21: 分年龄段比较城市、镇和乡村的性别比数据\n\n\n\n\n\n\n\n2.2.3 点线图\n克利夫兰点图 dotchart() 在条形图的基础上，省略了条形图的宽度，可以容纳更多的数据点。\n\nggplot(data = china_age_sex, aes(x = `性别比（女=100）`, y = `年龄`, color = `区域`)) +\n  geom_vline(xintercept = 100, color = \"lightgray\", lty = 2, linewidth = 1) +\n  geom_point() +\n  theme_bw()\n\n\n\n\n\n\n\n图 2.22: 分年龄段比较城市、镇和乡村的性别比数据\n\n\n\n\n\n\n\n2.2.4 词云图\nggwordcloud 包提供词云图层 geom_text_wordcloud() 根据代码提交的说明制作词云图。\n\nlibrary(ggwordcloud)\naggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt; \n  ggplot(aes(label = author, size = revision)) +\n  geom_text_wordcloud(seed = 2022, grid_size = 10, max_grid_size = 24) +\n  scale_size_area(max_size = 20)\n\n\n\n\n\n\n\n图 2.23: 词云图\n\n\n\n\n\n词云图也可以是条形图或柱形图的一种替代，词云图不用担心数目多少，而条形图不适合太多的分类情形。\n\naggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt;\n  subset(subset = revision &gt;= 100) |&gt; \n  ggplot(aes(x = revision, y = reorder(author, revision))) +\n  geom_col() +\n  theme_classic() +\n  coord_cartesian(expand = FALSE) +\n  labs(x = \"提交量\", y = \"维护者\")\n\n\n\n\n\n\n\n图 2.24: 开发者提交量排行榜",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>基础图形</span>"
    ]
  },
  {
    "objectID": "visualization-intermediate.html#sec-visualize-data-proportion",
    "href": "visualization-intermediate.html#sec-visualize-data-proportion",
    "title": "2  基础图形",
    "section": "2.3 描述占比",
    "text": "2.3 描述占比\n\n2.3.1 简单饼图\n提交量小于 2000 次的贡献者合并为一类 Others，按贡献者分组统计提交量及其占比，如 图 2.25 所示。\n\naggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt;\n  transform(author2 = ifelse(revision &lt; 2000, \"Others\", author)) |&gt;\n  aggregate(revision ~ author2, FUN = sum) |&gt;\n  transform(label = paste0(round(revision / sum(revision), digits = 4) * 100, \"%\")) |&gt;\n  ggplot(aes(x = 1, fill = reorder(author2, revision), y = revision)) +\n  geom_col(position = \"fill\", show.legend = FALSE, color = \"white\") +\n  scale_y_continuous(labels = scales::label_percent()) +\n  coord_polar(theta = \"y\") +\n  geom_text(aes(x = 1.2, label = author2),\n    position = position_fill(vjust = 0.5), color = \"black\"\n  ) +\n  geom_text(aes(x = 1.65, label = label),\n    position = position_fill(vjust = 0.5), color = \"black\"\n  ) +\n  theme_void() +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n图 2.25: 维护者提交量占比\n\n\n\n\n\n当把提交量小于 1000 次的贡献者合并为 Others，则分类较多，占比小的也有一席之地，饼图上显得十分拥挤。\n\naggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt; \n  transform(author2 = ifelse(revision &lt; 1000, \"Others\", author)) |&gt; \n  aggregate(revision ~ author2, FUN = sum) |&gt; \n  transform(label = paste0(round(revision / sum(revision), digits = 4) * 100, \"%\")) |&gt; \n  ggplot(aes(x = 1, fill = reorder(author2, revision)  , y = revision)) +\n  geom_col(position = \"fill\", show.legend = FALSE, color = \"white\") +\n  scale_y_continuous(labels = scales::label_percent()) +\n  coord_polar(theta = \"y\") +\n  geom_text(aes(x = 1.2, label = author2),\n    position = position_fill(vjust = 0.5), color = \"black\"\n  ) +\n  geom_text(aes(x = 1.6, label = label),\n    position = position_fill(vjust = 0.5), color = \"black\"\n  ) +\n  theme_void() +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n图 2.26: 维护者提交量占比\n\n\n\n\n\n一种缓解拥挤的办法是通过 ggrepel 包在扇形区域旁边添加注释\n\nlibrary(ggrepel)\ndat1 &lt;- aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt;\n  transform(author2 = ifelse(revision &lt; 1000, \"Others\", author)) |&gt;\n  aggregate(revision ~ author2, FUN = sum)\n\ndat2 &lt;- within(dat1, {\n  value &lt;- 100 * revision / sum(revision)\n  csum &lt;- rev(cumsum(rev(value)))\n  pos &lt;- value / 1.5 + c(csum[-1], NA)\n  pos &lt;- ifelse(is.na(pos), value / 2, pos)\n  label &lt;- paste(author2, paste0(round(value, 2), \"%\"), sep = \"\\n\")\n})\n\nggplot(data = dat2, aes(x = 1, fill = author2, y = value)) +\n  geom_col(show.legend = FALSE, color = \"white\") +\n  coord_polar(theta = \"y\") +\n  geom_label_repel(aes(y = pos, label = label), \n    size = 4.5, nudge_x = 0.75, show.legend = FALSE\n  ) +\n  theme_void() +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n图 2.27: 维护者提交量占比\n\n\n\n\n\n但是数量很多的情况下，也是无能为力的，当然，是否需要显示那么多，是否可以合并占比小的部分，也是值得考虑的问题。\n\n\n\n\n表 2.4: SVN 日志中的贡献者（部分）\n\n\n\n\n\n\nSVN 花名\n真实名字\n主要贡献\n\n\n\n\nrgentlem\nRobert Gentleman\nR 语言创始人\n\n\nihaka\nRoss Ihaka\nR 语言创始人\n\n\nripley\nBrian Ripley\nR Core Team 中的核心\n\n\nmurrell\nPaul Murrell\ngrid 包及栅格绘图系统\n\n\nmaechler\nMartin Maechler\ncluster / Matrix 包维护者\n\n\nhornik\nKurt Hornik\nR FAQ 和 CRAN 维护者\n\n\njmc\nJohn Chambers\nS 语言的创始人之一\n\n\nbates\nDouglas Bates\nnlme / lme4 包核心开发者\n\n\npd\nPeter Dalgaard\n《统计导论与 R 语言》作者\n\n\nligges\nUwe Ligges\n让 BUGS 与 R 同在\n\n\nplummer\nMartyn Plummer\n让 JAGS 与 R 携手\n\n\nluke\nLuke Tierney\ncompiler 包核心开发者\n\n\niacus\nStefano M. Iacus\n让 CRAN 拥抱 Fedora 系统\n\n\nkalibera\nTomas Kalibera\n编码问题终结者\n\n\ndeepayan\nDeepayan Sarkar\nlattice 包维护者\n\n\nmurdoch\nDuncan Murdoch\nR 软件的 Windows 版本维护者\n\n\nduncan\nDuncan Temple Lang\nXML / RCurl 包开发者\n\n\nurbaneks\nSimon Urbanek\nrJava / Rserve 包维护者\n\n\n\n\n\n\n\n\n\n\n2.3.2 环形饼图\n中间空了一块\n\naggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt; \n  transform(author2 = ifelse(revision &lt; 2000, \"Others\", author)) |&gt; \n  aggregate(revision ~ author2, FUN = sum) |&gt; \n  transform(label = paste0(round(revision / sum(revision), digits = 4) * 100, \"%\")) |&gt; \n  ggplot(aes(x = 1, fill = author2, y = revision)) +\n  geom_col(position = \"fill\", show.legend = FALSE, color = \"white\") +\n  scale_y_continuous(labels = scales::label_percent()) +\n  coord_polar(theta = \"y\") +\n  geom_text(aes(x = 1.2, label = author2),\n    position = position_fill(vjust = 0.5), color = \"black\"\n  ) +\n  geom_text(aes(x = 1.7, label = label),\n    position = position_fill(vjust = 0.5), color = \"black\"\n  ) +\n  theme_void() +\n  labs(x = NULL, y = NULL) +\n  xlim(c(0.2, 1.7))\n\n\n\n\n\n\n\n图 2.28: 维护者提交量占比\n\n\n\n\n\n\n\n2.3.3 扇形饼图\n扇形饼图又叫风玫瑰图或南丁格尔图\n\naggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt; \n  transform(author2 = ifelse(revision &lt; 2000, \"Others\", author)) |&gt; \n  aggregate(revision ~ author2, FUN = sum) |&gt; \n  ggplot(aes(x = reorder(author2, revision), y = revision)) +\n  geom_col(aes(fill = author2), show.legend = FALSE) +\n  coord_polar() +\n  theme_minimal() +\n  theme(axis.text.y = element_blank()) +\n  labs(x = NULL, y = NULL)\n\n\n\n\n\n\n\n图 2.29: 维护者提交量分布\n\n\n\n\n\n\n\n2.3.4 帕累托图\n\n除了饼图，还常用堆积柱形图描述各个部分的数量，柱形图的优势在于简洁，准确，兼顾对比和趋势。下 图 2.30 描述各年开发者们的贡献量及其变化趋势，饼图无法表达数量的变化趋势。\n\naggregate(data = svn_trunk_log, revision ~ year + author, FUN = length) |&gt; \n  ggplot(aes(x = year, y = revision, fill = author)) +\n  geom_col() +\n  theme_classic() +\n  coord_cartesian(expand = FALSE) +\n  theme(legend.position = \"bottom\") +\n  labs(x = \"年份\", y = \"提交量\", fill = \"开发者\")\n\n\n\n\n\n\n\n图 2.30: 代码提交量的比例趋势\n\n\n\n\n\n百分比堆积柱形图在数量堆积柱形图的基础上，将纵坐标的数量转化为百分比，下 图 2.31 展示各年开发者代码提交比例的变化趋势。\n\naggregate(data = svn_trunk_log, revision ~ year + author, FUN = length) |&gt; \n  ggplot(aes(x = year, y = revision, fill = author)) +\n  geom_col(position = \"fill\") +\n  scale_y_continuous(labels = scales::label_percent()) +\n  theme_classic() +\n  coord_cartesian(expand = FALSE) +\n  theme(legend.position = \"bottom\") +\n  labs(x = \"年份\", y = \"提交量\", fill = \"开发者\")\n\n\n\n\n\n\n\n图 2.31: 代码提交量的比例趋势\n\n\n\n\n\n帕累托图描述各个部分的占比，特别是突出关键要素的占比。收入常服从帕累托分布，这是一个幂率分布，比如 80% 的财富集中在 20% 的人的手中。下 图 2.32 展示过去 25 年各位开发者的代码累计提交量，提交量小于 1000 的已经合并为一类。不难看出，Ripley 的提交量远高于其他开发者。\n\ndat &lt;- aggregate(data = svn_trunk_log, revision ~ author, FUN = length) |&gt;\n  transform(author = ifelse(revision &lt; 1000, \"Others\", author)) |&gt;\n  aggregate(revision ~ author, FUN = sum)\ndat &lt;- dat[order(-dat$revision), ]\n\nggplot(data = dat, aes(x = reorder(author, revision, decreasing = T), y = revision)) +\n  geom_col(width = 0.75) +\n  geom_line(aes(y = cumsum(revision), group = 1)) +\n  geom_point(aes(y = cumsum(revision))) +\n  theme_classic() + \n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +\n  labs(x = \"维护者\", y = \"累计提交量\")\n\n\n\n\n\n\n\n图 2.32: 代码提交量的比例分布\n\n\n\n\n\n\n\n2.3.5 马赛克图\n马赛克图常用于展示多个分类数据，如 图 2.33 所示，展示加州伯克利分校院系录取情况。\n\nlibrary(ggmosaic)\nggplot(data = as.data.frame(UCBAdmissions)) +\n  geom_mosaic(aes(x = product(Dept, Gender), weight = Freq, fill = Admit)) +\n  theme_minimal()\n\n\n\n\n\n\n\n图 2.33: 加州伯克利分校院系录取情况\n\n\n\n\n\n\n\n\n\n\n\n提示\n\n\n\nBase R 提供函数 plot() 和 mosaicplot() 对 table 表格类型的数据可视化，提供一套公式绘图语法，可以绘制类似的马赛克图。\n\nmosaicplot(~ Gender + Dept + Admit,\n  data = UCBAdmissions, color = TRUE,\n  main = \"\", xlab = \"性别\", ylab = \"院系\"\n)\n\n对于多维列联表数据，Base R 提供函数 loglin() 拟合对数线性模型，以获取更加定量的结果。更进一步，MASS 包在函数 loglin() 的基础上，打包了另一个函数 loglm() ，它提供与函数 lm() 和 glm() 相一致的公式语法，使用起来更加方便。当然，函数 glm() 本身也是可以拟合对数线性模型的，毕竟它也是一种特殊的广义线性模型。\n\n\n\n\n2.3.6 矩阵树图\n矩阵树图展示有层次的占比，比如 G20 国家的 GDP 按半球、地域分组。treemapify 包专门绘制矩阵树图，下 图 2.34 展示南北半球，各地域内各个国家 GDP 的占比。\n\n\n\n\n表 2.5: G20 国家经济水平：GDP 总量、人类发展指数等\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n区域\n国家\nGDP\n人类发展指数\n经济水平\n所属半球\n\n\n\n\nAfrica\nSouth Africa\n384315\n0.629\nDeveloping\nSouthern\n\n\nNorth America\nUnited States\n15684750\n0.937\nAdvanced\nNorthern\n\n\nNorth America\nCanada\n1819081\n0.911\nAdvanced\nNorthern\n\n\nNorth America\nMexico\n1177116\n0.775\nDeveloping\nNorthern\n\n\nSouth America\nBrazil\n2395968\n0.730\nDeveloping\nSouthern\n\n\nSouth America\nArgentina\n474954\n0.811\nDeveloping\nSouthern\n\n\n\n\n\n\n\n\n每个瓦片的大小代表国家的 GDP 在所属半球里的比重。\n\nggplot(G20, aes(area = gdp_mil_usd, fill = region, label = country, subgroup = region)) +\n  geom_treemap() +\n  geom_treemap_text(grow = T, reflow = T, colour = \"black\") +\n  facet_wrap(~hemisphere) +\n  scale_fill_brewer(palette = \"Set1\") +\n  theme(legend.position = \"bottom\") +\n  labs(title = \"G20 主要经济体\", fill = \"区域\")\n\n\n\n\n\n\n\n图 2.34: G20 主要经济体的 GDP 占比\n\n\n\n\n\n\n\n2.3.7 量表图\n展示调查研究中的用户态度。量表在市场调查，问卷调查，App 用户体验反馈等方面应用十分广泛，已经成为调查研究中的金标准。量表由心理学家 Rensis Likert 于 1932 年提出 (Likert 1932)，Likert Scale 就是以他的名字命名的。\n量表在互联网产品中应用非常广泛，比如美团App里消息页面中的反馈框，用以收集用户使用产品的体验情况，如 表 2.6 所示，从极其困难到极其方便，将用户反馈分成7个等级，目的是收集用户的反馈，以期改善产品的体验。\n\n\n\n表 2.6: 您觉得在本页面，找想看的消息方便吗？\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n极其困难\n非常困难\n比较困难\n一般\n比较方便\n非常方便\n极其方便\n\n\n\n\n\n\n量表中的问题、观点的描述极其简单明了，对回答、表明态度的任何人都不会造成歧义，以确保不受文化差异、学历差异等的影响，受调查的人只需在待选的几个选项中圈选即可。候选项一般为 5-7 个，下面是一组典型的选项：\n\nStrongly disagree （强烈反对），\nDisagree（反对），\nNeither agree nor disagree（中立），\nAgree（同意），\nStrongly agree（强烈同意）。\n\nJason M. Bryer 开发了一个 R 包 likert，特别适合调查研究数据可视化，将研究对象的态度以直观有效的方式展示出来，内置多个数据集，其中 表 2.7 是一个数学焦虑量表调查的结果，调查数据来自统计课上的 20 个学生。\n调查对象是 78 个来自不同学科的本科生，样本含有 36 个男性和 42 个女性，64% 的样本的年龄在 18 至 24 岁，36% 的样本年龄 25 岁及以上。更多数据背景信息 (Bai 等 2009)。\n\n\n\n表 2.7: 你对数学感到焦虑吗？\n\n\n\n\n\n\n\n\n\n\n\n\n\n观点\n强烈反对\n反对\n中立\n同意\n强烈同意\n\n\n\n\nI find math interesting.\n10\n15\n10\n35\n30\n\n\nI get uptight during math tests.\n10\n20\n20\n25\n25\n\n\nI think that I will use math in the future.\n0\n0\n20\n25\n55\n\n\nMind goes blank and I am unable to think clearly when doing my math test.\n30\n30\n15\n10\n15\n\n\nMath relates to my life.\n5\n20\n10\n40\n25\n\n\nI worry about my ability to solve math problems.\n20\n20\n20\n30\n10\n\n\nI get a sinking feeling when I try to do math problems.\n35\n10\n15\n35\n5\n\n\nI find math challenging.\n5\n10\n15\n45\n25\n\n\nMathematics makes me feel nervous.\n20\n25\n15\n25\n15\n\n\nI would like to take more math classes.\n20\n25\n30\n20\n5\n\n\nMathematics makes me feel uneasy.\n25\n15\n20\n25\n15\n\n\nMath is one of my favorite subjects.\n35\n15\n25\n20\n5\n\n\nI enjoy learning with mathematics.\n15\n25\n30\n20\n10\n\n\nMathematics makes me feel confused.\n15\n20\n15\n35\n15\n\n\n\n\n\n\n相比于 ggplot2 绘制的普通条形图， 图 2.35 有一些独特之处：对立型的渐变色表示两个不同方向的态度，左右两侧以中立态度为中间位置，非常形象，并且按照其中一个方向的态度数据排序，显得比较整齐有序，便于理解。\n\n# 数据来自 likert 包\nMathAnxiety &lt;- readRDS(file = \"data/MathAnxiety.rds\")\n# 宽转长格式\nMathAnxiety_df &lt;- reshape(data = MathAnxiety, \n  varying = c(\"Strongly Disagree\", \"Disagree\", \"Neutral\", \"Agree\", \"Strongly Agree\"),\n  times = c(\"Strongly Disagree\", \"Disagree\", \"Neutral\", \"Agree\", \"Strongly Agree\"),\n  timevar = \"Attitude\", v.names = \"Numbers\",  idvar = \"Item\", \n  new.row.names = 1:(5 * 14), direction = \"long\"\n )\n\nMathAnxiety_df$Attitude &lt;- factor(MathAnxiety_df$Attitude, levels = c(\n  \"Strongly Agree\", \"Agree\", \"Neutral\", \"Disagree\", \"Strongly Disagree\"\n), labels =  c(\n  \"强烈同意\", \"同意\", \"中立\", \"反对\", \"强烈反对\"\n), ordered = TRUE)\n\nggplot(data = MathAnxiety_df, aes(x = Numbers, y = Item)) +\n  geom_col(aes(fill = Attitude), position = \"fill\") +\n  scale_x_continuous(labels = scales::label_percent()) +\n  scale_y_discrete(labels = scales::label_wrap(25)) +\n  scale_fill_brewer(palette = \"BrBG\", direction = -1) +\n  theme_classic() +\n  guides(fill = guide_legend(reverse = TRUE)) +\n  coord_cartesian(expand = FALSE) +\n  labs(x = \"占比\", y = \"问题\", fill = \"态度\")\n\n\n\n\n\n\n\n图 2.35: 你喜欢数学吗\n\n\n\n\n\nlikert 包的函数 likert() 适合对聚合的调查数据绘图。\n\nlibrary(likert)\nlmath &lt;- likert(summary = MathAnxiety)\nplot(lmath)\n\n而 ggstats 包的函数 gglikert() 适合对明细的调查数据绘图。下面模拟一次调查收集到的数据，共计 150 人回答 6 个问题，每个问题都有 5 个候选项构成。\n\nlibrary(ggstats)\nlikert_levels &lt;- c(\"强烈反对\", \"反对\", \"中立\", \"同意\", \"强烈同意\")\nset.seed(2023)\nlibrary(data.table)\ndf &lt;- data.table(\n  q1 = sample(likert_levels, 150, replace = TRUE),\n  q2 = sample(likert_levels, 150, replace = TRUE, prob = 5:1),\n  q3 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),\n  q4 = sample(likert_levels, 150, replace = TRUE, prob = 1:5),\n  q5 = sample(c(likert_levels, NA), 150, replace = TRUE),\n  q6 = sample(likert_levels, 150, replace = TRUE, prob = c(1, 0, 1, 1, 0))\n)\nfkt &lt;- paste0(\"q\", 1:6)\ndf[, (fkt) := lapply(.SD, factor, levels = likert_levels), .SDcols = fkt]\n\n一个调查问卷共有 6 个题目，150 个人对 6 个问题的回答构成一个数据框 df 。\n\ngglikert(df)\n\n\n\n\n\n\n\n图 2.36: Likert 图",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>基础图形</span>"
    ]
  },
  {
    "objectID": "visualization-intermediate.html#sec-visualization-intermediate-exercise",
    "href": "visualization-intermediate.html#sec-visualization-intermediate-exercise",
    "title": "2  基础图形",
    "section": "2.4 习题",
    "text": "2.4 习题\n\n根据 Github 代码提交量数据制作日历图。\n\ngithub_ctb &lt;- jsonlite::read_json(path = \"data/contributions.json\")\ngithub_df &lt;- data.frame(\n  date = unlist(lapply(github_ctb$contributions, \"[[\", \"date\")),\n  count = unlist(lapply(github_ctb$contributions, \"[[\", \"count\")),\n  color = unlist(lapply(github_ctb$contributions, \"[[\", \"color\")),\n  intensity = unlist(lapply(github_ctb$contributions, \"[[\", \"intensity\"))\n)\nweek.abb &lt;- c(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\")\ngithub_df &lt;- within(github_df, {\n  date &lt;- as.Date(date)\n  year &lt;- format(date, format = \"%Y\", tz = \"UTC\")\n  month &lt;- format(date, format = \"%m\", tz = \"UTC\")\n  week &lt;- format(date, format = \"%U\", tz = \"UTC\")\n  wday &lt;- format(date, format = \"%a\", tz = \"UTC\")\n  nday &lt;- format(date, format = \"%j\", tz = \"UTC\")\n  week &lt;- as.integer(week)\n  wday &lt;- factor(wday, labels = week.abb)\n})\nggplot(\n  data = subset(github_df, subset = year %in% 2020:2022),\n  aes(x = week, y = wday, fill = count)\n) +\n  geom_tile(color = \"white\", linewidth = 0.5) +\n  scale_fill_distiller(palette = \"Greens\", direction = 1) +\n  scale_x_continuous(\n    expand = c(0, 0), breaks = seq(1, 52, length = 12), labels = month.abb\n  ) +\n  facet_wrap(~year, ncol = 1) +\n  theme_minimal() +\n  labs(x = \"月份\", y = \"星期\", fill = \"提交量\")\n\n\n\n\n\n\n\n图 2.37: Github 打卡日历图\n\n\n\n\n\n\n\n\n\n\nBai, H., L. Wang, W. Pan, 和 M. Frey. 2009. 《Measuring mathematics anxiety: Psychometric analysis of a bidimensional affective scale》. Journal of Instructional Psychology 36 (3): 185–93.\n\n\nKothari, Aditya. 2022. ggTimeSeries: Time Series Visualisations Using the Grammar of Graphics. https://CRAN.R-project.org/package=ggTimeSeries.\n\n\nLikert, Rensis. 1932. 《A Technique for the Measurement of Attitudes》. Archives of Psychology 142 (1): 1–55.\n\n\nWickham, Hadley. 2016. ggplot2: Elegant Graphics for Data Analysis. 2nd 本. Springer-Verlag New York. https://ggplot2.tidyverse.org.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>基础图形</span>"
    ]
  },
  {
    "objectID": "visualization-advanced.html",
    "href": "visualization-advanced.html",
    "title": "3  统计图形",
    "section": "",
    "text": "3.1 描述分布\n数据来自中国国家统计局发布的2021年统计年鉴，各省、直辖市和自治区分区域的性别比数据（部分）情况见 表 3.1 。\n表 3.1: 各省、直辖市和自治区分区域的性别比数据（部分）\n\n\n\n\n\n\n地区\n人口数/男\n人口数/女\n性别比（女=100）\n区域\n\n\n\n\n北京\n8937161\n8814520\n101.39\n城市\n\n\n天津\n5610161\n5322931\n105.40\n城市\n\n\n河北\n11010407\n11119188\n99.02\n城市\n\n\n山西\n6588788\n6608849\n99.70\n城市\n\n\n内蒙古\n4714495\n4731924\n99.63\n城市\n\n\n辽宁\n12626419\n12946058\n97.53\n城市",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>统计图形</span>"
    ]
  },
  {
    "objectID": "visualization-advanced.html#sec-visualize-data-distribution",
    "href": "visualization-advanced.html#sec-visualize-data-distribution",
    "title": "3  统计图形",
    "section": "",
    "text": "3.1.1 箱线图\nlibrary(ggplot2)\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_boxplot() +\n  theme_classic()\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_boxplot(outlier.colour = \"red\") +\n  theme_classic()\nlibrary(lvplot)\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_lv() +\n  theme_classic()\nboxplot(`性别比（女=100）` ~ `区域` , data = province_sex_ratio)\n\n\n\n\n\n\n\n\n\n\n\n(a) ggplot2 包\n\n\n\n\n\n\n\n\n\n\n\n(b) ggplot2 包（高亮离群值）\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) lvplot 包\n\n\n\n\n\n\n\n\n\n\n\n(d) Base R 包\n\n\n\n\n\n\n\n图 3.1: 箱线图的几种绘制形式\n\n\n\n箱线图的历史有 50 多年了，它的变体也有很多，除了 ggplot2 包，lvplot 包也可以绘制箱线图的变体 (McGill 和 Larsen 1978)。更多详情见 Hadley Wickham 和 Lisa Stryjewski 的文章 40 years of boxplots。\n\n\n3.1.2 提琴图\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_violin(fill = \"lightgray\") +\n  theme_classic()\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_violin(fill = \"lightgray\", draw_quantiles = c(0.25, 0.5, 0.75)) +\n  theme_classic()\n#&gt; Warning: The `draw_quantiles` argument of `geom_violin()` is deprecated as of\n#&gt; ggplot2 4.0.0.\n#&gt; ℹ Please use the `quantiles.linetype` argument instead.\nvioplot::vioplot(`性别比（女=100）` ~ `区域`,\n  data = province_sex_ratio, col = \"lightgray\")\nbeanplot::beanplot(`性别比（女=100）` ~ `区域`,\n  data = province_sex_ratio, col = \"lightgray\", log = \"\",\n  xlab = \"区域\", ylab = \"性别比（女=100）\")\n\n\n\n\n\n\n\n\n\n\n\n(a) 函数 geom_violin()\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 geom_violin() 标记分位点\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) vioplot 包\n\n\n\n\n\n\n\n\n\n\n\n(d) beanplot 包\n\n\n\n\n\n\n\n图 3.2: 提琴图\n\n\n\nbeanplot 包的名字是根据图形的外观取的，bean 即是豌豆，rug 用须线表示数据。\n\n\n3.1.3 直方图\nggplot2 包绘制直方图的函数是 geom_histogram() ，而与之相关的函数 geom_freqpoly() 是绘制折线图，将直方图中每个柱子的顶点连接起来。\nggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, fill = `区域`)) +\n  geom_histogram(binwidth = 5, color = \"white\", position = \"stack\") +\n  scale_fill_grey() +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.9, 0.8)) +\n  labs(y = \"频数\")\nggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, color = `区域`)) +\n  geom_freqpoly(binwidth = 5, stat = \"bin\", position = \"stack\") +\n  scale_color_grey() +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.9, 0.8))\n\n\n\n\n\n\n\n\n\n\n\n(a) 函数 geom_histogram()\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 geom_freqpoly()\n\n\n\n\n\n\n\n图 3.3: 直方图\n\n\n\n\n\n3.1.4 密度图\nggplot2 包绘制密度图的函数是 geom_density()， 图 3.4 展示分组密度曲线图\n\nggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`)) +\n  geom_density(aes(fill = `区域`), alpha = 0.75) +\n  scale_fill_grey() +\n  theme_classic()\n\n\n\n\n\n\n\n图 3.4: 密度图\n\n\n\n\n\n\n3.1.4.1 堆积（条件）密度图\n\n\n\n\n\n\n注意\n\n\n\nStacked density plots: if you want to create a stacked density plot, you probably want to ‘count’ (density * n) variable instead of the default density\n\n\n堆积密度图正确的绘制方式是保护边际密度。\nggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = after_stat(density))) +\n  geom_density(aes(fill = `区域`), position = \"stack\", alpha = 0.5) +\n  scale_fill_grey() +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.9, 0.8))\nggplot(data = province_sex_ratio, aes(x = `性别比（女=100）`, y = after_stat(density * n))) +\n  geom_density(aes(fill = `区域`), position = \"stack\", alpha = 0.5) +\n  scale_fill_grey() +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.9, 0.8))\n\n\n\n\n\n\n\n\n\n\n\n(a) 堆积密度图 after_stat(density)\n\n\n\n\n\n\n\n\n\n\n\n(b) 堆积密度图 after_stat(density * n)\n\n\n\n\n\n\n\n图 3.5: 累积分布密度图\n\n\n\n什么原因导致 图 3.5 中两个子图看起来没什么差别呢？而换一组数据，就可以看出明显的差别。\nggplot(diamonds, aes(x = carat, y = after_stat(density), fill = cut)) +\n  geom_density(position = \"stack\") +\n  scale_fill_grey() +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.8, 0.7)) +\n  labs(x = \"克拉\", y = \"频数\", fill = \"切工\")\nggplot(diamonds, aes(x = carat, y = after_stat(density * n), fill = cut)) +\n  geom_density(position = \"stack\") +\n  scale_fill_grey() +\n  scale_y_continuous(\n    breaks = c(25000, 50000, 75000), \n    labels = c(\"25K\", \"50K\", \"75K\")) +\n  theme_classic() +\n  theme(legend.position = \"inside\", legend.position.inside = c(0.8, 0.7)) +\n  labs(x = \"克拉\", y = \"频数\", fill = \"切工\")\n\n\n\n\n\n\n\n\n\n\n\n(a) 函数 after_stat(density)\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 after_stat(density * n)\n\n\n\n\n\n\n\n图 3.6: 堆积密度图\n\n\n\n\n\n3.1.4.2 联合密度图\n\nstate_x77 &lt;- data.frame(state.x77, state_name = rownames(state.x77),\n  state_region = state.region, check.names = FALSE)\np1 &lt;- ggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +\n  geom_point() +\n  geom_density_2d(\n    aes(color = after_stat(level), alpha = after_stat(level)), show.legend = F\n  ) +\n  scale_color_distiller(palette = \"Greys\") +\n  labs(\n    x = \"人均收入（美元）\", y = \"预期寿命（年）\",\n    title = \"1977 年各州预期寿命与人均收入的关系\",\n    caption = \"数据源：美国人口调查局\"\n  ) +\n  theme_classic()\np1\n\n\n\n\n\n\n\n图 3.7: 二维联合密度图\n\n\n\n\n\n\n\n3.1.4.3 边际密度图\nggExtra 包(Attali 和 Baker 2022) 添加边际密度曲线和边际直方图。\n\nlibrary(ggExtra)\nggMarginal(p1, type = \"density\")\nggMarginal(p1, type = \"histogram\")\n\n\n\n\n\n\n\n图 3.8: 描述边际分布\n\n\n\n\n\n\n\n3.1.4.4 填充密度图\nggplot2 包提供二维密度图层 geom_density_2d_filled() 绘制热力图， ggdist (Kay 2022) 进行了一些扩展。\n\nggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +\n  geom_density_2d_filled(contour_var = \"count\") +\n  theme_classic() +\n  labs(\n    x = \"人均收入（美元）\", y = \"预期寿命（年）\",\n    title = \"1977 年各州预期寿命与人均收入的关系\",\n    caption = \"数据源：美国人口调查局\"\n  )\n\n\n\n\n\n\n\n图 3.9: ggplot2 包绘制二维填充密度图\n\n\n\n\n\n相比于 ggplot2 内置的二维核密度估计，ggdensity (Otto 和 Kahle 2023) 有一些优势，根据数据密度将目标区域划分，更加突出层次和边界。gghdr 包与 ggdensity 类似，展示 highest density regions (HDR)\n\nlibrary(ggdensity)\nggplot(data = state_x77, aes(x = Income, y = `Life Exp`)) +\n  geom_hdr() +\n  geom_point() +\n  theme_classic() +\n  labs(\n    x = \"人均收入（美元）\", y = \"预期寿命（年）\",\n    title = \"1977 年各州预期寿命与人均收入的关系\",\n    caption = \"数据源：美国人口调查局\"\n  )\n\n\n\n\n\n\n\n图 3.10: ggdensity 包绘制二维填充密度图\n\n\n\n\n\n\n\n\n3.1.5 岭线图\n叠嶂图，还有些其它名字，如峰峦图、岭线图等，详情参考统计之都主站《叠嶂图的前世今生》，主要用来描述数据的分布情况，在展示分布的对比上效果非常好。\n图 3.11 设置窗宽为 1.5 个百分点\n\n\n\n\n\n\n\n\n\n\n\n(a) 岭线图\n\n\n\n\n\n\n\n\n\n\n\n(b) 岭线图和抖动图组合\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 岭线图和轴须图组合\n\n\n\n\n\n\n\n图 3.11: 描述数据分布\n\n\n\n\n\n\n\n\n\n提示\n\n\n\n除了中国国家统计年鉴，各省、自治区、直辖市及各级统计局每年都会发布一些统计年鉴、公告等数据，读者可以在此基础上继续收集更多数据，来分析诸多有意思的问题：\n\n城市、镇和乡村男女性别比呈现差异化分布的成因。\n城市、镇和乡村男女年龄构成。\n将上述问题从省级下钻到市、县级来分析。\n\n\n\n\n\n3.1.6 抖动图\n下面先用函数 geom_point() 绘制散点图展示原始数据，通过点的疏密程度暗示数据的分布。Base R 函数 stripchart() 可以实现类似的效果。当数据量比较大时，点相互覆盖比较严重，此时，抖动图比较适合用来展示原始数据。函数 geom_beeswarm() 提供了另一种散点的组织方式，按一定的规则，而不是近似随机的方式组织。\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_point() +\n  theme_classic()\nstripchart(\n  `性别比（女=100）` ~ `区域`, vertical = TRUE, pch = 1,\n  data = province_sex_ratio, xlab = \"区域\")\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_jitter(width = 0.25) +\n  theme_classic()\nlibrary(ggbeeswarm)\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_beeswarm() +\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\n(a) 函数 geom_point()\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 stripchart()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 函数 geom_jitter()\n\n\n\n\n\n\n\n\n\n\n\n(d) 函数 geom_beeswarm()\n\n\n\n\n\n\n\n图 3.12: 散点图\n\n\n\nSidiropoulos 等 (2018) 提出一种新的方式描述数据的分布，集合抖动图和小提琴图的功能，在给定的分布界限内抖动。数据点受 violin 的曲线限制，蜂群图也是某种形式的抖动图，添加 violin 作为参考边界，与 sina 图是非常类似的。\nlibrary(ggforce)\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_sina() +\n  theme_classic()\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_violin() +\n  geom_sina() +\n  theme_classic()\nlibrary(ggbeeswarm)\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_quasirandom() +\n  theme_classic()\nggplot(data = province_sex_ratio, aes(x = `区域`, y = `性别比（女=100）`)) +\n  geom_violin() +\n  geom_quasirandom() +\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\n(a) ggforce 包的函数 geom_sina()\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 geom_sina() 叠加函数 geom_violin()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) ggbeeswarm 包的函数 geom_quasirandom()\n\n\n\n\n\n\n\n\n\n\n\n(d) 函数 geom_quasirandom() 叠加函数 geom_violin()\n\n\n\n\n\n\n\n图 3.13: 加强版的抖动图",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>统计图形</span>"
    ]
  },
  {
    "objectID": "visualization-advanced.html#sec-visualize-data-relation",
    "href": "visualization-advanced.html#sec-visualize-data-relation",
    "title": "3  统计图形",
    "section": "3.2 描述关系",
    "text": "3.2 描述关系\n\n3.2.1 散点图\n散点图用以描述变量之间的关系，展示原始的数据，点的形态、大小、颜色等都可以随更多变量变化。\n中国国家统计局 2021 年发布的统计年鉴，2020 年 31 个省、直辖市、自治区的抚养比、文盲率、人口数的关系。\n\n\n\n\n表 3.2: 2020 年各省、直辖市、自治区，总抚养比和文盲率相关数据（部分）\n\n\n\n\n\n\n地区\n人口数\n15-64岁\n抚养比\n15岁及以上人口\n文盲人口\n文盲率\n\n\n\n\n广东\n126012510\n91449628\n37.79\n102262628\n1826344\n1.79\n\n\n山东\n101527453\n67100737\n51.31\n62464815\n3308280\n4.01\n\n\n河南\n99365519\n62974661\n57.79\n76376565\n2228594\n2.92\n\n\n江苏\n84748016\n58129537\n45.79\n71856068\n2211291\n3.08\n\n\n四川\n83674866\n56036154\n49.32\n70203754\n3330733\n4.74\n\n\n河北\n74610235\n49133330\n51.85\n59521267\n1128423\n1.90\n\n\n\n\n\n\n\n\n其中，文盲人口是指15岁及以上不识字及识字很少人口，文盲率 = 文盲人口 / 15岁及以上人口，抚养比 = (0-14岁 + 65岁及以上) / 15-64岁人口数。\n\nlibrary(ggplot2)\nggplot(data = china_raise_illiteracy) +\n  geom_point(aes(x = `总抚养比`, y = `文盲人口占15岁及以上人口的比重`)) +\n  theme_classic() +\n  labs(x = \"抚养比（%）\", y = \"文盲率（%）\")\n\n\n\n\n\n\n\n图 3.14: 文盲率与抚养比的关系\n\n\n\n\n\n\n\n3.2.2 气泡图\n气泡图在散点图的基础上，添加了散点大小的视觉维度，可以在图上多展示一列数据，下 图 3.15 新增了人口数变量。此外，在气泡旁边添加地区名称，将气泡填充的颜色也映射给了人口数变量。\n\nlibrary(ggrepel)\nlibrary(scales)\nggplot(\n  data = china_raise_illiteracy,\n  aes(x = `总抚养比`, y = `文盲人口占15岁及以上人口的比重`)\n) +\n  geom_point(aes(size = `人口数`, color = `人口数`),\n    alpha = 0.85, pch = 16,\n    show.legend = c(color = FALSE, size = TRUE)\n  ) +\n  scale_size(labels = label_number(scale_cut = cut_short_scale())) +\n  scale_color_viridis_c(option = \"C\") +\n  geom_text_repel(\n    aes(label = `地区`), size = 3, max.overlaps = 50,\n    segment.colour = \"gray\", seed = 2022, show.legend = FALSE\n  ) +\n  coord_cartesian(xlim = c(30, 60), ylim = c(0, 10.5), expand = FALSE) +\n  theme_classic() +\n  labs(x = \"抚养比（%）\", y = \"文盲率（%）\")\n\n\n\n\n\n\n\n图 3.15: 文盲率和抚养比数据\n\n\n\n\n\n\n\n3.2.3 凹凸图\n凹凸图描述位置排序关系随时间的变化，比如前年、去年和今年各省的 GDP 排序变化，春节各旅游景点的人流量变化。ggbump 包专门用来绘制凹凸图，如 图 3.16 所示，展示\n\nlibrary(ggbump)\n# 位置排序变化\ndf &lt;- data.frame(\n  country = c(\n    \"印度\", \"印度\", \"印度\", \"瑞典\",\n    \"瑞典\", \"瑞典\", \"德国\", \"德国\",\n    \"德国\", \"芬兰\", \"芬兰\", \"芬兰\"\n  ),\n  year = c(\n    2018, 2019, 2020, 2018, 2019, 2020,\n    2018, 2019, 2020, 2018, 2019, 2020\n  ),\n  value = c(\n    492, 246, 246, 369, 123, 492,\n    246, 369, 123, 123, 492, 369\n  )\n)\n\nlibrary(data.table)\ndf &lt;- as.data.table(df)\ndf[, rank := rank(value, ties.method = \"random\"), by = \"year\"]\n\nggplot(df, aes(year, rank, color = country)) +\n  geom_point(size = 7) +\n  geom_text(data = df[df$year == min(df$year), ],\n            aes(x = year - .1, label = country), size = 5, hjust = 1) +\n  geom_text(data = df[df$year == max(df$year), ],\n            aes(x = year + .1, label = country), size = 5, hjust = 0) +\n  geom_bump(linewidth = 2, smooth = 8) +\n  scale_x_continuous(limits = c(2017.6, 2020.4), breaks = seq(2018, 2020, 1)) +\n  theme_minimal(base_size = 14) +\n  theme(legend.position = \"none\", panel.grid.major = element_blank()) +\n  labs(x = NULL, y = \"排名\") +\n  scale_y_reverse() +\n  coord_fixed(ratio = 0.5)\n\n\n\n\n\n\n\n图 3.16: 凹凸图\n\n\n\n\n\n\n\n3.2.4 韦恩图\n韦恩图描述集合、群体的交叉关系，整体和部分的包含关系，ggVennDiagram 包展示 A、B、C 三个集合的交叉关系，如 图 3.17 所示\n\nx &lt;- list(A = 1:5, B = 2:7, C = 5:10)\nggVennDiagram::ggVennDiagram(x) +\n  scale_fill_gradient(low = \"#F4FAFE\", high = \"#4981BF\")\n\n\n\n\n\n\n\n图 3.17: A、B、C 三个集合的交叉关系\n\n\n\n\n\n\n\n3.2.5 网络图\ntidygraph 包基于 igraph 包操作图数据，计算网络图中节点重要性，ggraph包基于 ggplot2 包可视化网络关系。\n\nlibrary(ggraph)\ndata(\"highschool\")\nstr(highschool)\n#&gt; 'data.frame':    506 obs. of  3 variables:\n#&gt;  $ from: num  1 1 1 1 1 2 2 3 3 4 ...\n#&gt;  $ to  : num  14 15 21 54 55 21 22 9 15 5 ...\n#&gt;  $ year: num  1957 1957 1957 1957 1957 ...\n\nhighschool 是一个数据框类型的数据，记录了1957 年和 1958 年一些高中男生之间的关系，在数据集中，这些男生被编码成数字 1-71。\n\nhighschool[highschool$from == 1, ]\n#&gt;     from to year\n#&gt; 1      1 14 1957\n#&gt; 2      1 15 1957\n#&gt; 3      1 21 1957\n#&gt; 4      1 54 1957\n#&gt; 5      1 55 1957\n#&gt; 244    1 15 1958\n#&gt; 245    1 21 1958\n#&gt; 246    1 22 1958\n\n1 号男生在 1957 年与 14、15、21、54、55 男生关系密切，到了 1958 年，他与 15、21、22 关系比较密切。tidygraph 包在 igraph 的基础上，可以对图数据进行操作，下面先将数据框转化为图，然后计算中心度，作为高中生的受欢迎程度。\n\ngraph &lt;- tidygraph::as_tbl_graph(highschool, directed = TRUE) |&gt; \n  dplyr::mutate(Popularity = tidygraph::centrality_degree(mode = 'in'))\ngraph\n#&gt; # A tbl_graph: 70 nodes and 506 edges\n#&gt; #\n#&gt; # A directed multigraph with 1 component\n#&gt; #\n#&gt; # Node Data: 70 × 1 (active)\n#&gt;    Popularity\n#&gt;         &lt;dbl&gt;\n#&gt;  1          2\n#&gt;  2          0\n#&gt;  3          0\n#&gt;  4          4\n#&gt;  5          5\n#&gt;  6          2\n#&gt;  7          2\n#&gt;  8          3\n#&gt;  9          4\n#&gt; 10          4\n#&gt; # ℹ 60 more rows\n#&gt; #\n#&gt; # Edge Data: 506 × 3\n#&gt;    from    to  year\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1    13  1957\n#&gt; 2     1    14  1957\n#&gt; 3     1    20  1957\n#&gt; # ℹ 503 more rows\n\n\nggraph(graph, layout = \"kk\") +\n  geom_edge_fan(aes(alpha = after_stat(index)), show.legend = FALSE) +\n  geom_node_point(aes(size = Popularity)) +\n  facet_edges(~year) +\n  theme_graph(base_family = \"sans\", foreground = \"steelblue\", fg_text_colour = \"white\")\n\n\n\n\n\n\n\n图 3.18: 高中男生间关系的变化",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>统计图形</span>"
    ]
  },
  {
    "objectID": "visualization-advanced.html#sec-visualize-data-uncertainty",
    "href": "visualization-advanced.html#sec-visualize-data-uncertainty",
    "title": "3  统计图形",
    "section": "3.3 描述不确定性",
    "text": "3.3 描述不确定性\n统计是一门研究不确定性的学科，由不确定性引出许多的基本概念，比如用置信区间描述点估计的不确定性，用覆盖概率描述区间估计方法的优劣。下面以二项分布参数的点估计与区间估计为例，通过可视化图形介绍这一系列统计概念。就点估计来说，描述不确定性可以用标准差、置信区间。\nggdist 包可视化分布和不确定性 (Kay 2022)\n\nMichael Friendly 2021 年的课程 Psychology of Data Visualization\nClaus O. Wilke 2023 年的课程 SDS 375 Schedule Spring 2023\n\n\n3.3.1 置信区间\n\n\n\n表 3.3: 二项分布的分布列\n\n\n\n\n\n0\n1\n2\n\\(\\cdots\\)\nn\n\n\n\n\n\\(p_0\\)\n\\(p_1\\)\n\\(p_2\\)\n\\(\\cdots\\)\n\\(p_n\\)\n\n\n\n\n\n\n二项分布 \\(\\mathrm{Binomial}(n,p)\\) 的参数 \\(p\\) 的精确区间估计如下：\n\\[\n\\big(\\mathrm{Beta}(\\frac{\\alpha}{2}; x, n-x+1), \\mathrm{Beta}(1-\\frac{\\alpha}{2}; x+1, n-x)\\big)\n\\tag{3.1}\\]\n其中， \\(x\\) 表示成功次数，\\(n\\) 表示实验次数，\\(\\mathrm{Beta}(p;v,w)\\) 表示形状参数为 \\(v\\) 和 \\(w\\) 的 Beta 贝塔分布的 \\(p\\) 分位数，参数 \\(p\\) 的置信区间的上下限 \\(P_L,P_U\\) 满足\n\\[\n\\begin{aligned}\n\\frac{\\Gamma(n+1)}{\\Gamma(x)\\Gamma(n-x+1)}\\int_{0}^{P_L}t^{x-1}(1-t)^{n-x}\\mathrm{dt} &= \\frac{\\alpha}{2} \\\\\n\\frac{\\Gamma(n+1)}{\\Gamma(x+1)\\Gamma(n-x)}\\int_{0}^{P_U}t^{x}(1-t)^{n-x-1}\\mathrm{dt} &= 1-\\frac{\\alpha}{2}\n\\end{aligned}\n\\]\n\\(p_x\\) 表示二项分布 \\(\\mathrm{Binomial}(n,p)\\) 第 \\(x\\) 项的概率，\\(x\\) 的取值为 \\(0,1,\\cdots,n\\)\n\\[p_x = \\binom{n}{x}p^x(1-p)^{n-x}, \\quad x = 0,1,\\cdots,n\\]\n二项分布的累积分布函数和 \\(S_k\\) 表示前 \\(k\\) 项概率之和\n\\[S_k = \\sum_{x=0}^{k} p_x\\]\n\\(S_k\\) 服从形状参数为 \\(n-k,k+1\\) 的贝塔分布 \\(I_x(a,b)\\)，对应于 R 函数 pbeta(x,a,b)。 \\(S_k\\) 看作贝塔分布的随机变量 \\(X\\)\n\\[\n\\begin{aligned}\nB_x(a,b) &=\\int_{0}^{x}t^{a-1}(1-t)^{b-1}\\mathrm{dt} \\\\\nI_x(a,b) &= \\frac{B_x(a,b)}{B(a,b)}, \\quad B(a,b) = B_1(a,b)\n\\end{aligned}\n\\]\n考虑二项总体的参数 \\(p=0.7\\)，重复模拟 50 次，每次模拟获得的比例 \\(\\hat{p}\\) 及其置信区间，区间估计方法来自 (Clopper 和 Pearson 1934) ，函数 binom.test() 也是采用此方法，二者计算结果相同。如 图 3.19 所示，置信区间覆盖真值的情况用不同颜色表示，覆盖用灰色表示，没有覆盖用黑色表示。\n\nclopper_pearson &lt;- function(p = 0.1, n = 10, nsim = 100) {\n  set.seed(2022)\n  nd &lt;- rbinom(nsim, prob = p, size = n)\n  ll &lt;- qbeta(p = 0.05 / 2, shape1 = nd, shape2 = n - nd + 1)\n  ul &lt;- qbeta(p = 1 - 0.05 / 2, shape1 = nd + 1, shape2 = n - nd)\n  data.frame(nd = nd, ll = ll, ul = ul, cover = ul &gt; p & ll &lt; p)\n}\n# 二项分布的参数 p = 0.7\ndat &lt;- clopper_pearson(p = 0.7, n = 10, nsim = 50)\n# 二项分布的参数的置信区间覆盖真值的情况\nggplot(data = dat, aes(x = 1:50, y = nd / 10, colour = cover)) +\n  geom_hline(yintercept = 0.7, lty = 2, linewidth = 1.2, color = \"gray\") +\n  geom_pointrange(aes(ymin = ll, ymax = ul)) +\n  scale_color_grey(labels = c(`TRUE` = \"是\", `FALSE` = \"否\")) +\n  theme_classic() +\n  labs(x = \"n\", y = \"p\", color = \"覆盖\")\n\n\n\n\n\n\n\n图 3.19: Clopper-Pearson 置信区间\n\n\n\n\n\n图中，横坐标表示模拟次数 \\(n\\) ，纵坐标表示对应的成功概率 \\(p\\) ，线段端点表示置信区间上下限。\n\n\n3.3.2 假设检验\n假设检验的目的是做决策，决策是有风险的，是可能发生错误的，为了控制犯第一类错误的可能性，我们用 P 值描述检验统计假设的不确定性，用功效描述检验方法的优劣。对同一个统计假设，同一组数据，不同的检验方法有不同的 P 值，本质是检验方法的功效不同。\nggpval 在图上添加检验的 P 值结果，ggsignif (Constantin 和 Patil 2021) 在图上添加显著性注释。ggstatsplot (Patil 2021) 可视化统计检验、模型的结果，描述功效变化。ggpubr 制作出版级统计图形，两样本均值的比较。\n\nwith(\n  aggregate(\n    data = PlantGrowth, weight ~ group,\n    FUN = function(x) c(dist_mean = mean(x), dist_sd = sd(x))\n  ),\n  cbind.data.frame(weight, group)\n) |&gt;\n  ggplot(aes(x = group, y = dist_mean)) +\n  geom_col(\n    position = position_dodge(0.4), width = 0.4, fill = \"gray\"\n  ) +\n  geom_errorbar(aes(ymin = dist_mean - dist_sd, ymax = dist_mean + dist_sd),\n    position = position_dodge(0.4), width = 0.2) +\n  theme_classic() +\n  labs(x = \"组别\", y = \"植物干重\")\n\n\n\n\n\n\n\n图 3.20: 植物生长\n\n\n\n\n\n\n\n\n\n\n\n注记\n\n\n\nR 3.5.0 以后，函数 aggregate() 的参数 drop 默认值为 TRUE， 表示扔掉未用来分组的变量，聚合返回的是一个矩阵类型的数据对象。\n\n\n单因素方差分析 oneway.test() 检验各组的方差是否相等。\n\noneway.test(data = PlantGrowth, weight ~ group)\n#&gt; \n#&gt;  One-way analysis of means (not assuming equal variances)\n#&gt; \n#&gt; data:  weight and group\n#&gt; F = 5.181, num df = 2.000, denom df = 17.128, p-value =\n#&gt; 0.01739\n\n结果显示方差不全部相等，因此，采用函数 t.test(var.equal = FALSE) 来检验数据。图 3.21 展示假设检验的结果，分别标记了 ctrl 与 trt1、trt1 与 trt2 两组 t 检验的结果。\n\nlibrary(ggsignif)\nggplot(data = PlantGrowth, aes(x = group, y = weight)) +\n  geom_boxplot(width = 0.25) +\n  geom_jitter(width = 0.15) +\n  geom_signif(comparisons = list(c(\"ctrl\", \"trt1\"), c(\"trt1\", \"trt2\")), \n              map_signif_level = function(p) sprintf(\"p = %.2g\", p), \n              textsize = 6, test = \"t.test\") +\n  theme_classic() +\n  coord_cartesian(clip = \"off\")\n\n\n\n\n\n\n\n图 3.21: 展示假设检验的结果\n\n\n\n\n\n为了了解其中的原理，下面分别使用函数 t.test() 检验数据，结果给出的 P 值与上 图 3.21 完全一样。\n\nt.test(data = PlantGrowth, weight ~ group, subset = group %in% c(\"ctrl\", \"trt1\"))\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  weight by group\n#&gt; t = 1.1913, df = 16.524, p-value = 0.2504\n#&gt; alternative hypothesis: true difference in means between group ctrl and group trt1 is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -0.2875162  1.0295162\n#&gt; sample estimates:\n#&gt; mean in group ctrl mean in group trt1 \n#&gt;              5.032              4.661\nt.test(data = PlantGrowth, weight ~ group, subset = group %in% c(\"trt1\", \"trt2\"))\n#&gt; \n#&gt;  Welch Two Sample t-test\n#&gt; \n#&gt; data:  weight by group\n#&gt; t = -3.0101, df = 14.104, p-value = 0.009298\n#&gt; alternative hypothesis: true difference in means between group trt1 and group trt2 is not equal to 0\n#&gt; 95 percent confidence interval:\n#&gt;  -1.4809144 -0.2490856\n#&gt; sample estimates:\n#&gt; mean in group trt1 mean in group trt2 \n#&gt;              4.661              5.526\n\n\n\n3.3.3 模型预测\n描述模型预测的不确定性，预测的方差、预测区间。线性回归来说，回归线及置信带。代码提交量的趋势拟合\n\nsvn_trunk_log &lt;- readRDS(file = \"data/svn-trunk-log-2022.rds\")\nsvn_trunk_log$year &lt;- as.integer(format(svn_trunk_log$stamp, \"%Y\"))\ntrunk_year &lt;- aggregate(data = svn_trunk_log, revision ~ year, FUN = length)\nggplot(data = trunk_year[trunk_year$year != 1997,], aes(x = year, y = revision)) +\n  geom_point() +\n  geom_smooth(aes(color = \"LOESS\", fill = \"LOESS\"),\n    method = \"loess\", formula = \"y~x\",\n    method.args = list(\n      span = 0.75, degree = 2, family = \"symmetric\",\n      control = loess.control(surface = \"direct\", iterations = 4)\n    )) +\n  geom_smooth(aes(color = \"GAM\", fill = \"GAM\"),\n    formula = y ~ s(x, k = 12), method = \"gam\", se = TRUE) +\n  geom_smooth(aes(color = \"Cubic Spline\", fill = \"Cubic Spline\"),\n                method = \"lm\", formula = y ~ splines::bs(x, 3), se = T) +\n  scale_color_brewer(name = \"模型\", palette = \"Set1\") +\n  scale_fill_brewer(name = \"模型\", palette = \"Set1\") +\n  theme_classic() +\n  theme(panel.grid.major.y = element_line(colour = \"gray90\")) +\n  labs(x = \"年份\", y = \"提交量\")\n\n\n\n\n\n\n\n图 3.22: 趋势拟合、预测和推断\n\n\n\n\n\n\n\n3.3.4 模型诊断\n\n所有模型都是错误的，但有些是有用的。\n— 乔治·博克斯\n\n描述模型的敏感性，数据中存在的离群值，变量之间的多重共线性等。引入 Cook 距离、杠杆值、VIF 等来诊断模型。\n\n# 准备数据\nstate_x77 &lt;- data.frame(state.x77,\n  state_name = rownames(state.x77), state_region = state.region,\n  state_abb = state.abb, check.names = FALSE\n)\n# 线性模型拟合\nfit &lt;- lm(`Life Exp` ~ Income + Murder, data = state_x77)\n# 模型诊断图\nlibrary(ggfortify)\nautoplot(fit, which = 1:6, label.size = 3)\n#&gt; Warning: `fortify(&lt;lm&gt;)` was deprecated in ggplot2 3.6.0.\n#&gt; ℹ Please use `broom::augment(&lt;lm&gt;)` instead.\n#&gt; ℹ The deprecated feature was likely used in the ggfortify package.\n#&gt;   Please report the issue at\n#&gt;   &lt;https://github.com/sinhrks/ggfortify/issues&gt;.\n#&gt; Warning: `aes_string()` was deprecated in ggplot2 3.0.0.\n#&gt; ℹ Please use tidy evaluation idioms with `aes()`.\n#&gt; ℹ See also `vignette(\"ggplot2-in-packages\")` for more information.\n#&gt; ℹ The deprecated feature was likely used in the ggfortify package.\n#&gt;   Please report the issue at\n#&gt;   &lt;https://github.com/sinhrks/ggfortify/issues&gt;.\n#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `linewidth` instead.\n#&gt; ℹ The deprecated feature was likely used in the ggfortify package.\n#&gt;   Please report the issue at\n#&gt;   &lt;https://github.com/sinhrks/ggfortify/issues&gt;.\n\n\n\n\n\n\n\n图 3.23: 线性模型的诊断图\n\n\n\n\n\n对于复杂的统计模型，比如混合效应模型的诊断，ggPMX 包。\n\n\n3.3.5 边际效应\n继续 state_x77 数据集，以预期寿命（1969-1971 年统计）为因变量，Income 人均收入（1974 年）和 Murder 谋杀和非过失杀人率（单位：十万分之一，1976 年统计）为自变量，建立线性模型如下：\n\\[\n\\text{Life Exp} = \\alpha + \\beta_1  \\text{Income} + \\beta_2 \\text{Murder} + \\epsilon\n\\tag{3.2}\\]\n在 R 语言中，可以用函数 lm() 拟合上述模型，\n\nfit &lt;- lm(`Life Exp` ~ Income + Murder, data = state_x77)\n\n模型拟合结果输出如下：\n\nsummary(fit)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = `Life Exp` ~ Income + Murder, data = state_x77)\n#&gt; \n#&gt; Residuals:\n#&gt;      Min       1Q   Median       3Q      Max \n#&gt; -1.48301 -0.62099 -0.01714  0.47768  2.20831 \n#&gt; \n#&gt; Coefficients:\n#&gt;               Estimate Std. Error t value Pr(&gt;|t|)    \n#&gt; (Intercept) 71.2255815  0.9673952  73.626  &lt; 2e-16 ***\n#&gt; Income       0.0003705  0.0001973   1.878   0.0666 .  \n#&gt; Murder      -0.2697594  0.0328408  -8.214 1.22e-10 ***\n#&gt; ---\n#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#&gt; \n#&gt; Residual standard error: 0.8259 on 47 degrees of freedom\n#&gt; Multiple R-squared:  0.637,  Adjusted R-squared:  0.6215 \n#&gt; F-statistic: 41.23 on 2 and 47 DF,  p-value: 4.561e-11\n\nggeffects 描述单个自变量的作用，人均收入对预期寿命的边际效应\n\nlibrary(ggeffects)\nincome_pred &lt;- ggpredict(fit, terms = \"Income\")\n#&gt; Warning: Looks like you are using syntactically invalid variable names,\n#&gt;   quoted in backticks: `Life Exp`. This may result in unexpected\n#&gt;   behaviour. Please rename your variables (e.g., `Life.Exp`\n#&gt;   instead of `Life Exp`) and fit the model again.\nggplot(income_pred, aes(x, predicted)) +\n  geom_line() +\n  geom_ribbon(aes(ymin = conf.low, ymax = conf.high), alpha = 0.1) +\n  theme_classic() +\n  labs(x = \"人均收入\", y = \"预期寿命\")\n\n\n\n\n\n\n\n图 3.24: 边际效应\n\n\n\n\n\n\n\n\n\nAttali, Dean, 和 Christopher Baker. 2022. ggExtra: Add Marginal Histograms to ggplot2, and More ggplot2 Enhancements. https://CRAN.R-project.org/package=ggExtra.\n\n\nClopper, C. J., 和 E. S. Pearson. 1934. 《The Use of Confidence or Fiducial Limits Illustrated In The Case of The Binomial》. Biometrika 26 (4): 404–13. https://doi.org/10.1093/biomet/26.4.404.\n\n\nConstantin, Ahlmann-Eltze, 和 Indrajeet Patil. 2021. 《ggsignif: R Package for Displaying Significance Brackets for ggplot2》. PsyArxiv. https://doi.org/10.31234/osf.io/7awm6.\n\n\nKay, Matthew. 2022. ggdist: Visualizations of Distributions and Uncertainty. https://doi.org/10.5281/zenodo.3879620.\n\n\nMcGill, Tukey, R., 和 W. A. Larsen. 1978. 《Variations of box plots》. The American Statistician 32 (1): 12–16. https://www.jstor.org/stable/2683468.\n\n\nOtto, James, 和 David Kahle. 2023. 《ggdensity: Improved Bivariate Density Visualization in R》. The R Journal 15: 220–36. https://doi.org/10.32614/RJ-2023-048.\n\n\nPatil, Indrajeet. 2021. 《Visualizations with statistical details: The ggstatsplot approach》. Journal of Open Source Software 6 (61): 3167. https://doi.org/10.21105/joss.03167.\n\n\nSidiropoulos, Nikos, Sina Hadi Sohi, Thomas Lin Pedersen, Bo Torben Porse, Ole Winther, Nicolas Rapin, 和 Frederik Otzen Bagger. 2018. 《SinaPlot: An Enhanced Chart for Simple and Truthful Representation of Single Observations Over Multiple Classes》. Journal of Computational and Graphical Statistics 27 (3): 673–76. https://doi.org/10.1080/10618600.2017.1366914.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>统计图形</span>"
    ]
  },
  {
    "objectID": "visualization-lattice.html",
    "href": "visualization-lattice.html",
    "title": "4  lattice 入门",
    "section": "",
    "text": "4.1 分组散点图\nlattice 最初是受到商业统计软件 S/S-Plus 中的 Trellis 组件启发，打算在 R 软件中重新实现一套新的绘图系统，在使用接口上保持与 Trellis 兼容，Trellis 使用文档也同样适用于 lattice。\n本章主要介绍 lattice 包 (Sarkar 2008) 及其相关的 latticeExtra 包。\n函数 xyplot() 在 lattice 包中非常具有代表性，掌握此函数的作图规律，其它函数学起来也就不难了。分组散点图是一个非常常见的、用来描述变量之间关系的图形，下面就以绘制一个分组散点图来介绍函数 xyplot() 的用法。\nlibrary(lattice)\nxyplot(\n  x = Sepal.Length ~ Petal.Length, groups = Species, scales = \"free\",\n  data = iris, grid = TRUE, xlab = \"萼片长度\", ylab = \"花瓣长度\",\n  auto.key = list(space = \"top\", columns = 3)\n)\n\n\n\n\n\n\n\n图 4.1: 分组散点图\n除了通过 space 参数设置图例的位置，还可以通过坐标设置图例的位置，比如下 图 4.2 (b) 中设置图例的位置坐标为 x = 1, y = 0 使得图例位于图的右下角。图例坐标的参考点是原点 x = 0, y = 0 就是左下角的位置，而右上角的位置为 x = 1, y = 1 。\n除了上面介绍的几个参数，还有许多其它参数，其中一部分会在后续介绍其它种类的图形时顺带介绍，剩余的部分请感兴趣的读者查看函数 xyplot() 的帮助文档。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>lattice 入门</span>"
    ]
  },
  {
    "objectID": "visualization-lattice.html#sec-lattice-xyplot",
    "href": "visualization-lattice.html#sec-lattice-xyplot",
    "title": "4  lattice 入门",
    "section": "",
    "text": "参数 x 需要传递 R 语言中的表达式，这是一种被广泛使用的公式语法，示例中为 Sepal.Length ~ Petal.Length ，表示横坐标为 Petal.Length， 纵坐标为 Sepal.Length 。\n参数 groups 指定分组变量，此处为 Species 变量，表示鸢尾花种类。\n参数 scales 设置坐标轴刻度， scales = \"free\" 表示去掉边框上面和右面的刻度线。\n参数 data 指定绘图数据，此处为 iris 数据集。\n参数 grid 控制是否添加背景网格线，此处为 TRUE 表示添加背景网格线。\n参数 xlab 和参数 ylab 分别指定横、纵坐标轴标签。\n参数 auto.key 设置图例，示例中设置 space = \"top\" 将图例置于图形上方，设置 columns = 3 使条目排成 3 列，此外，设置 reverse.rows = TRUE 还可以使图例中的条目顺序反向。\n\n\nxyplot(\n  Sepal.Length ~ Petal.Length, groups = Species, data = iris,\n  scales = \"free\", grid = TRUE, xlab = \"萼片长度\", ylab = \"花瓣长度\", \n  auto.key = list(space = \"right\", columns = 1)\n)\nxyplot(\n  Sepal.Length ~ Petal.Length, groups = Species, data = iris,\n  scales = \"free\", grid = TRUE, xlab = \"萼片长度\", ylab = \"花瓣长度\", \n  auto.key = list(corner = c(1, 0))\n)\n\n\n\n\n\n\n\n\n\n\n\n(a) 图例位于图右侧\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) 图例位于内内部\n\n\n\n\n\n\n\n图 4.2: 调整图例位置",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>lattice 入门</span>"
    ]
  },
  {
    "objectID": "visualization-lattice.html#sec-lattice-par",
    "href": "visualization-lattice.html#sec-lattice-par",
    "title": "4  lattice 入门",
    "section": "4.2 图形参数",
    "text": "4.2 图形参数\n类似 Base R 绘图系统中的图形参数设置函数 par()和 ggplot2 包中的主题设置函数 theme()， lattice 包也有图形参数设置函数 trellis.par.set() ，而图形参数查询函数为 trellis.par.get() 。可设置的图形参数非常多，仅常用的也不少。首先来看看有哪些图形参数可以设置。\n\ntp &lt;- trellis.par.get()\nnames(tp)\n#&gt;  [1] \"grid.pars\"         \"fontsize\"          \"background\"       \n#&gt;  [4] \"panel.background\"  \"clip\"              \"add.line\"         \n#&gt;  [7] \"add.text\"          \"plot.polygon\"      \"box.dot\"          \n#&gt; [10] \"box.rectangle\"     \"box.umbrella\"      \"dot.line\"         \n#&gt; [13] \"dot.symbol\"        \"plot.line\"         \"plot.symbol\"      \n#&gt; [16] \"reference.line\"    \"strip.background\"  \"strip.shingle\"    \n#&gt; [19] \"strip.border\"      \"superpose.line\"    \"superpose.symbol\" \n#&gt; [22] \"superpose.polygon\" \"regions\"           \"shade.colors\"     \n#&gt; [25] \"axis.line\"         \"axis.text\"         \"axis.components\"  \n#&gt; [28] \"layout.heights\"    \"layout.widths\"     \"box.3d\"           \n#&gt; [31] \"par.title.text\"    \"par.xlab.text\"     \"par.ylab.text\"    \n#&gt; [34] \"par.zlab.text\"     \"par.main.text\"     \"par.sub.text\"\n\n可以看到，图形参数着实非常多，知道了这么多图形参数，而每个参数又有哪些选项可取呢？不忙，再看看图形参数的结构，比如 superpose.symbol 。\n\ntp$superpose.symbol\n#&gt; $alpha\n#&gt; [1] 1 1 1 1 1 1 1\n#&gt; \n#&gt; $cex\n#&gt; [1] 0.8 0.8 0.8 0.8 0.8 0.8 0.8\n#&gt; \n#&gt; $col\n#&gt; [1] \"#0072B2\" \"#E69F00\" \"#009E73\" \"#D55E00\" \"#56B4E9\" \"#F0E442\"\n#&gt; [7] \"#CC79A7\"\n#&gt; \n#&gt; $fill\n#&gt; [1] \"#CCFFFF\" \"#FFCCFF\" \"#CCFFCC\" \"#FFE5CC\" \"#CCE6FF\" \"#FFFFCC\"\n#&gt; [7] \"#FFCCCC\"\n#&gt; \n#&gt; $font\n#&gt; [1] 1 1 1 1 1 1 1\n#&gt; \n#&gt; $pch\n#&gt; [1] 1 1 1 1 1 1 1\n\n这是一个列表，有 6 个元素，每个元素设置符号的不同属性，依次是透明度 alpha、大小 cex、颜色 col、填充色 fill、字型 font 和类型 pch ，这些属性的含义与函数 par() 是一致的。下 图 4.3 展示所有的常用图形参数及其可设置的选项。\n\n\n\n\n\n\n\n\n图 4.3: 常用图形参数\n\n\n\n\n\n现在，知道了图形设置参数及其结构，还需要知道它们究竟在绘图时起什么作用，也就是说它们控制图形中的哪部分元素及效果。下 图 4.4 展示 lattice 包图形参数效果。由图可知，图形参数 superpose.symbol 是控制散点图中的点，点可以是普通的点，也可以是任意的字母符号。\n\n\n\n\n\n\n\n\n图 4.4: 图形参数效果预览\n\n\n\n\n\n在之前的 图 4.1 的基础上，设置 type = c(\"p\", \"r\") 添加回归线。通过图形参数 par.settings 设置各类绘图元素的符号类型和大小，该参数接受一个列表类型的数据，列表的元素还是列表，列表的层层嵌套实现图中元素的精细控制。列表元素 superpose.symbol 控制点的符号，pch = 16 设置为 16，相比于默认的点要大一号。列表元素 superpose.line 控制线，lwd = 2 设置宽度为 2，比默认的宽度大一倍，lty = 3 设置线的类型为 3，表示虚线。通过参数 auto.key 设置图例位置，图例位于图形上方，图例中的条目排成3列。\n\nxyplot(\n  Sepal.Length ~ Petal.Length, groups = Species, data = iris,\n  scales = \"free\", grid = TRUE, type = c(\"p\", \"r\"),\n  xlab = \"萼片长度\", ylab = \"花瓣长度\", \n  auto.key = list(columns = 3, space = \"top\"), \n  par.settings = list(\n    superpose.symbol = list(pch = 16),\n    superpose.line = list(lwd = 2, lty = 3)\n  )\n)\n\n\n\n\n\n\n\n图 4.5: 调整点、线、图例元素\n\n\n\n\n\nlatticeExtra 包有两个函数专门用来设置图形风格，分别是 theEconomist.theme() 和 ggplot2like() ，这两个主题函数提供一系列预设的图形参数，前者来自《经济学人》杂志的图形主题，后者来自 ggplot2 包的默认绘图主题。\nlibrary(latticeExtra)\nxyplot(\n  Sepal.Length ~ Petal.Length, groups = Species, data = iris,\n  scales = \"free\", grid = TRUE, xlab = \"萼片长度\", ylab = \"花瓣长度\", \n  auto.key = list(space = \"top\", columns = 3), \n  par.settings = ggplot2like()\n)\nxyplot(\n  Sepal.Length ~ Petal.Length, groups = Species, data = iris,\n  scales = \"free\", grid = TRUE, xlab = \"萼片长度\", ylab = \"花瓣长度\", \n  auto.key = list(space = \"top\", columns = 3), \n  par.settings = theEconomist.theme(with.bg = TRUE, box = \"transparent\")\n)\n\n\n\n\n\n\n\n\n\n\n\n(a) ggplot2 包默认的绘图主题\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) 《经济学人》杂志的绘图主题\n\n\n\n\n\n\n\n图 4.6: latticeExtra 内置的两个主题",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>lattice 入门</span>"
    ]
  },
  {
    "objectID": "visualization-lattice.html#sec-common-lattice",
    "href": "visualization-lattice.html#sec-common-lattice",
    "title": "4  lattice 入门",
    "section": "4.3 常见图形",
    "text": "4.3 常见图形\n\n4.3.1 分组柱形图\n本节所用数据集 Insurance 来自 MASS 包，记录一家保险公司面临风险的投保人数量，以及在 1973 年第 3 季度他们提出汽车理赔的数量。数据类型、各个变量的类型及部分预览数据如下：\n\ndata(Insurance, package = \"MASS\")\nstr(Insurance)\n#&gt; 'data.frame':    64 obs. of  5 variables:\n#&gt;  $ District: Factor w/ 4 levels \"1\",\"2\",\"3\",\"4\": 1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ Group   : Ord.factor w/ 4 levels \"&lt;1l\"&lt;\"1-1.5l\"&lt;..: 1 1 1 1 2 2 2 2 3 3 ...\n#&gt;  $ Age     : Ord.factor w/ 4 levels \"&lt;25\"&lt;\"25-29\"&lt;..: 1 2 3 4 1 2 3 4 1 2 ...\n#&gt;  $ Holders : int  197 264 246 1680 284 536 696 3582 133 286 ...\n#&gt;  $ Claims  : int  38 35 20 156 63 84 89 400 19 52 ...\n\n其中，District 表示投保人居住的地区，因子型变量。Group 汽车按油箱大小分组的变量，有序的因子型变量。Age 投保人的年龄段标签，有序的因子型变量。Holders 投保人数量，整型变量。Claims 理赔数量，整型变量。下 图 4.7 先按投保人的汽车类型分面，再按投保人所在地区分组，展示理赔频度与投保人年龄的关系。\n\nbarchart(\n  Claims / Holders ~ Age | Group, groups = District,\n  data = Insurance, xlab = \"年龄段\", ylab = \"理赔频度\",\n  auto.key = list(space = \"top\", columns = 4, title = \"地区\", cex.title = 1)\n)\n\n\n\n\n\n\n\n图 4.7: 分组柱形图\n\n\n\n\n\n函数 barchart() 中的公式 Claims / Holders ~ Age | Group ，斜杠 / 表示除法，波浪线 ~ 表示响应变量与自变量的分界，竖线 | 表示分面。\n\n\n4.3.2 分组箱线图\n\nbwplot(Petal.Length ~ Species, data = iris, scales = \"free\",\n  xlab = \"鸢尾花种类\", ylab = \"花瓣长度\")\n\n\n\n\n\n\n\n图 4.8: 分组箱线图\n\n\n\n\n\n\n\n4.3.3 经验分布图\n用阶梯图表示累积经验分布图，纵轴表示累积概率，不同种类的鸢尾花，花瓣长度的分布明显不同。根据 Glivenko–Cantelli 定理，经验分布函数以概率 1 收敛至累积分布函数。\n\nlibrary(latticeExtra)\necdfplot(~ Petal.Length | Species, data = iris, scales = \"free\", \n         xlab = \"花瓣长度\", ylab = \"累积概率\")\n\n\n\n\n\n\n\n图 4.9: 经验分布图\n\n\n\n\n\n\n\n4.3.4 回归曲线图\n\nsplines 自然立方样条 ns()\nmgcv 广义可加模型 s()\n\n\n\n\n\n\n\n\n\n图 4.10: 调色板\n\n\n\n\n\n图 4.11 中用不同的回归模型拟合数据中的趋势。1920s 汽车行驶距离和速度的关系图。函数 panel.smoother() 来自 latticeExtra 包\nlibrary(splines)\nlibrary(nlme)\nlibrary(mgcv)\nxyplot(dist ~ speed,\n  data = cars, scales = \"free\", xlab = \"速度\", ylab = \"距离\",\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    panel.smoother(y ~ x,\n      col.line = \"#EA4335\", method = \"lm\", ...\n    )\n  }\n)\nxyplot(dist ~ speed,\n  data = cars, scales = \"free\", xlab = \"速度\", ylab = \"距离\",\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    panel.smoother(y ~ x,\n      col.line = \"#4285f4\", method = \"loess\", span = 0.9, ...\n    )\n  }\n)\nxyplot(dist ~ speed,\n  data = cars, scales = \"free\", xlab = \"速度\", ylab = \"距离\",\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    panel.smoother(y ~ ns(x, 5),\n      col.line = \"#34A853\", method = \"lm\", ...\n    )\n  }\n)\nxyplot(dist ~ speed,\n  data = cars, scales = \"free\", xlab = \"速度\", ylab = \"距离\",\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    panel.smoother(y ~ s(x),\n      col.line = \"#FBBC05\", method = \"gam\", ...\n    )\n  }\n)\n\n\n\n\n\n\n\n\n\n\n\n(a) 线性回归\n\n\n\n\n\n\n\n\n\n\n\n(b) 局部多项式回归\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 自然样条回归\n\n\n\n\n\n\n\n\n\n\n\n(d) 广义可加回归\n\n\n\n\n\n\n\n图 4.11: 回归曲线图\n\n\n\n\n\n4.3.5 置信区间图\n各个郡县每 10 万人当中因癌症死亡的人数。USCancerRates 数据集来自 latticeExtra 包，记录各个郡县的癌症死亡率及其置信区间，下图展示新泽西州各个郡县的癌症死亡率及其置信区间。\n\nsegplot(reorder(county, rate.male) ~ LCL95.male + UCL95.male,\n  data = subset(USCancerRates, state == \"New Jersey\"),\n  draw.bands = FALSE, centers = rate.male,\n  scales = list(x = list(alternating = 1, tck = c(1, 0))),\n  xlab = \"癌症死亡率\", ylab = \"郡县\"\n)\n\n\n\n\n\n\n\n图 4.12: 置信区间图\n\n\n\n\n\n\n\n4.3.6 置信椭圆图\nlatticeExtra 包的函数 panel.ellipse() 可以绘制置信椭圆。二维数据，置信水平为 0.95 时，置信椭圆。\n\nxyplot(Sepal.Length ~ Petal.Length,\n  groups = Species, data = iris, scales = \"free\",\n  xlab = \"萼片长度\", ylab = \"花瓣长度\",\n  par.settings = list(\n    superpose.symbol = list(pch = 16),\n    superpose.line = list(lwd = 2, lty = 3)\n  ),\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    panel.ellipse(x, y, level = 0.85, ...)\n  },\n  auto.key = list(space = \"top\", columns = 3)\n)\n\n\n\n\n\n\n\n图 4.13: 分组置信椭圆图\n\n\n\n\n\n\n\n4.3.7 切片水平图\n按照深度降序排列，根据震级 mag 划分 4 个区间，每个区间内数据点的数量比较平衡，相邻区间之间有重叠部分。对数据进行切片，观察连续的切片数据，增加一个维度。\n对震深排序的目的是让数据点按照一定的顺序绘制在图上，数据点相距较近容易互相覆盖。使得在二维平面上，通过对数据点的染色，也能体现地震深度在空间中的层次变化。\n不同的震级下，地震深度在空间中的变化是一致的。\n\n# 震级区间\nquakes$Magnitude &lt;- equal.count(quakes$mag, number = 4)\n# 震深\ndepth.ord &lt;- rev(order(quakes$depth))\nquakes.ordered &lt;- quakes[depth.ord, ]\n\nIntervals:\n   min  max count\n1 3.95 4.55   484\n2 4.25 4.75   492\n3 4.45 4.95   425\n4 4.65 6.45   415\n\nOverlap between adjacent intervals:\n[1] 293 306 217\n函数 equal.count() 内部调用函数 co.intervals() ，还有两个参数 number 和 overlap。如果要没有重叠的话，得设置 overlap = 0 。\n\nquakes$Magnitude &lt;- equal.count(quakes$mag, number = 4, overlap = 0)\n\n\nlevelplot(depth ~ long + lat | Magnitude,\n  data = quakes.ordered, scales = \"free\",\n  panel = panel.levelplot.points, \n  prepanel = prepanel.default.xyplot, \n  type = c(\"p\", \"g\"), layout = c(2, 2)\n)\n\n\n\n\n\n\n\n图 4.14: 分面水平图\n\n\n\n\n\n\n\n4.3.8 三维散点图\nlattice 包的函数 cloud() 三维散点图\n\ncloud(Sepal.Length ~ Sepal.Width + Petal.Length,\n  groups = Species, data = iris,\n  # 去掉方向箭头\n  scales = list(arrows = FALSE, col = \"black\"),\n  xlab = list(\"萼片宽度\", rot = 30),\n  ylab = list(\"花瓣长度\", rot = -35),\n  zlab = list(\"萼片长度\", rot = 90),\n  # 减少三维图形的边空\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -0.5, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -1.5, units = \"inches\"),\n      top.padding = list(x = -1.5, units = \"inches\")\n    )\n  ),\n  par.settings = list(\n    # 点的类型\n    superpose.symbol = list(pch = 16),\n    # 去掉外框线\n    axis.line = list(col = \"transparent\")\n  )\n)\n\n\n\n\n\n\n\n图 4.15: 三维散点图\n\n\n\n\n\n下面是一个示例，自定义面板函数 panel.3d.cloud 。\n\n\n\n\n\n\n注记\n\n\n\n图底部的网格待改进，生成网格线的代码太死板。\n\n\n\n# 加载数据\nrongelap &lt;- readRDS(file = \"data/rongelap.rds\")\nrongelap_coastline &lt;- readRDS(file = \"data/rongelap_coastline.rds\")\n\nlibrary(lattice)\n# 参考 lattice 书籍的图 6.5 的绘图代码\npanel.3dcoastline &lt;- function(..., rot.mat, distance, xlim, ylim, zlim,\n                              xlim.scaled, ylim.scaled, zlim.scaled) {\n  scale.vals &lt;- function(x, original, scaled) {\n    scaled[1] + (x - original[1]) * diff(scaled) / diff(original)\n  }\n  scaled.map &lt;- rbind(\n    scale.vals(rongelap_coastline$cX, xlim, xlim.scaled),\n    scale.vals(rongelap_coastline$cY, ylim, ylim.scaled),\n    zlim.scaled[1]\n  )\n  m &lt;- ltransform3dto3d(scaled.map, rot.mat, distance)\n  panel.lines(m[1, ], m[2, ], col = \"black\")\n}\n\nrongelap_grid_line &lt;- rbind.data.frame(\n  data.frame(x = 1000 * -6:0, y = -3500),\n  data.frame(x = 1000 * 0:-6, y = -3000),\n  data.frame(x = 1000 * -6:0, y = -2500),\n  data.frame(x = 1000 * 0:-6, y = -2000),\n  data.frame(x = 1000 * -6:0, y = -1500),\n  data.frame(x = 1000 * 0:-6, y = -1000),\n  data.frame(x = 1000 * -6:0, y = -500),\n  data.frame(x = 1000 * 0:-6, y = 0),\n  data.frame(x = -6000, y = -500 * 7:0),\n  data.frame(x = -5000, y = -500 * 0:7),\n  data.frame(x = -4000, y = -500 * 7:0),\n  data.frame(x = -3000, y = -500 * 0:7),\n  data.frame(x = -2000, y = -500 * 7:0),\n  data.frame(x = -1000, y = -500 * 0:7),\n  data.frame(x = 0, y = -500 * 7:0)\n)\n\npanel.3dgridline &lt;- function(..., rot.mat, distance, xlim, ylim, zlim,\n                              xlim.scaled, ylim.scaled, zlim.scaled) {\n  scale.vals &lt;- function(x, original, scaled) {\n    scaled[1] + (x - original[1]) * diff(scaled) / diff(original)\n  }\n  scaled.map &lt;- rbind(\n    scale.vals(rongelap_grid_line$x, xlim, xlim.scaled),\n    scale.vals(rongelap_grid_line$y, ylim, ylim.scaled),\n    zlim.scaled[1]\n  )\n  m &lt;- ltransform3dto3d(scaled.map, rot.mat, distance)\n  panel.lines(x = m[1,], y = m[2,], col = \"gray\", lty = 2)\n}\n\ncloud(counts / time ~ cX * cY,\n  data = rongelap, col = \"black\",\n  xlim = c(-6500, 100), ylim = c(-3800, 150),\n  scales = list(arrows = FALSE, col = \"black\"),\n  aspect = c(0.75, 0.5),\n  xlab = list(\"横坐标（米）\", rot = 20),\n  ylab = list(\"纵坐标（米）\", rot = -50),\n  zlab = list(\"辐射强度\", rot = 90),\n  type = c(\"p\", \"h\"), pch = 16, lwd = 0.5,\n  panel.3d.cloud = function(...) {\n    panel.3dgridline(...)\n    panel.3dcoastline(...) # 海岸线\n    panel.3dscatter(...)\n  },\n  # 减少三维图形的边空\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -0.5, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -1.5, units = \"inches\"),\n      top.padding = list(x = -1.5, units = \"inches\")\n    )\n  ),\n  par.settings = list(\n    # 移除几条内框线\n    # box.3d = list(col = c(1, 1, NA, NA, 1, NA, 1, 1, 1)),\n    # 刻度标签字体大小\n    axis.text = list(cex = 0.8),\n    # 去掉外框线\n    axis.line = list(col = \"transparent\")\n  ),\n  # 设置三维图的观察方位\n  screen = list(z = 30, x = -65, y = 0)\n)\n\n\n\n\n\n\n\n图 4.16: 添加三维网格参考线和透视曲线\n\n\n\n\n\n\n\n4.3.9 三维透视图\n有如下参数方程\n\\[\n\\begin{aligned}\n\\left\\{\n\\begin{array}{l}\nx(u,v) = \\cos(u)\\big(r + \\cos(u / 2)\\big) \\\\\ny(u,v) = \\sin(u)\\big(r + \\cos(u / 2)\\sin(tv) - \\sin(u / 2)\\sin(2tv)\\big)\\sin(tv) -\n    \\sin(u / 2)\\sin(2tv) \\\\\nz(u,v) = \\sin(u / 2) \\sin(tv) + \\cos(u / 2) \\sin(tv)\n\\end{array} \\right.\n\\end{aligned}\n\\]\n其中，\\(u\\) 和 \\(v\\) 是参数，\\(\\frac{u}{2\\pi} \\in [0.3,1.25], \\frac{v}{2\\pi} \\in [0,1]\\)，\\(r\\) 和 \\(t\\) 是常量，不妨设 \\(r = 2\\) 和 \\(t=1\\) 。\n\n# lattice 书 6.3.1 节 参数\nkx &lt;- function(u, v) cos(u) * (r + cos(u / 2))\nky &lt;- function(u, v) {\n  sin(u) * (r + cos(u / 2) * sin(t * v) -\n    sin(u / 2) * sin(2 * t * v)) * sin(t * v) -\n    sin(u / 2) * sin(2 * t * v)\n}\nkz &lt;- function(u, v) sin(u / 2) * sin(t * v) + cos(u / 2) * sin(t * v)\nn &lt;- 50\nu &lt;- seq(0.3, 1.25, length = n) * 2 * pi\nv &lt;- seq(0, 1, length = n) * 2 * pi\num &lt;- matrix(u, length(u), length(u))\nvm &lt;- matrix(v, length(v), length(v), byrow = TRUE)\nr &lt;- 2\nt &lt;- 1\n\nwireframe(kz(um, vm) ~ kx(um, vm) + ky(um, vm),\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), ylab = expression(x[2]),\n  zlab = list(expression(\n    italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")\n  ), rot = 90), alpha = 0.75,\n  scales = list(arrows = FALSE, col = \"black\"),\n  # 减少三维图形的边空\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -0.5, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -1.5, units = \"inches\"),\n      top.padding = list(x = -1.5, units = \"inches\")\n    )\n  ),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 30, x = -65, y = 0)\n)\n\n\n\n\n\n\n\n图 4.17: 三维透视图\n\n\n\n\n\n绘图函数 wireframe() 支持使用公式语法，也支持矩阵类型的数据绘制透视图。\n\nwireframe(volcano,\n  drape = TRUE, colorkey = FALSE, shade = TRUE,\n  xlab = list(\"南北方向\", rot = -40),\n  ylab = list(\"东西方向\", rot = 45),\n  zlab = list(\"高度\", rot = 90),\n  # 减少三维图形的边空\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -.6, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -.8, units = \"inches\"),\n      top.padding = list(x = -1.0, units = \"inches\")\n    )\n  ),\n  # 设置坐标轴字体大小\n  par.settings = list(\n    axis.line = list(col = \"transparent\"),\n    fontsize = list(text = 12, points = 10)\n  ),\n  scales = list(arrows = FALSE, col = \"black\"), \n  screen = list(z = -45, x = -50, y = 0)\n)\n\n\n\n\n\n\n\n图 4.18: 奥克兰火山地形图\n\n\n\n\n\n\n\n4.3.10 地形轮廓图\n绘图函数 levelplot() 支持使用公式语法，也支持矩阵类型的数据绘制轮廓图。基于奥克兰火山地形数据 volcano 绘制轮廓图，volcano 是矩阵类型的数据。\n\nlevelplot(volcano, useRaster = TRUE,\n  # 去掉图形上、右边多余的刻度线\n  scales = list(\n    x = list(alternating = 1, tck = c(1, 0)),\n    y = list(alternating = 1, tck = c(1, 0))\n  ),\n  par.settings = list(\n    # x/y 轴标签字体，刻度标签字体\n    par.xlab.text = list(fontfamily = \"Noto Serif CJK SC\"),\n    par.ylab.text = list(fontfamily = \"Noto Serif CJK SC\"),\n    axis.text = list(fontfamily = \"sans\")\n  ),\n  xlab = \"南北方向\", ylab = \"东西方向\"\n)\n\n\n\n\n\n\n\n图 4.19: 奥克兰火山的地形轮廓图\n\n\n\n\n\n函数 levelplot() 的参数 col.regions 需要传递一个函数，示例中使用的默认设置。常见的函数有 hcl.colors() 、 gray.colors() 、terrain.colors() 、cm.colors() 和 topo.colors() 等，函数 hcl.colors() 默认使用 viridis 调色板，还可以用函数 colorRampPalette() 构造调色板函数。\n\ndata(topo, package = \"MASS\")\nlevelplot(z ~ x * y, data = topo, scales = \"free\",\n  panel = panel.2dsmoother, contour = TRUE,\n  form = z ~ s(x, y, bs = \"gp\", k = 50), method = \"gam\",\n  xlab = \"水平方向\", ylab = \"垂直方向\"\n)\n\n\n\n\n\n\n\n图 4.20: 奥克兰火山的地形轮廓图\n\n\n\n\n\n函数 panel.2dsmoother() 来自 latticeExtra 包，数据的二维分布，默认采用 tp\n\ntp thin plate regression spline 回归样条方法平滑。\ncr Cubic regression spline 立方回归样条。\ngp Gaussian process smooths 高斯过程平滑，默认为全秩 Full Rank，指定 k 低秩近似 Low Rank。\n\n\n\n4.3.11 地区分布图\n最后一个想要介绍的是地区分布图，也叫面量图、围栏图，描述空间栅格数据的分布，常见的一种情况是展示各个地区的人口、社会、经济指标。下面通过 tigris 包可以下载美国人口调查局发布的数据，本想下载与观测数据年份最近的地图数据，但是 2009 年及以前的地图数据缺失，因此，笔者下载了 2010 年的地图数据，它与得票率数据最近。\n\nlibrary(tigris)\nus_state_map &lt;- states(cb = TRUE, year = 2010, resolution = \"20m\", class = \"sf\")\nus_state_map &lt;- shift_geometry(us_state_map, geoid_column = \"STATE\", position = \"below\")\n\n第一行代码用 tigris 包的函数 states() 下载 2010 年比例尺为 1:20000000 的多边形州边界矢量地图数据，返回一个 simple feature 类型的空间数据类型。第二行代码用该包的另一个函数 shift_geometry() 移动离岸的州和领地，将它们移动到主体部分的下方。\n\nlibrary(sf)\nus_state_sf &lt;- readRDS(\"data/us-state-map-2010.rds\")\n# sf 转 sp\nus_state_sp &lt;- as(us_state_sf, \"Spatial\")\nlibrary(maps)\n# sp 转 map\nus_state_map &lt;- SpatialPolygons2map(us_state_sp, namefield = \"NAME\")\n# 准备观测数据\ndata(votes.repub)\n# 转为 data.frame 类型\nvotes_repub &lt;- as.data.frame(votes.repub)\n\n数据集 votes.repub 记录 1856-1976 年美国历届大选中共和党在各州的得票率。图中以由红到蓝的颜色变化表示由低到高的得票率，1964 年共和党在东南一隅得票率较高，在其它地方得票率普遍较低，形成一边倒的情况，最终由民主党的林登·约翰逊当选美国第36任总统。1968 年共和党在东南部得票率最低，与 1964 年相比，整个反过来了，最终由共和党的理查德·尼克松当选美国第37任总统。\n\nlibrary(RColorBrewer)\nrdbu_pal &lt;- colorRampPalette(colors = brewer.pal(n = 11, name = \"RdBu\"))\nmapplot(rownames(votes_repub) ~ `1964` + `1968`, data = votes_repub,\n  border = NA, map = us_state_map, colramp = rdbu_pal, layout = c(1, 2),\n  scales = list(draw = FALSE), xlab = \"\", ylab = \"\"\n)\n\n\n\n\n\n\n\n图 4.21: 共和党在各州的得票率\n\n\n\n\n\n参数 border 设置州边界线的颜色，NA 表示去掉边界线。参数 map 设置州边界地图数据。参数 colramp 设置一个调色板，用于将得票率与调色板上的颜色映射起来。美国历届大选，共和党和民主党竞争总统职位，最终由得票率决定，用红蓝对抗型调色板表现竞争关系。基于 RColorBrewer 包的 RdBu 调色板，用函数 colorRampPalette() 构造一个新的红蓝调色板。参数 layout 将多个子图按照一定顺序排列，图中设置 2 行 1 列的多图布局。参数 scales 用来调整刻度，设置 list(draw = FALSE) 将图中的刻度去掉了。参数 xlab 设置一个空字符，即 xlab = \"\" 可去掉横坐标轴标签，参数 ylab 应用于设置纵坐标，用法与参数 xlab 一样。图中，主要表现得票率在各州的分布，因此，坐标轴刻度和标签都不太重要，可以去掉。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>lattice 入门</span>"
    ]
  },
  {
    "objectID": "visualization-lattice.html#sec-basic-lattice-summary",
    "href": "visualization-lattice.html#sec-basic-lattice-summary",
    "title": "4  lattice 入门",
    "section": "4.4 总结",
    "text": "4.4 总结\n现在回过头来看，无论是图形样式还是绘图语法， lattice 可以看作是介于 Base R 和 ggplot2 之间的一种绘图风格。举例来说，下面比较 Base R 和 lattice 的图形样式。\nplot(Sepal.Length ~ Petal.Length, col = Species, data = iris,\n  xlab = \"萼片长度\", ylab = \"花瓣长度\")\nxyplot(Sepal.Length ~ Petal.Length, groups = Species, data = iris,\n  scales = \"free\", xlab = \"萼片长度\", ylab = \"花瓣长度\")\n\n\n\n\n\n\n\n\n\n\n\n(a) Base R 图形\n\n\n\n\n\n\n\n\n\n\n\n(b) lattice 图形\n\n\n\n\n\n\n\n图 4.22: 对比 Base R 和 lattice 制作的分组散点图\n\n\n\n与函数 plot() 对应的是函数 xyplot() ，它们共用一套公式语法，参数 data 的含义也是一样的。与参数 col 对应的是参数 groups ，作用是添加数据分组标识。在两个函数中，添加横纵坐标轴标签都是用参数 xlab 和 ylab 。函数 xyplot() 中参数 scales 的作用是对坐标轴刻度的调整，参数值 \"free\" 表示去掉图形上边和右边的刻度线，默认情况下是有刻度线的。\n在高级的绘图函数方面，Base R 和 lattice 基本都有功能对应的函数，在低水平的绘图函数方面，二者截然不同，主要是因为后者基于另一套绘图系统 — grid 绘图系统。Base R 作图常常需要一个函数一个函数地不断叠加，在图中画上点、线、轴、标签等元素，而 lattice 主要通过面板函数，层层叠加的方式，每一个面板函数实现一个功能，整合一系列绘图操作。本章主要介绍 lattice 包和 latticeExtra 包，用到的高级绘图函数如下表。\n\n\n\n表 4.1: lattice 和 latticeExtra 包的部分函数\n\n\n\n\n\n\n\n\n\n\n\nR 包\n函数\n图形\n作用\n\n\n\n\nlattice\nxyplot()\n（分组）散点图\n描述关系\n\n\nlattice\nbwplot()\n（分组）箱线图\n描述分布\n\n\nlattice\nbarchart()\n（分组）柱形图\n描述对比\n\n\nlattice\nlevelplot()\n切片水平图\n描述趋势\n\n\nlattice\nwireframe()\n三维透视图\n描述趋势\n\n\nlattice\ncloud()\n三维散点图\n描述分布\n\n\nlatticeExtra\npanel.smoother()\n回归曲线图\n描述趋势\n\n\nlatticeExtra\npanel.2dsmoother()\n地形轮廓图\n描述趋势\n\n\nlatticeExtra\necdfplot()\n经验分布图\n描述分布\n\n\nlatticeExtra\nsegplot()\n置信区间图\n描述不确定性\n\n\nlatticeExtra\npanel.ellipse()\n置信椭圆图\n描述不确定性\n\n\nlatticeExtra\nmapplot()\n地区分布图\n描述分布\n\n\n\n\n\n\n\n\n\n\nSarkar, Deepayan. 2008. lattice: Multivariate Data Visualization with R. New York: Springer. http://lmdvr.r-forge.r-project.org.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>lattice 入门</span>"
    ]
  },
  {
    "objectID": "visualization-lattice.html#footnotes",
    "href": "visualization-lattice.html#footnotes",
    "title": "4  lattice 入门",
    "section": "",
    "text": "Paul 在 DSC 2001 大会上的幻灯片。↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>lattice 入门</span>"
    ]
  },
  {
    "objectID": "visualization-graphics.html",
    "href": "visualization-graphics.html",
    "title": "5  graphics 入门",
    "section": "",
    "text": "5.1 绘图基础\n不是把每个绘图函数都挨个讲一遍，也不是把它们统统归纳总结，而是比较深入地介绍一、两种图形，一、两个例子，重点阐述 Base R 的绘图特点，使用图形时，注意图形本身的作用，最终，希望读者能够达到举一反三的效果。\n基础绘图系统。相比于 ggplot2 和 lattice，graphics 制作示意图是优势。\n利用点、线等基础元素从零开始绘图。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>graphics 入门</span>"
    ]
  },
  {
    "objectID": "visualization-graphics.html#sec-graphics-elements",
    "href": "visualization-graphics.html#sec-graphics-elements",
    "title": "5  graphics 入门",
    "section": "",
    "text": "5.1.1 plot()\n本节将主要基于鸢尾花数据集介绍 R 语言基础绘图系统，该数据集最早来自埃德加·安德森，后来，被罗纳德·费希尔在介绍判别分析的论文中用到，从而，流行于机器学习社区。鸢尾花是非常漂亮的一种花，在统计和机器学习社区家喻户晓，更别提在植物界的名声。其实，远不止于此，在绘画艺术界也是如雷贯耳，印象派大师文森特·梵高画了一系列鸢尾花作品。万紫千红，但能入画的不多，故而，鸢尾花更显高雅。在生命最后的一段日子里，梵高受精神病折磨，在法国普罗旺斯的圣·雷米医院里，唯有盛开的鸢尾花陪着他，最著名的《星月夜》就是在这时候创作出来的。下面先让我们一睹鸢尾花芳容，图片来自维基百科鸢尾花词条。\n\n\n\n\n\n\n\n\n\n\n\n(a) versicolor 杂色鸢尾\n\n\n\n\n\n\n\n\n\n\n\n(b) setosa 山鸢尾\n\n\n\n\n\n\n\n\n\n\n\n(c) virginica 弗吉尼亚鸢尾\n\n\n\n\n\n\n\n图 5.1: 三种鸢尾花\n\n\n\n鸢尾花数据集已经打包在 R 软件中，而且默认已经加载到命名空间，下面用函数 summary() 查看其概况。\n\nsummary(iris)\n#&gt;   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n#&gt;  Min.   :4.300   Min.   :2.000   Min.   :1.000   Min.   :0.100  \n#&gt;  1st Qu.:5.100   1st Qu.:2.800   1st Qu.:1.600   1st Qu.:0.300  \n#&gt;  Median :5.800   Median :3.000   Median :4.350   Median :1.300  \n#&gt;  Mean   :5.843   Mean   :3.057   Mean   :3.758   Mean   :1.199  \n#&gt;  3rd Qu.:6.400   3rd Qu.:3.300   3rd Qu.:5.100   3rd Qu.:1.800  \n#&gt;  Max.   :7.900   Max.   :4.400   Max.   :6.900   Max.   :2.500  \n#&gt;        Species  \n#&gt;  setosa    :50  \n#&gt;  versicolor:50  \n#&gt;  virginica :50  \n#&gt;                 \n#&gt;                 \n#&gt; \n\n函数 plot() 采用公式语法可以快速作图。\nplot(Sepal.Length ~ Sepal.Width, data = iris)\nplot(iris$Sepal.Width, iris$Sepal.Length, panel.first = grid())\n\n\n\n\n\n\n\n\n\n\n\n(a) 公式语法绘制散点图\n\n\n\n\n\n\n\n\n\n\n\n(b) 带背景参考线的散点图\n\n\n\n\n\n\n\n图 5.2: 快速作图函数 plot()\n\n\n\n函数 plot() 是一个泛型函数，传递不同类型的参数值会调用不同的绘图方法，而不同的绘图方法的参数是不同的。当采用公式语法绘图时，会自动调用函数 plot.formula() ，此时，参数 panel.first 就不起作用。当不使用公式语法时，会调用函数 plot.default() ，此时，参数 panel.first 就起作用，利用该参数可以添加背景参考线。\n\n\n5.1.2 标签\n函数 plot() 的参数 xlab 、ylab 和 main 可以分别设置坐标轴横、纵标签和图主标题。\n\nplot(\n  Sepal.Length ~ Sepal.Width, data = iris, \n  xlab = \"Sepal Width\", ylab = \"Sepal Length\",\n  main = \"Edgar Anderson's Iris Data\"\n)\n\n\n\n\n\n\n\n图 5.3: 标签\n\n\n\n\n\n\n\n5.1.3 字体\n作图函数 plot() 和 title() 都有参数 family ，设置该参数可以调整图形中的字体。下 图 5.4 的横纵坐标轴标签和图标题设为宋体，坐标轴刻度标签设为无衬线字体。\n\nplot(Sepal.Length ~ Sepal.Width, data = iris, ann = FALSE, family = \"sans\")\ntitle(\n  xlab = \"萼片宽度\", ylab = \"萼片长度\",\n  main = \"埃德加·安德森的鸢尾花数据\", family = \"Noto Serif CJK SC\"\n)\n\n\n\n\n\n\n\n图 5.4: 字体\n\n\n\n\n\n\n\n5.1.4 分组\n分组有两种方式，其一按照数据中的分类变量分组，其二按照一定的规则分组。而图形表达的方式可以借助颜色或图形元素的样式。\n函数 plot() 的参数 col 和 pch 都可以用来分组，前者通过颜色，后者通过点的类型。简单起见，将数据集 iris 中的 Species 列传递给参数 col ，实现不同种类的鸢尾花配以不同的颜色。\n\nplot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16)\n\n\n\n\n\n\n\n图 5.5: 分组\n\n\n\n\n\n下面采用一个简单规则将数据分成两组，将鸢尾花中 setosa 山毛榉类型且 Sepal.Length 萼片长度大于 5 厘米的分成一组，以红色填充散点代表这部分数据，与余下的散点形成对比，达到区分的目的。\n\nplot(Sepal.Length ~ Sepal.Width, data = iris)\npoints(Sepal.Length ~ Sepal.Width, data = iris, \n  col = \"#EA4335\", pch = 16,\n  subset = Species == \"setosa\" & Sepal.Length &gt; 5\n)\n\n\n\n\n\n\n\n图 5.6: 分组\n\n\n\n\n\n\n\n5.1.5 配色\n经过探查，知道数据集 iris 中的 Species 列有三种取值。调用函数 palette() 设置一个超过 3 种颜色的调色板可以实现自定义配色。首先来看看当前调色板的颜色。\n\npalette()\n#&gt; [1] \"black\"   \"#DF536B\" \"#61D04F\" \"#2297E6\" \"#28E2E5\" \"#CD0BBC\"\n#&gt; [7] \"#F5C710\" \"gray62\"\n\n一共是 8 种颜色，效果预览见 图 5.7 。\n\n\n\n\n\n\n\n\n图 5.7: 默认调色板\n\n\n\n\n\n设置新的调色板也是用函数 palette() ，参数 value 设置新的颜色值向量，下面依次是红、蓝、绿、黄四种颜色。\n\npalette(value = c(\"#EA4335\", \"#4285f4\", \"#34A853\", \"#FBBC05\"))\n\n函数 plot() 的调色板默认来自函数 palette() ，经过上面的调整，同一行绘图代码出来不同的效果，即 图 5.5 变成 图 5.8 。\n\nplot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16)\n\n\n\n\n\n\n\n图 5.8: 配色\n\n\n\n\n\n用户也可自定义调色板，先选取一些满意的颜色，然后用函数 colorRampPalette() 生成调色板。\n\njet.colors &lt;- colorRampPalette(c(\"#00007F\", \"blue\", \"#007FFF\", \"cyan\",\n                     \"#7FFF7F\", \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\"))\nfilled.contour(volcano, color.palette = jet.colors)\nLab.palette &lt;- colorRampPalette(c(\"red\", \"orange\", \"blue\"), space = \"Lab\")\nfilled.contour(volcano, color.palette = Lab.palette)\n\n\n\n\n\n\n\n\n\n\n\n(a) Matlab 调色板\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) Lab.palette 调色板\n\n\n\n\n\n\n\n图 5.9: 自定义调色板\n\n\n\n\n看到这个图立马能让人想到 10 年前在学校里用过的 Matlab 里的绘图工具。不同颜色之间的过渡非常糟糕，一点也不平滑，视觉刺激很强，导致图形本身要传递的信息被冲淡了。换了调色板后，整套配色显得柔和多了，不同颜色之间过渡自然，图形中要表达的重点突出。\n\n\n5.1.6 注释\n函数 text() 可以在图上任意位置添加文本或公式。下图在位置 (4,6.5) 处添加红色的文字 flower。\n\nplot(Sepal.Length ~ Sepal.Width, data = iris)\ntext(x = 4, y = 6.5, labels = \"flower\", col = \"#EA4335\")\n\n\n\n\n\n\n\n图 5.10: 注释\n\n\n\n\n\n\n\n5.1.7 图例\n函数 plot() 不会自动添加图例，需要使用函数 legend() 添加图例。\n\nplot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16)\nlegend(x = \"topright\", title = \"Species\",\n  legend = unique(iris$Species), box.col = NA, bg = NA,\n  pch = 16, col = c(\"#EA4335\", \"#4285f4\", \"#34A853\")\n)\n\n\n\n\n\n\n\n图 5.11: 图例\n\n\n\n\n\n图例放置在绘图区域以外，比如右边空区域。此时，通过点和文本构造图例。\n\nop &lt;- par(mar = c(4, 4, 3, 6))\nplot(\n  Sepal.Length ~ Sepal.Width, data = iris, \n  col = Species, pch = 16, main = \"Edgar Anderson's Iris Data\"\n)\ntext(x = 4.7, y = 6.75, labels = \"Species\", pos = 4, offset = .5, xpd = T)\npoints(x = 4.7, y = 6.5, pch = 16, cex = 1, col = \"#EA4335\", xpd = T)\ntext(x = 4.7, y = 6.5, labels = \"setosa\", pos = 4, col = \"#EA4335\", xpd = T)\npoints(x = 4.7, y = 6.3, pch = 16, cex = 1, col = \"#4285f4\", xpd = T)\ntext(x = 4.7, y = 6.3, labels = \"versicolor\", pos = 4, col = \"#4285f4\", xpd = T)\npoints(x = 4.7, y = 6.1, pch = 16, cex = 1, col = \"#34A853\", xpd = T)\ntext(x = 4.7, y = 6.1, labels = \"virginica\", pos = 4, col = \"#34A853\", xpd = T)\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n图 5.12: 图例\n\n\n\n\n\n在函数 plot() 内设置较宽的坐标轴范围，获得一个较宽的绘图区域，再用函数 points() 添加数据点，最后，使用函数 legend() 添加图例。\n\nplot(\n  x = c(2, 6), y = range(iris$Sepal.Length), type = \"n\",\n  xlab = \"Sepal Width\", ylab = \"Sepal Length\",\n  main = \"Edgar Anderson's Iris Data\"\n)\npoints(Sepal.Length ~ Sepal.Width,\n  col = Species, pch = 16, data = iris\n)\nlegend(x = \"right\", title = \"Species\",\n  legend = unique(iris$Species), box.col = NA, bg = NA,\n  pch = 16, col = c(\"#EA4335\", \"#4285f4\", \"#34A853\")\n)\n\n\n\n\n\n\n\n图 5.13: 图例\n\n\n\n\n\n\n\n5.1.8 统计\n添加分组线性回归线。按鸢尾花种类分组，线性回归模型拟合数据，抽取回归系数。首先，使用函数 split() 将数据集 iris 按变量 Species 分组拆分，得到一个列表，每个元素都是数据框。接着，调用函数 lapply() 将函数 lm() 作用到列表的每个元素上，得到一个列表，每个元素都是线性拟合对象。最后，再调函数 lapply() 将函数 coef() 应用到列表的每个元素上，得到回归模型的系数向量。\n\nlapply(\n  lapply(\n    split(iris, ~Species), lm,\n    formula = Sepal.Length ~ Sepal.Width\n  ),\n  coef\n)\n#&gt; $setosa\n#&gt; (Intercept) Sepal.Width \n#&gt;   2.6390012   0.6904897 \n#&gt; \n#&gt; $versicolor\n#&gt; (Intercept) Sepal.Width \n#&gt;   3.5397347   0.8650777 \n#&gt; \n#&gt; $virginica\n#&gt; (Intercept) Sepal.Width \n#&gt;   3.9068365   0.9015345\n\n走到绘图这一步，往往是画什么内容比较清楚，分类数量、调色板都确定下来了。大致来说分 6 步：第一步，实现分组线性回归拟合；第二步，绘制分组散点图；第三步，添加分组回归线；第四步，添加图例并调整图例的位置；第五步，设置图形边界等绘图参数；第六步，添加背景网格线。输入线性拟合对象给函数 abline() 可以直接绘制回归线，不需要从拟合对象中提取回归系数。调用函数 par() 设置图形边界，特别是增加图形右侧边界以容纳图例，再调用函数 legend() 要设置 xpd = TRUE 以允许图例超出绘图区域。\n\n# 分组线性拟合\niris_lm &lt;- lapply(\n  split(iris, ~Species), lm, formula = Sepal.Length ~ Sepal.Width\n)\n# 将分组变量和颜色映射\ncols &lt;- c(\"setosa\" = \"#EA4335\",  \"versicolor\" = \"#4285f4\", \"virginica\" = \"#34A853\")\n# 设置图形边界以容纳标签和图例\nop &lt;- par(mar = c(4, 4, 3, 8))\n# 绘制分组散点图\nplot(\n  Sepal.Length ~ Sepal.Width,\n  data = iris, col = Species, pch = 16,\n  xlab = \"Sepal Width\", ylab = \"Sepal Length\",\n  main = \"Edgar Anderson's Iris Data\"\n)\n# 添加背景参考线\ngrid()\n# 添加回归线\nfor (species in c(\"setosa\", \"versicolor\", \"virginica\")) {\n  abline(iris_lm[[species]], col = cols[species], lwd = 2)\n}\n# 添加图例\nlegend(\n  x = \"right\", title = \"Species\", inset = -0.4, xpd = TRUE,\n  legend = unique(iris$Species), box.col = NA, bg = NA, lty = 1, lwd = 2,\n  pch = 16, col = c(\"#EA4335\", \"#4285f4\", \"#34A853\")\n)\n# 恢复图形参数设置\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n图 5.14: 分组线性回归",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>graphics 入门</span>"
    ]
  },
  {
    "objectID": "visualization-graphics.html#sec-graphics-advanced",
    "href": "visualization-graphics.html#sec-graphics-advanced",
    "title": "5  graphics 入门",
    "section": "5.2 绘图进阶",
    "text": "5.2 绘图进阶\n\n5.2.1 组合图形\n点、线、多边形组合\n\nx &lt;- seq(-10, 10, length = 400)\ny1 &lt;- dnorm(x)\ny2 &lt;- dnorm(x, m = 3)\nop &lt;- par(mar = c(5, 4, 2, 1))\nplot(x, y2,\n  xlim = c(-3, 8), type = \"n\",\n  xlab = quote(Z == frac(mu[1] - mu[2], sigma / sqrt(n))),\n  ylab = \"Density\"\n)\npolygon(c(1.96, 1.96, x[240:400], 10),\n  c(0, dnorm(1.96, m = 3), y2[240:400], 0),\n  col = \"grey80\", lty = 0\n)\nlines(x, y2)\nlines(x, y1)\npolygon(c(-1.96, -1.96, x[161:1], -10),\n  c(0, dnorm(-1.96, m = 0), y1[161:1], 0),\n  col = \"grey30\", lty = 0\n)\npolygon(c(1.96, 1.96, x[240:400], 10),\n  c(0, dnorm(1.96, m = 0), y1[240:400], 0),\n  col = \"grey30\"\n)\nlegend(x = 4.2, y = .4,\n  fill = c(\"grey80\", \"grey30\"),\n  legend = expression(\n    P(abs(Z) &gt; 1.96, H[1]) == 0.85,\n    P(abs(Z) &gt; 1.96, H[0]) == 0.05\n  ), bty = \"n\"\n)\ntext(0, .2, quote(H[0]:~ ~ mu[1] == mu[2]))\ntext(3, .2, quote(H[1]:~ ~ mu[1] == mu[2] + delta))\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n图 5.15: 正态总体下两样本均值之差的检验\n\n\n\n\n\n\n\n5.2.2 多图布局\n布局函数 layout() 和图形参数设置函数 par()\n\ndata(anscombe)\nform &lt;- sprintf(\"y%d ~ x%d\", 1:4, 1:4)\nfit &lt;- lapply(form, lm, data = anscombe)\nop &lt;- par(mfrow = c(2, 2), mgp = c(2, 0.7, 0), \n          mar = c(3, 3, 1, 1) + 0.1, oma = c(0, 0, 2, 0))\nfor (i in 1:4) {\n  plot(as.formula(form[i]),\n    data = anscombe, col = \"black\",\n    pch = 20, xlim = c(3, 19), ylim = c(3, 13),\n    xlab = as.expression(substitute(x[i], list(i = i))),\n    ylab = as.expression(substitute(y[i], list(i = i))),\n    family = \"sans\"\n  )\n  abline(fit[[i]], col = \"black\")\n  text(\n    x = 7, y = 12, family = \"sans\",\n    labels = bquote(R^2 == .(round(summary(fit[[i]])$r.squared, 3)))\n  )\n}\nmtext(\"数据集的四重奏\", outer = TRUE)\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n图 5.16: 数据可视化很重要",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>graphics 入门</span>"
    ]
  },
  {
    "objectID": "visualization-graphics.html#sec-graphics-choose",
    "href": "visualization-graphics.html#sec-graphics-choose",
    "title": "5  graphics 入门",
    "section": "5.3 图形选择",
    "text": "5.3 图形选择\n以不同的二维或三维图形可视化同一份多元数据。颜色图、透视图、等值线图和填充等值线图存在某种相似性，又有区别。\n\n5.3.1 颜色图\n\\[\nf(x,y) =\n\\begin{cases}\n\\frac{\\sin(\\sqrt{x^2 + y^2})}{\\sqrt{x^2 + y^2}}, & (x,y) \\neq (0,0)\\\\\n1, & (x,y) = (0,0)\n\\end{cases}\n\\]\n\ny &lt;- x &lt;- seq(from = -8, to = 8, length.out = 51)\nz &lt;- outer(x, y, FUN = function(x, y) sin(sqrt(x^2 + y^2)) / sqrt(x^2 + y^2))\nz[26, 26] &lt;- 1\n\n将绘图区域划分成网格，每个小网格对应一个颜色值。函数 image() 绘制颜色图\n\nimage(x = x, y = y, z = z, xlab = \"$x$\", ylab = \"$y$\")\n\n\n\n\n\n\n\n图 5.17: 颜色图\n\n\n\n\n\n\n\n5.3.2 透视图\n函数 persp() 绘制透视图\n\nop &lt;- par(mar = c(0, 1, 2, 1))\npersp(\n  x = x, y = y, z = z, main = \"二维函数的透视图\",\n  theta = 30, phi = 30, expand = 0.5, col = \"lightblue\",\n  xlab = \"$x$\", ylab = \"$y$\", zlab = \"$f(x,y)$\"\n)\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n图 5.18: 透视图\n\n\n\n\n\n\n\n5.3.3 等值线图\n地理上，常用等高线图描述地形，等高线图和等值线图其实是一个意思。函数 contour() 绘制等值线图。\n\ncontour(x = x, y = y, z = z, xlab = \"$x$\", ylab = \"$y$\")\n\n\n\n\n\n\n\n图 5.19: 等值线图\n\n\n\n\n\n\n\n5.3.4 填充等值线图\n函数 filled.contour() 绘制填充等值线图。\n\nfilled.contour(\n  x = x, y = y, z = z, asp = 1,\n  color.palette = hcl.colors,\n  plot.title = {\n    title(\n      main = \"二维函数的填充等值线图\",\n      xlab = \"$x$\", ylab = \"$y$\"\n    )\n  },\n  plot.axes = {\n    grid(col = \"gray\")\n    axis(1, at = 2 * -4:4, labels = 2 * -4:4)\n    axis(2, at = 2 * -4:4, labels = 2 * -4:4)\n    points(0, 0, col = \"blue\", pch = 16)\n  },\n  key.axes = {\n    axis(4, seq(-0.2, 1, length.out = 9))\n  }\n)\n\n\n\n\n\n\n\n图 5.20: 填充等值线图",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>graphics 入门</span>"
    ]
  },
  {
    "objectID": "visualization-graphics.html#sec-graphics-summary",
    "href": "visualization-graphics.html#sec-graphics-summary",
    "title": "5  graphics 入门",
    "section": "5.4 总结",
    "text": "5.4 总结\n\n5.4.1 tinyplot 包\ntinyplot 包扩展 Base R 函数 plot() 的功能，在公式语法方面和 lattice 包很接近。另一个值得一提的 R 包是 basetheme ，用来设置 Base R 绘图主题。\n\nlibrary(tinyplot)\ntinyplot(Sepal.Length ~ Sepal.Width | Species, data = iris, \n      palette = \"Tableau 10\", pch = 16)\n\n\n\n\n\n\n\n图 5.21: tinyplot 包绘制分组散点图\n\n\n\n\n\n或者使用参数 by 指定分组变量，效果和上图一样。\n\nwith(iris, {\n  tinyplot(y = Sepal.Length, x = Sepal.Width, by = Species,\n      palette = \"Tableau 10\", pch = 16)\n})\n\n还可以使用参数 legend 调整图例的位置，比如放置在绘图区域下方。\n\nop &lt;- par(mar = c(5, 4, .5, .5))\ntinyplot(Sepal.Length ~ Sepal.Width | Species,\n  data = iris, palette = \"Tableau 10\", pch = 16,\n  legend = legend(\"bottom!\", title = \"Species of iris\", bty = \"o\")\n)\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n图 5.22: tinyplot 包调整图例位置\n\n\n\n\n\n还可以绘制其它类型的图形，如分组密度曲线图、分面散点图等。\ntinyplot(\n  ~ Petal.Length | Species, data = iris,\n  type = \"density\",\n  fill = \"by\", # 分组填充\n  grid = TRUE, # 背景网格\n  palette = \"Tableau 10\"\n)\n\ntinyplot(\n  Petal.Width ~ Petal.Length | Sepal.Length, data = iris,\n  facet = ~ Species,  # 分面\n  grid = TRUE, pch = 19, frame = TRUE,\n  palette = terrain.colors # 生成调色板的函数指定配色\n)\n\n\n\n\n\n\n\n\n\n\n\n(a) 分组密度曲线图\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) 分面散点图\n\n\n\n\n\n\n\n图 5.23: tinyplot 包的分组和分面功能\n\n\n\n\n\n5.4.2 plot3D 包\n虽然不提倡大量使用三维图形，但如何绘制三维图形却是生生不息的命题，以下仅是 R 语言社区的冰山一角。\n\nplotrix (Lemon 2006) 一个坐落于 R 的红灯区的 R 包。基于 Base R 各类绘图函数。\nscatterplot3d (Ligges 和 Mächler 2003) 基于 Base R 绘制三维散点图。\nmisc3d (Feng 和 Tierney 2008) 绘制三维图形的杂项，支持通过 Base R、 tcltk 包和 rgl 包渲染图形。\nplot3D (Soetaert 2021) 依赖 misc3d 包，加强 Base R 在制作三维图形方面的能力。\n\n举个比较新颖的一个例子，plot3D 包的函数 image2D() 绘制二维颜色图，细看又和 image() 函数不同，渲染出来的图形有三维的立体感。归根结底，很多时候束缚住自己的不是工具，而是视野和思维。以奥克兰 Maunga Whau 火山地形数据 volcano 为例。\nlibrary(plot3D)\nimage2D(volcano,\n  shade = 0.2, rasterImage = TRUE, asp = 0.7,\n  xlab = \"南北方向\", ylab = \"东西方向\",\n  main = \"奥克兰 Maunga Whau 地形图\", clab = \"高度\",\n  contour = FALSE, col = hcl.colors(100),\n  colkey = list(\n    at = 90 + 20 * 0:5, labels = 90 + 20 * 0:5,\n    length = 1, width = 1\n  )\n)\nop &lt;- par(mar = c(1, 1.5, 0, 0))\npersp3D(\n  x = 1:87, y = 1:61, z = volcano, col = hcl.colors(100),\n  ticktype = \"detailed\", colkey = FALSE, expand = 1, \n  phi = 35, theta = 125, bty = \"b2\", shade = TRUE,\n  ltheta = 100, lphi = 45,\n  xlab = \"\\n南北方向\", ylab = \"\\n东西方向\", zlab = \"\\n高度\"\n)\non.exit(par(op), add = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n(a) 函数 image2D() 二维颜色图\n\n\n\n\n\n\n\n\n\n\n\n\n\n(b) 函数 persp3D() 三维透视图\n\n\n\n\n\n\n\n图 5.24: 奥克兰火山地形图\n\n\n\n值得一提，Python 社区的绘图模块 matplotlib 同样具有强大的绘图能力，三维图形也不在话下。不过，不同的绘图系统所采用的透视法不同，如下图所示。\n\n\n代码\nfrom matplotlib import cm\nfrom matplotlib.colors import LightSource\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# 设置 PGF 后端渲染图形\nimport matplotlib as mpl\nmpl.use(\"pgf\")\n# XeLaTeX 编译图形\nplt.rcParams.update({\n    \"text.usetex\": True,\n    \"pgf.texsystem\": \"xelatex\",\n    \"pgf.rcfonts\": False,    # don't setup fonts from rc parameters\n    \"pgf.preamble\": \"\\n\".join([\n            r\"\\usepackage[fontset=fandol,UTF8]{ctex}\",\n        ]),\n})\n# 读取数据\nvolcano = pd.read_csv(\"data/volcano.csv\", header=None)\n# DataFrame 转 Array\nz = volcano.to_numpy().transpose()\n# 数据行、列数\nncols, nrows = z.shape\n# 线性序列\nx = np.linspace(0, 86, nrows)\ny = np.linspace(0, 60, ncols)\n# 类似 R 语言函数 expand.grid()\nxv, yv = np.meshgrid(x, y)\n# 设置主题\nfig, ax = plt.subplots(subplot_kw=dict(projection=\"3d\"))\n# 观察视角\nax.view_init(azim=30, elev=30)\n# 设置坐标轴标签\nax.set_xlabel(r\"南北方向\", rotation=45)\nax.set_ylabel(r\"东西方向\", rotation=-15)\nax.set_zlabel(r\"高度\", rotation=90)\n# 去掉多余的边空\nfig.set_tight_layout(True)\n# 光源照射的角度\nls = LightSource(270, 45)\n# 自定义调色板\nrgb = ls.shade(z, cmap=cm.viridis, vert_exag=0.1, blend_mode=\"soft\")\n# 三维透视图\nsurf = ax.plot_surface(\n    xv, yv, z, rstride=1, cstride=1, facecolors=rgb,\n    linewidth=0, antialiased=False, shade=False\n)\n# 渲染\nplt.show()\n\n\n\n\n\n\n\n\n图 5.25: matplotlib 绘制三维透视图\n\n\n\n\n\n\n\n\n\nFeng, Dai, 和 Luke Tierney. 2008. 《Computing and Displaying Isosurfaces in R》. Journal of Statistical Software 28 (1). https://doi.org/10.18637/jss.v028.i01.\n\n\nLemon, Jim. 2006. 《plotrix: a package in the red light district of R》. R-News 6 (4): 8–12.\n\n\nLigges, Uwe, 和 Martin Mächler. 2003. 《scatterplot3d: An R Package for Visualizing Multivariate Data》. Journal of Statistical Software 8 (11): 1–20. https://doi.org/10.18637/jss.v008.i11.\n\n\nSoetaert, Karline. 2021. plot3D: Plotting Multi-Dimensional Data. https://CRAN.R-project.org/package=plot3D.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>graphics 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html",
    "href": "visualization-tikz.html",
    "title": "6  TikZ 入门",
    "section": "",
    "text": "6.1 standalone 宏包\n有一些示意图是用来表达数据探索的思路的，而不是直接探索数据的工具。比如象限图、甘特图、思维导图、网络图等，可以用 TikZ 绘制这类图形来阐述分析维度、思路、结构等。当然，绘制这类示意图不仅限于 TikZ，还有很多其它工具，如 LaTeX 社区的 PSTricks，JavaScripts 社区的 Mermaid，软件 Graphviz 等。\n最常见的 LaTeX 文档类有 article、report、beamer、book，分别对应文章、报告、演示和书籍。有的宏包在此基础上扩展功能，比如 ctex 宏包提供中文支持，有四个文档类 ctexart、 ctexrep 、ctexbeamer 和 ctexbook 与之对应起来。standalone 宏包提供 standalone 文类主要用于绘制独立的图片，默认情况下，文档四周多余的空白部分会被裁剪掉。在 LaTeX 环境中，推荐使用 TikZ 来绘图。standalone 文类可与 tikz 宏包一起使用，生成一张张由 TikZ 代码绘制的独立图片。下面举个简单的例子，用 TikZ 绘制两个坐标轴。\nstandalone 文类启用 tikz 选项来绘图，选项 border=1mm 表示图片四周的边空保留 1 毫米，文档内容放在 document 环境里，TikZ 绘图代码放在 tikzpicture 环境中，命令 \\draw 负责绘制具体的图形，用 XeLaTeX 编译，效果如 图 6.1 所示。\n图 6.1: TikZ 绘图\nstandalone 文类有很多选项，下面介绍 4 个选项的常用内容。\nstandalone 文类是支持 PSTricks 绘图的，下面在直角坐标系中绘制一个带阴影效果的圆，示例代码如下：\nstandalone 文类的选项 pstricks 表示启用 PSTricks 绘图环境，加载 pst-plot 宏包提供额外的命令，PSTricks 是基于 PostScript 语言的，每一个绘图命令都是 \\ps 开头的，比如 \\psset 、\\psaxes、\\pscircle 等。\\begin{pspicture} 和 \\end{pspicture} 之间是 PSTricks 绘图代码，\\begin{pspicture} 之后的 (0,0)(11,11) 是左下和右上角两个坐标，定义了一个绘图区域。和 TikZ 绘图代码一样，也用 XeLaTeX 编译，效果如 图 6.2 所示。\n图 6.2: PSTricks 绘图\n可以在 Quarto 和 R Markdown 文档中插入 PSTricks 绘图代码，使用 knitr 包的 tikz 引擎绘图。只要修改模版文件 tikz2pdf.tex ，移除一行 \\usetikzlibrary{matrix} ，不再加载 tikz 宏包及其 matrix 库。TIKZ_CLASSOPTION 不再仅限于 TikZ ，而是 standalone 文类的选项，相应地，EXTRA_TIKZ_PREAMBLE_CODE 变成一般的 LaTeX 文档的导言区，TIKZ_CODE 可以是 PSTricks 代码。新的模版文件 tikz2pdf.tex 如下：\n上 图 6.2 即是由 knitr 包的 tikz 引擎渲染出来的。在代码块选项 engine-opts 中，传递一个列表，分别包含 classoption（standalone 文类选项）、 extra.preamble（导言区）、 template （TikZ 模版文件）三块内容。生成 图 6.2 的 engine-opts 设置如下：\n其它选项和更多详细介绍见 standalone 宏包帮助文档。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-tikz-standalone",
    "href": "visualization-tikz.html#sec-tikz-standalone",
    "title": "6  TikZ 入门",
    "section": "",
    "text": "\\documentclass[tikz,border=1mm]{standalone}\n\\begin{document}\n\\begin{tikzpicture}\n\\draw[&lt;-&gt;] (6,0) -- (0,0) node[left]{O} -- (0,6);\n\\end{tikzpicture}\n\\end{document}\n\n\n\n\nclass 选项指定文类环境，默认值为 article，表示在 article 文类中绘图。其它选项还有 beamer ，表示在演示环境中绘图。在不同的文类中，图片渲染出来的效果不同。\ntikz=true|false 选项是否启用 TikZ 绘图，默认值是 false 。当显式地在 standalone 文类中启用 tikz 选项，就表示用 TikZ 绘图，将自动加载 tikz 宏包。与之类似的选项 pstricks=true|false ，表示是否启用 PSTricks 绘图，PSTricks 是LaTeX 社区中一套语法不同于 TikZ 的绘图工具。\ncrop=true|false 选项是否裁剪变空，默认值是 true ，表示绘图区域以外的部分都裁剪掉。与之相关的另一个选项是 border ，可以更加精细地控制图片四周的各个边空。\nborder 选项指定边空大小，默认值是 0，表示无边空。当 crop=true 时，再指定 border 选项，比如 border=1mm 表示图片四周的边空保留 1 毫米。图片四周的边空大小可以按照左、下、右、上的顺序指定，比如 border={5mm 6mm 0mm -2mm} 表示图片左边空 5 毫米、下边空 6 毫米、右边空 0 毫米、上边空负 2 毫米。\n\n\n\\documentclass[pstricks,border={5mm 6mm 0mm -2mm}]{standalone}\n\\usepackage{pst-plot}\n\\begin{document}\n\\psset{xunit=0.15in, yunit=0.15in}\n\\begin{pspicture}(0,0)(11,11)\n\\psaxes[Dx=4,Dy=4, subticks=4]{-&gt;}(0,0)(0,0)(10,10)[$x$,0][$y$,0]\n\\pscircle[runit=0.15in, fillcolor=orange!50, fillstyle=solid,shadow=true](5,5){3}\n\\end{pspicture}\n\\end{document}\n\n\n\n\\documentclass[\n%% TIKZ_CLASSOPTION %%\n]{standalone}\n%% EXTRA_TIKZ_PREAMBLE_CODE %%\n\\begin{document}\n%% TIKZ_CODE %%\n\\end{document}\n\nlist(\n  classoption = \"pstricks,border={5mm 6mm 0mm -2mm}\",\n  extra.preamble = \"\\\\usepackage{pst-plot}\",\n  template = \"code/tikz2pdf.tex\"\n)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-tikz-pgf",
    "href": "visualization-tikz.html#sec-tikz-pgf",
    "title": "6  TikZ 入门",
    "section": "6.2 PGF 宏包",
    "text": "6.2 PGF 宏包\nPGF 宏包提供一套易于学习和使用的绘图语法 TikZ，TikZ 是 TikZ ist kein Zeichenprogramm 的简写，命名有 Linux 哲学意味。下面比较详细的介绍 LaTeX 宏包 PGF 绘制曲线图的过程。\n\n\\begin{tikzpicture}\n\\draw[&lt;-&gt;] (6,0) -- (0,0) node[left]{O} -- (0,6);\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.3: PGF 绘制曲线图\n\n\n\n\n\n首先，\\draw 命令绘制带箭头的坐标轴，坐标轴的范围 \\([0,6]\\times[0,6]\\) 。坐标轴是由线构成的，线有虚线、实线，也有宽度和颜色，虚线还有不同类型，这些都是可以设置的参数，比如将 \\draw[&lt;-&gt;] 改为 \\draw[color=red,&lt;-&gt;] ，坐标轴颜色设置为红色。\n\n\\begin{tikzpicture}\n\\draw[&lt;-&gt;] (6,0) node[below]{$q$} -- (0,0) node[left]{O} -- (0,6) node[left]{$V(q)$};\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.4: PGF 绘制曲线图\n\n\n\n\n\n然后，在位置 (6,0) 和 (0,6) 分别添加节点 node[below]{$q$} 和 node[left]{$V(q)$} 。node 表示节点，节点的标签内容在大括号内，标签的位置在中括号内，这里，below 表示在位置 (6,0) 的下方。\n\n\\begin{tikzpicture}\n\\draw[&lt;-&gt;] (6,0) node[below]{$q$} -- (0,0) node[left]{O} -- (0,6) node[left]{$V(q)$};\n\\draw[very thick] (0,0) to [out=90,in=145] (5,4.5);\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.5: PGF 绘制曲线图\n\n\n\n\n\n最后，从点 (0,0) 至点 (5,4.5) 绘制一条非常粗的曲线。曲线从点 (0,0) 出去的时候，是以 90 度垂直水平轴的方向出去的，到点 (5,4.5) 是以 145 度方向进入的。角度是按照逆时针方向计算的。线的粗细、方向都是由参数决定的。\n在这里，TikZ 是用来绘制示意图的，不需要知道每个命令的每个参数的取值有哪些。关键是知道自己想要画什么，其实，可以用铅笔在纸上以最快的方式绘制草图，了解每个绘图元素，然后查找 PGF 帮助手册，找到对应的命令和参数，将草图工整地誊抄一遍。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-tikz-pgfplots",
    "href": "visualization-tikz.html#sec-tikz-pgfplots",
    "title": "6  TikZ 入门",
    "section": "6.3 三维图",
    "text": "6.3 三维图\n顾名思义，pgfplots 宏包基于 PGF 的，用它来绘制三维图形是非常方便的。\n\\documentclass[tikz]{standalone}\n\\usepackage{pgfplots}\n\\pgfplotsset{width=7cm,compat=1.17}\n\\begin{document}\n%% TikZ 代码%%\n\\end{document}\n首先加载 pgfplots 宏包，设置全局的绘图参数，width=7cm 表示绘图页面宽度，compat=1.17 表示使用 pgfplots 的版本。\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    hide axis,\n    colormap/viridis\n]\n\\addplot3[\n    mesh,\n    samples=50,\n    domain=-8:8\n]\n{ sin(deg(sqrt(x^2+y^2)))/sqrt(x^2+y^2) };\n\\addlegendentry{$\\frac{\\sin(r)}{r}$}\n\\end{axis}\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.6: TikZ 绘制三维图 viridis 调色板\n\n\n\n\n\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    hide axis,\n    colormap/jet\n]\n\\addplot3[\n    mesh,\n    samples=50,\n    domain=-8:8\n]\n{ sin(deg(sqrt(x^2+y^2)))/sqrt(x^2+y^2) };\n\\addlegendentry{$\\frac{\\sin(r)}{r}$}\n\\end{axis}\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.7: TikZ 绘制三维图 jet 调色板\n\n\n\n\n\n\n\\begin{tikzpicture}\n\\begin{axis}[\n    hide axis,\n    colormap/cool,\n    colorbar sampled,\n    domain=-8:8\n]\n\\addplot3[\n    contour filled={\n      number=20,\n    },\n    ]{sin(deg(sqrt(x^2+y^2)))/sqrt(x^2+y^2)};\n\\addlegendentry{$\\frac{\\sin(r)}{r}$}\n\\end{axis}\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.8: TikZ 绘制三维图 cool 调色板\n\n\n\n\n\n\n\\begin{axis} 和 \\end{axis} 环境有很多配置选项，参数值 [hide axis, colormap/viridis] 中 hide axis 表示隐藏坐标轴，colormap/viridis 表示三维图形的调色板采用 viridis 。colormap 支持很多不同的调色板，上面列举了两个。其实还可以增加不同的选项，比如添加选项 colorbar sampled 会生成一个颜色条，还可以添加选项 colorbar horizontal 来水平放置颜色条。\n可以在导言区加载 \\usetikzlibrary{pgfplots.colorbrewer} 导入 ColorBrewer 系列调色板，方便后续绘图时调用。作用与 R 语言中的 RColorBrewer 包类似，调色板名称略有不同，前者 PuBu-9 对应后者 PuBu 。\n\\addplot3 命令绘制函数 sin(deg(sqrt(x^2+y^2)))/sqrt(x^2+y^2) 的三维图像，即函数 \\(f(x,y)=\\frac{\\sin(\\sqrt{x^2 + y^2})}{\\sqrt{x^2 + y^2}}\\) 的三维图像。参数值 [mesh, samples=50, domain=-8:8] 中 mesh 表示三维图形是网格状，其它可选值还有曲面图 surf 、填充等值线图 contour filled 等，samples=50 表示网格密度是 50，domain=-8:8 表示横纵坐标的范围都是 \\([-8,8]\\) 。\n\\addlegendentry 添加图例，图例标签是 \\(\\frac{\\sin(r)}{r}\\) ，颜色会随着调色板变化。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-tikz-network",
    "href": "visualization-tikz.html#sec-tikz-network",
    "title": "6  TikZ 入门",
    "section": "6.4 网络图",
    "text": "6.4 网络图\n绘制网络图用 tikz-network 宏包，也是 PGF 的一个扩展包。图结构是根据顶点和边来定义的，图的复杂程度也可以用顶点和边的规模来衡量。图描述一种非线性的关系，有自己的一套语言，定义顶点 \\Vertex 和边 \\Edge 的两个命令是最基础的。下面绘制柯尼斯堡七桥问题对应的图。\n\\documentclass[tikz]{standalone}\n\\usepackage{tikz-network}\n\\begin{document}\n%% TikZ 代码%%\n\\end{document}\n\n\\begin{tikzpicture}\n\\Vertex[IdAsLabel, x=5, color=gray, size=1, fontsize=\\large]{A}\n\\Vertex[IdAsLabel, x=10, color=gray, size=1, fontsize=\\large]{B}\n\\Vertex[IdAsLabel, x=15, color=gray, size=1, fontsize=\\large]{C}\n\\Vertex[IdAsLabel, x=10, y=6, color=gray, size=1, fontsize=\\large]{D}\n\n\\Edge[label=2, bend=45, fontscale=2](A)(B)\n\\Edge[label=6, bend=30, fontscale=2](A)(D)\n\\Edge[label=3, bend=45, fontscale=2](B)(A)\n\\Edge[label=5, bend=45, fontscale=2](B)(C)\n\\Edge[label=4, bend=45, fontscale=2](C)(B)\n\\Edge[label=7, bend=30, fontscale=2](D)(C)\n\\Edge[label=1, fontscale=2](D)(B)\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.9: 柯尼斯堡七桥\n\n\n\n\n\n\n\\Vertex 命令定义顶点（含标签），参数 IdAsLabel 表示顶点 ID 作为标签，参数 x 和 y 表示坐标位置，参数 color 表示顶点的填充色，参数 size 表示顶点的大小，参数 fontsize 表示标签文本的大小。\n\\Edge 命令在已有顶点的基础上定义边，(A)(B) 表示从顶点 A 到顶点 B 有一条边，参数label 表示边上的标签文本，参数 bend 表示边的弧度，参数 fontscale 表示标签文本的大小。\n\n不难看出，无论是顶点还是边，都有颜色、大小、标签等参数，尽管参数名称有所不同。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-tikz-mindmap",
    "href": "visualization-tikz.html#sec-tikz-mindmap",
    "title": "6  TikZ 入门",
    "section": "6.5 思维导图",
    "text": "6.5 思维导图\n思维导图是非常常见的一种树状图，用于梳理层次关系。TikZ 绘制思维导图是通过 mindmap 库实现的，它是 PGF 的一个库。如 图 6.10 所示，看着和脑神经网络有某种相似性，所以，有时候，思维导图也叫脑图。\n\\documentclass[tikz,svgnames]{standalone}\n\\usepackage[fontset=fandol]{ctex}\n\\usetikzlibrary{mindmap}\n\\begin{document}\n%% TikZ 代码%%\n\\end{document}\n\n\\begin{tikzpicture}[\n    mindmap, every node/.style=concept, concept color=orange, text=white,\n    level 1/.append style={level distance=5cm, sibling angle=60, font=\\LARGE},\n    level 2/.append style={level distance=3.5cm, sibling angle=45, font=\\large}\n  ]\n\n  \\node{\\huge{\\textsf{数据分析}}} [clockwise from=60]\n  child [concept color=DarkMagenta] {\n      node {\\textit{数据准备}} [clockwise from=120]\n      child { node {数据对象}}\n      child { node {数据获取}}\n      child { node {数据清洗}}\n      child { node {数据操作}}\n    }\n  child [concept color=DarkBlue] {\n      node {\\textit{数据探索}} [clockwise from=30]\n      child { node {ggplot2 入门}}\n      child { node {基础图形}}\n      child { node {统计图形}}\n    }\n  child [concept color=Brown] {\n      node {\\textit{数据交流}} [clockwise from=-30]\n      child { node {交互图形}}\n      child { node {交互表格}}\n      child { node {交互应用}}\n    }\n  child [concept color=teal] {\n      node {\\textit{统计分析}} [clockwise from=-75]\n      child { node {统计检验}}\n      child { node {回归分析}}\n      child { node {功效分析}}\n    }\n  child [concept color=purple] {\n      node {\\textit{数据建模}} [clockwise from=-120]\n      child { node {网络分析}}\n      child { node {文本分析}}\n      child { node {时序分析}}\n    }\n  child [concept color=DarkGreen] {\n      node {\\textit{优化建模}} [clockwise from=180]\n      child { node {统计计算}}\n      child { node {数值优化}}\n      child { node {优化问题}}\n    };\n\\end{tikzpicture}\n\n\n\n\n\n\n\n图 6.10: TikZ 绘制思维导图\n\n\n\n\n\n根节点视为一层，则该思维导图有三层。不同的颜色和字体来区分不同的层次或分类，数据分析划分为不同的部分，每个部分有若干章。根节点字体为黑体、第二、三级节点分别为楷体、宋体。\n\\node{\\huge{\\textsf{数据科学}}} [clockwise from=60]\n定义根节点，节点的文本设置为黑体，大小设置为 \\huge 。由根节点向外辐射生成 6 个子节点，每隔 60 度设置一个子节点。\n  child [concept color=DarkMagenta] {\n      node {\\textit{数据准备}} [clockwise from=120]\n      child { node {数据对象}}\n      child { node {数据获取}}\n      child { node {数据清洗}}\n      child { node {数据操作}}\n    }\n第一个子节点，颜色为饱和的紫色 DarkMagenta，二级子节点为「数据准备」，三级子节点有 4 个，逆时针 120 度的位置设置第一个三级子节点「数据对象」，然后顺时针往下，依次是「数据获取」、「数据清洗」和「数据操作」。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-smart-diagram",
    "href": "visualization-tikz.html#sec-smart-diagram",
    "title": "6  TikZ 入门",
    "section": "6.6 SmartArt 图",
    "text": "6.6 SmartArt 图\nOffice 办公软件中有一个 SmartArt 绘图模块，专门用来绘制各类示意图。LaTeX 宏包 smartdiagram 基于 TikZ 定制了一套风格类似的绘图库。 smartdiagram 宏包的主要绘图命令是 \\smartdiagram[参数值] ，设置不同的参数值可以绘制不同的图形，如气泡图 bubble diagram 和描述图 descriptive diagram 等。\n\n\\smartdiagram[bubble diagram]{\n  Pandoc,\n  编程语言~\\\\ (Python\\\\R/Julia\\\\JavaScript), \n  编译引擎~\\\\ (Jupyter\\\\Knitr\\\\Observable), \n  扩展Pandoc~\\\\ (交叉引用\\\\悬浮引用\\\\布局面板), \n  文档项目~\\\\ (批量渲染\\\\共享配置),\n  扩展接口~\\\\ (RStudio\\\\VS Code\\\\JupyterLab) \n}\n\n\n\n\n\n\n\n图 6.11: 气泡图\n\n\n\n\n\n\n\\smartdiagram[descriptive diagram]{\n  {编程语言, {Python、R、Julia、JavaScript}}, \n  {编译引擎, {Jupyter、Knitr、Observable}}, \n  {扩展Pandoc, {交叉引用、悬浮引用、布局面板}}, \n  {文档项目, {批量渲染、共享配置}},\n  {扩展接口, {RStudio、VS Code、JupyterLab}},\n}\n\n\n\n\n\n\n\n图 6.12: 描述图",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-tikz.html#sec-tikz-with-r",
    "href": "visualization-tikz.html#sec-tikz-with-r",
    "title": "6  TikZ 入门",
    "section": "6.7 TikZ 与 R",
    "text": "6.7 TikZ 与 R\nTikZ 绘图的优势有很多，语法简单、易于上手、功能强大、资源丰富、成熟稳定等，可以说几乎是集所有优点于一身。正因如此，knitr 包和 tikzDevice 包将其引入 R 语言社区中。knitr 包的 tikz 引擎是用来编译 TikZ 代码的，默认使用的是 standalone 文类。\nR 语言绘图遇到公式时，略显不足，而排版公式是 LaTeX 的优势。正因为有所不足，所以我也不会纠结于工具层面的东西，什么好用用什么！三维 图 6.6 是用 LaTeX 里的优秀绘图工具 TikZ 制作的，细心的读者会发现本书多次用到这个工具。\n众所周知，Donald Knuth 十年磨一剑，开发了 TeX 排版系统，就是解决排版数学公式的痛点。如 图 6.13 所示，因图形中包含数学公式和符号，为了获得原汁原味的渲染效果，在使用 Base R 绘图的过程中通过 tikzDevice 包引入了 LaTeX 中的 TikZ 绘图引擎。\n\nopar &lt;- par(mgp = c(2, 0.7, 0), mar = c(4, 3, 4, 1) + 0.1, no.readonly = TRUE)\nset.seed(2021)\nx &lt;- rnorm(10)\ny &lt;- x + rnorm(5, sd = 0.25)\nlab &lt;- sample(\n  x = paste0(\"$\\\\mathcal{\", LETTERS, \"}$\"),\n  size = 10, replace = FALSE\n)\nmodel &lt;- lm(y ~ x)\nrsq &lt;- summary(model)$r.squared\nrsq &lt;- signif(rsq, 4)\nplot(x, y,\n  main = \"你好 \\\\LaTeX!\", # 引入 7 号文本字体\n  sub = \"$\\\\mathcal{N}(x;\\\\mu,\\\\Sigma)$\",\n  xlab = \"$x$\", ylab = \"$y$\", type = \"n\"\n)\ntext(x = x, y = y, labels = lab)\nabline(model, col = \"black\")\n# 引入 7 号数学字体\nmtext(paste(\"线性模型: $\\\\mathsf{R}^{2}=\", rsq, \"$\"), line = 0.5)\nlegend(\"bottomright\",\n  legend = paste0(\n    \"$y = \", round(coef(model)[2], 3), \"x +\",\n    round(coef(model)[1], 3), \"$\"\n  ),\n  bty = \"n\"\n)\non.exit(par(opar), add = TRUE)\n\n\n\n\n\n\n\n图 6.13: 简单线性模型\n\n\n\n\n\n图 6.14 是贝塞尔函数 \\(\\mathcal{K}_{\\kappa}(u)\\) 在区间 \\((10^{-8}, 10^2)\\) 和 \\((0, 4)\\) 上的图像。其中，图 6.14 (a) 是区间 \\((10^{-8}, 10^2)\\) 上的贝塞尔函数 \\(\\mathcal{K}_{\\kappa}(u)\\)， 图 6.14 (b) 是区间 \\((0, 4)\\) 上的贝塞尔函数 \\(\\mathcal{K}_{\\kappa}(u)\\) 。\nx0 &lt;- 2^(-20:10)\nnus &lt;- c(2:5, 10, 20)\nx &lt;- seq(0, 4, length.out = 501)\n\nplot(x0, x0^-8,\n  frame.plot = TRUE, # 添加绘图框\n  log = \"xy\",    # x 和 y 轴都取对数尺度\n  axes = FALSE,  # 去掉坐标轴\n  xlab = \"$u$\", ylab = \"$\\\\mathcal{K}_{\\\\kappa}(u)$\", # 设置坐标轴标签\n  type = \"n\", # 清除绘图区域的内容\n  ann = TRUE, # 添加标题 x和y轴标签\n  panel.first = grid() # 添加背景参考线\n)\n\naxis(1,\n  at = 10^(-8 + 2 * 0:5),\n  labels = paste0(\"$\\\\mathsf{10^{\", -8 + 2 * 0:5, \"}}$\")\n)\naxis(2,\n  at = 10^(-8 + 16 * 0:4),\n  labels = paste0(\"$\\\\mathsf{10^{\", -8 + 16 * 0:4, \"}}$\"), las = 1\n)\n\nfor (i in seq(length(nus))) {\n  lines(x0, besselK(x0, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2)\n}\nlegend(\"topright\",\n  legend = paste0(\"$\\\\kappa=\", rev(nus), \"$\"),\n  col = hcl.colors(9, rev = TRUE), lwd = 2, cex = 1\n)\n\nx &lt;- seq(0, 4, length.out = 501)\nx &lt;- x[x &gt; 0]\nplot(x, x,\n  frame.plot = TRUE, ylim = c(1e+0, 1e+20), log = \"y\",\n  xlab = \"$u$\", ylab = \"$\\\\mathcal{K}_{\\\\kappa}(u)$\",\n  type = \"n\", yaxt = \"n\", ann = TRUE, panel.first = grid()\n)\naxis(2,\n  at = c(1e+0, 1e+05, 1e+10, 1e+15, 1e+20),\n  labels = paste0(\"$\\\\mathsf{10^{\", 5 * 0:4, \"}}$\"), las = 1\n)\n\nfor (i in seq(length(nus))) {\n  lines(x, besselK(x, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2)\n}\nlegend(\"topright\",\n  legend = paste0(\"$\\\\kappa=\", rev(nus), \"$\"),\n  col = hcl.colors(9, rev = TRUE), lwd = 2, cex = 1\n)\n\n\n\n\n\n\n\n\n\n\n\n(a) 区间 \\((10^{-8}, 10^2)\\) 上的贝塞尔函数\n\n\n\n\n\n\n\n\n\n\n\n(b) 区间 \\((0, 4)\\) 上的贝塞尔函数\n\n\n\n\n\n\n\n图 6.14: 贝塞尔函数图像",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>TikZ 入门</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html",
    "href": "visualization-practice.html",
    "title": "7  探索实践",
    "section": "",
    "text": "7.1 分析老忠实间歇泉喷发规律\n图 7.1 展示美国怀俄明州黄石国家公园老忠实间歇泉喷发规律，横轴表示喷发持续时间（以分钟计），纵轴表示等待时间（以分钟计），点的亮暗程度（白到黑）代表附近点密度的高低，亮度值通过二维核密度估计方法得到，具体实现借助了 KernSmooth (Wand 和 Jones 1995) 包提供的 bkde2D() 函数，设置了喷发时间的窗宽为 0.7 分钟，等待时间的窗宽为 7分钟。不难看出，每等待 55 分钟左右间歇泉喷发约 2 分钟，或者每等待 80 分钟左右间歇泉喷发 4.5 约分钟，非常守时，表现得很老实，故而得名。说实话，二维核密度估计在这里有点大材小用了，因为数据点比较少，肉眼也能分辨出来哪里聚集的点多，哪里聚集的点少。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-faithful",
    "href": "visualization-practice.html#sec-faithful",
    "title": "7  探索实践",
    "section": "",
    "text": "代码\n# faithful 添加二维核密度估计 density 列\nlibrary(KernSmooth)\nden &lt;- bkde2D(x = faithful, bandwidth = c(0.7, 7), gridsize = c(51L, 51L))\nfaithful2d &lt;- expand.grid(eruptions = den$x1, waiting = den$x2) |&gt;\n  transform(density = as.vector(den$fhat))\n\nplot(faithful,\n  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,\n  xlim = c(0.5, 6.5),\n  ylim = c(35, 100)\n)\ntitle(xlab = \"喷发时间\", ylab = \"等待时间\", family = \"Noto Serif CJK SC\")\n\nplot(faithful,\n  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,\n  xlim = c(0.5, 6.5),\n  ylim = c(35, 100),\n  col = densCols(faithful,\n    bandwidth = c(0.7, 7),\n    nbin = c(51L, 51L), colramp = hcl.colors\n  )\n)\ntitle(xlab = \"喷发时间\", ylab = \"等待时间\", family = \"Noto Serif CJK SC\")\n\nplot(faithful,\n  pch = 20, panel.first = grid(), cex = 1, ann = FALSE,\n  xlim = c(0.5, 6.5),\n  ylim = c(35, 100),\n  col = densCols(faithful,\n    bandwidth = c(0.7, 7),\n    nbin = c(51L, 51L), colramp = hcl.colors\n  )\n)\ncontour(den$x1, den$x2, den$fhat, nlevels = 10, add = TRUE, family = \"sans\")\ntitle(xlab = \"喷发时间\", ylab = \"等待时间\", family = \"Noto Serif CJK SC\")\n\n# 散点添加颜色\nmkBreaks &lt;- function(u) u - diff(range(u)) / (length(u) - 1) / 2\n# faithful 划入网格内\nxbin &lt;- cut(faithful[, 1], mkBreaks(den$x1), labels = FALSE)\nybin &lt;- cut(faithful[, 2], mkBreaks(den$x2), labels = FALSE)\n# 网格对应的核密度估计值即为 faithful 对应的核密度估计值\nfaithful$dens &lt;- den$fhat[cbind(xbin, ybin)]\n# 若是 faithful 数据点没有划分，则置为 0 \nfaithful$dens[is.na(faithful$dens)] &lt;- 0\n\nlibrary(ggplot2)\nlibrary(ggnewscale)\nggplot() +\n  geom_point(\n    data = faithful, aes(x = eruptions, y = waiting, color = dens),\n    shape = 20, size = 2, show.legend = FALSE\n  ) +\n  scale_colour_viridis_c(option = \"D\") +\n  new_scale_color() +\n  geom_contour(data = faithful2d, aes(\n    x = eruptions, y = waiting,\n    z = density, colour = after_stat(level)\n  ), bins = 14, linewidth = 0.45, show.legend = FALSE) +\n  scale_colour_viridis_c(option = \"C\", direction = -1, begin = 0.2, end = 0.8) +\n  # colorspace::scale_color_continuous_sequential(palette = \"Grays\") +\n  scale_x_continuous(breaks = 1:6) +\n  scale_y_continuous(breaks = 10 * 4:10) +\n  coord_cartesian(xlim = c(0.5, 6.5), ylim = c(35, 100)) +\n  labs(x = \"喷发时间\", y = \"等待时间\", colour = \"密度\") +\n  theme_bw(base_size = 13) +\n  theme(\n    legend.title = element_text(family = \"Noto Serif CJK SC\"),\n    axis.title = element_text(family = \"Noto Serif CJK SC\"),\n    axis.title.x = element_text(\n      margin = margin(b = 0, l = 0, t = 20, r = 0)\n    ),\n    axis.title.y = element_text(\n      margin = margin(b = 0, l = 0, t = 0, r = 20)\n    ),\n    panel.border = element_rect(color = \"black\"),\n    panel.grid = element_blank(),\n    panel.grid.major = element_line(\n      color = \"lightgray\",\n      linetype = 3, linewidth = 0.5\n    ),\n    axis.ticks.length = unit(0.25, \"cm\"),\n    axis.text.x = element_text(\n      family = \"sans\", color = \"black\",\n      vjust = -1.5, size = rel(1.25)\n    ),\n    axis.text.y = element_text(\n      family = \"sans\", color = \"black\",\n      angle = 90, vjust = 1.5, hjust = 0.5,\n      size = rel(1.25)\n    )\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n(a) faithful 数据集的散点图\n\n\n\n\n\n\n\n\n\n\n\n(b) 点的亮暗表示核密度估计值的大小\n\n\n\n\n\n\n\n\n\n\n\n\n\n(c) 等高线表示核密度估计值\n\n\n\n\n\n\n\n\n\n\n\n(d) 等高线表示核密度估计值\n\n\n\n\n\n\n\n图 7.1: 二维核密度估计\n\n\n\n\n\n\n\n\n\n提示\n\n\n\n函数 bkde2D() 实现二维带窗宽的核密度估计（2D Binned Kernel Density Estimate），R 语言存在多个版本，grDevices 包的函数 densCols() 直接调用 KernSmooth 包的函数 bkde2D()，graphics 包的函数 smoothScatter() 与函数 densCols() 一样，内部也是调用 bkde2D() 函数，ggplot2 包的图层 geom_density_2d() 采用 MASS 包的函数 kde2d()，在算法实现上，MASS::kde2d() 与 KernSmooth::bkde2D() 不同，前者是二维核密度估计（Two-Dimensional Kernel Density Estimation）。Tarn Duong 的著作 《Multivariate Kernel Smoothing and Its Applications 》 (José. Chacón 2018) 对多元核平滑方法及其应用作了专门的论述，相关实现见书籍配套的 ks 包。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-china-household-sex",
    "href": "visualization-practice.html#sec-china-household-sex",
    "title": "7  探索实践",
    "section": "7.2 中国地区级男女性别比分布",
    "text": "7.2 中国地区级男女性别比分布\n图 7.2 (a) 展示 2020 年中国各省、自治区和直辖市分城市、镇和乡村的性别比数据。数据来自中国国家统计局发布的 2021 年统计年鉴，在数据量不太大的情况下，尽可能展示原始数据，可以捕捉到更加细致的差异。社会经济相关的数据常常显示有马太效应，对原始数据适当做一些变换有利于比较和展示数据，图 7.2 (b) 展示对数变换后的性别比数据的分布。大部分地区的性别比数据都在 100:100 左右，流动人口的性别比波动大很多。\n\n\n代码\nchina_household_sex &lt;- readRDS(file = \"data/china-household-sex-2020.rds\")\nggplot(data = china_household_sex, aes(x = `户口登记状况`, y = `男性` / `女性`)) +\n  geom_jitter(aes(color = `区域`), width = 0.3) +\n  theme_classic()\n\nggplot(data = china_household_sex, aes(x = `户口登记状况`, y = `男性` / `女性`)) +\n  geom_jitter(aes(color = `区域`), width = 0.3) +\n  scale_y_continuous(trans = \"log10\") +\n  theme_classic()\n\n\n\n\n\n\n\n\n\n\n\n(a) 原始性别比数据\n\n\n\n\n\n\n\n\n\n\n\n(b) 对数变换后的性别比数据\n\n\n\n\n\n\n图 7.2: 2020 年中国地区级男女性别比分布\n\n\n\n\n\n「住本乡、镇、街道，户口在本乡、镇、街道」土著和已获得当地户口的。性别比分布有明显的层次差异，性别比均值从大到小依次是城市、乡村、镇。城市里，男性略多于女性，镇里，男性明显少于女性，乡村里，男性略低于女性。\n「住本乡、镇、街道，户口待定」黑户或其它。性别比分布有明显的层次差异。同上。\n「住本乡、镇、街道，户口在外乡、镇、街道，离开户口登记地半年以上」流出人口，流出乡、镇、街道。城市、镇、乡村的性别比数据充分混合了，性别比分布没有明显的层次差异。\n「居住在港澳台或国外，户口在本乡、镇、街道」流出人口，流出国。同上。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-usa-mortality",
    "href": "visualization-practice.html#sec-usa-mortality",
    "title": "7  探索实践",
    "section": "7.3 美国历年各年龄死亡率变化",
    "text": "7.3 美国历年各年龄死亡率变化\n\n图 7.3 展示美国 1933-2020 年男性分年龄的死亡率数据1。图分上下两部分，上半部分展示死亡率原值随年龄的变化情况，以 ggplot2 默认的调色板给各个年份配色，下半部分展示死亡率对数变换后随年龄的变化情况，并以红、橙、黄、绿、青、蓝、紫构造彩虹式的调色板给各个年份配色。作图过程中，使用对数变换和调用彩虹式的调色板，帮助我们观察到更多的细节、层次。对数变换后，更加清晰地展示死亡率的变化，尤其是 0-20 岁之间的死亡率起伏变化。调用彩虹式的调色板后，约 20 年为一个阶段，每个阶段内呈现梯度变化，多个阶段体现层次性，更加清晰地展示死亡率曲线的变动趋势。透过层次看到 80 多年来，美国在医疗和公共卫生方面取得的显著改善。\n\n\n代码\nusa_mortality &lt;- readRDS(file = \"data/usa-mortality-2020.rds\")\nlibrary(patchwork)\np1 &lt;- ggplot(data = usa_mortality, aes(x = Age, y = Male, group = Year)) +\n  geom_vline(xintercept = \"100\", colour = \"gray\", lty = 2) +\n  geom_line(aes(color = Year), linewidth = 0.25) +\n  scale_x_discrete(\n    breaks = as.character(20 * 0:5),\n    labels = as.character(20 * 0:5)\n  ) +\n  theme_classic() \np2 &lt;- p1 +\n  labs(x = \"年龄\", y = \"死亡率\", color = \"年份\")\np3 &lt;- p1 +\n  scale_y_log10(labels = scales::label_log()) +\n  scale_colour_gradientn(colors = RColorBrewer::brewer.pal(name = \"Spectral\", n = 11)) +\n  labs(x = \"年龄\", y = \"死亡率（对数尺度）\", color = \"年份\")\np2 / p3\n\n\n\n\n\n\n\n\n图 7.3: 1933-2020 年美国男性死亡率曲线\n\n\n\n\n\n图 7.3 也展示了很多基础信息，出生时有很高的死亡率，出生后死亡率迅速下降，一直到10岁，死亡率才又开始回升，直到 20 岁，死亡率才回到出生时的水平。之后，在青年阶段死亡率缓慢增加，直至老年阶段达到很高的死亡率水平。相比于老年阶段，医疗水平的改善作用主要体现在婴儿、儿童、青少年阶段。\n图 7.3 还展示了一个潜在的数据质量问题，在 100 岁之后，死亡率波动程度明显在变大，这是因为高龄人数变得很少，即死亡率的分母变得很小，分子的细小波动会被放大，也因为同样的原因，100 岁以上的死亡率主要依赖模型估计，甚至出现死亡率大于 1 的罕见情况。因此，就对比医疗和公共卫生水平的变化而言，从数据的实际情况出发，100 岁以上的情况可以不参与比较。\n图 7.4 以年份为横轴，以年龄为纵轴绘制网格，网格内部根据男性死亡率数据填充颜色制作热力图，死亡率数据是对数尺度，颜色的变化和死亡率的变化关系同前，采用了相同的调色板。更加深入的分析和建模，详见 Marron 和 Dryden (2022) 的第一章。\n\n\n代码\nggplot(data = usa_mortality, aes(x = Year, y = Age, fill = Male)) +\n  scale_fill_gradientn(\n    colors = RColorBrewer::brewer.pal(name = \"Spectral\", n = 11),\n    trans = \"log10\", labels = scales::percent_format()\n  ) +\n  geom_tile(linewidth = 0.4) +\n  scale_y_discrete(\n    breaks = as.character(10 * 0:10),\n    labels = as.character(10 * 0:10),\n    expand = c(0, 0)\n  ) +\n  scale_x_continuous(\n    breaks = 1940 + 10 * 0:8,\n    labels = 1940 + 10 * 0:8,\n    expand = c(0, 0)\n  ) + \n  theme_classic() +\n  labs(x = \"年份\", y = \"年龄\", fill = \"死亡率\")\n\n\n\n\n\n\n\n\n图 7.4: 1933-2020 年美国男性死亡率热力图",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-virginia-deaths",
    "href": "visualization-practice.html#sec-virginia-deaths",
    "title": "7  探索实践",
    "section": "7.4 美国弗吉尼亚州城乡死亡率",
    "text": "7.4 美国弗吉尼亚州城乡死亡率\nVADeaths 数据来自 Base R 内置的 datasets 包，记录 1940 年美国弗吉尼亚州死亡率，如下表。\n\n\n\n\n表 7.1: 1940 年美国弗吉尼亚州死亡率\n\n\n\n\n\n\n\n农村男\n农村女\n城市男\n城市女\n\n\n\n\n50-54\n11.7\n8.7\n15.4\n8.4\n\n\n55-59\n18.1\n11.7\n24.3\n13.6\n\n\n60-64\n26.9\n20.3\n37.0\n19.3\n\n\n65-69\n41.0\n30.9\n54.6\n35.1\n\n\n70-74\n66.0\n54.3\n71.1\n50.0\n\n\n\n\n\n\n\n\n死亡率数据是按年龄段、城乡、性别分组统计的，这是一个三因素交叉统计表，表格中第1行第1列的数据表示 50-54 岁乡村男性的死亡率为 11.7 ‰ ，即在 50-54 岁乡村男性群体中，1000 个人中死亡 11.7 个，这是抽样调查出来的数字。下图分年龄段、城乡、性别展示弗吉尼亚州死亡率数据，从图例来看，突出的是各年龄段的对比，图主要传递的信息是各年龄段的死亡率差异。无论城市还是乡村，也无论男性还是女性，年龄越大死亡率越高，这完全是一个符合生物规律的客观事实，这是众人皆知的，算不上洞见。\n\n\n代码\ndat &lt;- transform(expand.grid(\n  site = c(\"乡村\", \"城镇\"), sex = c(\"男\", \"女\"), \n  age = ordered(c(\"50-54\", \"55-59\", \"60-64\", \"65-69\", \"70-74\"))\n), deaths = as.vector(t(VADeaths)) / 1000)\n\nlibrary(ggplot2)\n# (\\u2030) 表示千分号\nggplot(data = dat, aes(x = sex, y = deaths, fill = age)) +\n  geom_col(position = \"dodge2\") +\n  scale_y_continuous(labels = scales::label_percent(scale = 1000, suffix = \"\\u2030\")) +\n  scale_fill_brewer(palette = \"Spectral\") +\n  facet_wrap(~site, ncol = 1) +\n  theme_bw(base_size = 13) +\n  labs(x = \"性别\", y = \"死亡率\", fill = \"年龄\")\n\n\n\n\n\n\n\n\n图 7.5: 弗吉尼亚州各年龄段死亡率的对比\n\n\n\n\n\n将对比对象从年龄段转变为城乡，描述城乡差距在死亡率上的体现，是不是一下子更深刻了呢？城市降低各个年龄段的死亡率，暗示着城市的居住条件、医疗水平比乡村好，提高城市化率增加全民的寿命。严格来说，就这个粗糙的数据集不能如此快地下这个结论，但是，它暗示这个信息，同样也符合人们的常识。\n\n\n代码\nggplot(data = dat, aes(x = age, y = deaths, fill = site)) +\n  geom_col(position = \"dodge2\") +\n  scale_y_continuous(labels = scales::label_percent(scale = 1000, suffix = \"\\u2030\")) +\n  scale_fill_brewer(palette = \"Spectral\") +\n  facet_wrap(~sex, ncol = 1) +\n  theme_bw(base_size = 13) +\n  labs(x = \"年龄\", y = \"死亡率\", fill = \"城乡\")\n\n\n\n\n\n\n\n\n图 7.6: 弗吉尼亚州城乡死亡率的对比",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-diamonds-distr",
    "href": "visualization-practice.html#sec-diamonds-distr",
    "title": "7  探索实践",
    "section": "7.5 如何用图表示累积概率分布",
    "text": "7.5 如何用图表示累积概率分布\n不失一般性，考虑连续随机变量的条件分布和累积分布。不妨设随机变量 \\(x\\) 的概率分布函数和概率密度函数分别是 \\(F(x)\\) 和 \\(f(x)\\) 。已知概率分布函数和概率密度函数之间有如下关系。\n\\[\nF(x) = \\int_{-\\infty}^{x} f(t) \\mathrm{dt}\n\\]\ndiamonds 数据来自 ggplot2 包，记录了约 54000 颗钻石的价格、重量、切工、颜色、纯净度、尺寸等属性信息。图 7.7 展示这批不同切工的钻石随价格的分布，在这个示例中，如何表达累积分布？概率分布的密度曲线是根据直方图估计得来的，根据不同价格区间内钻石的数量占总钻石的比例估计概率。固定窗宽，即在同一价格区间内累积不同切工的钻石数量，得到累积概率，最后获得累积概率密度曲线，更多理论细节见数据可视化陷阱 (Pu 和 Kay 2020) 。\n\n\n代码\nlibrary(ggplot2)\nlibrary(patchwork)\np1 &lt;- ggplot(diamonds, aes(x = price, y = after_stat(density), fill = cut)) +\n  geom_density(position = \"stack\", colour = \"white\") +\n  scale_fill_brewer(palette = \"Spectral\") +\n  scale_y_continuous(\n    labels = expression(0, 5~\"·\"~10^-4, 10 ~ \"·\" ~ 10^-4, 15 ~ \"·\" ~ 10^-4),\n    breaks = c(0, 5, 10, 15) * 10^(-4)\n  ) +\n  theme_bw(base_family = \"Noto Serif CJK SC\") +\n  labs(x = \"价格\", y = \"概率密度\", fill = \"切工\", tag = \"坏\") +\n  theme(\n    axis.text.x = element_text(family = \"sans\", color = \"black\"),\n    axis.text.y = element_text(\n      family = \"sans\", color = \"black\",\n      angle = 90, vjust = 1.5, hjust = 0.5\n    ),\n    legend.text = element_text(family = \"sans\"),\n    plot.tag = element_text(family = \"Noto Serif CJK SC\", color = \"red\"),\n    plot.tag.position = \"topright\"\n  )\n\np2 &lt;- ggplot(diamonds, aes(x = price, y = after_stat(density * n), fill = cut)) +\n  geom_density(position = \"stack\", colour = \"white\") +\n  scale_fill_brewer(palette = \"Spectral\") +\n  theme_bw(base_family = \"Noto Serif CJK SC\") +\n  labs(x = \"价格\", y = \"概率质量\", fill = \"切工\", tag = \"好\") +\n  theme(\n    axis.text.x = element_text(family = \"sans\", color = \"black\"),\n    axis.text.y = element_text(\n      family = \"sans\", color = \"black\",\n      angle = 90, vjust = 1.5, hjust = 0.5\n    ),\n    legend.text = element_text(family = \"sans\"),\n    plot.tag = element_text(family = \"Noto Serif CJK SC\", color = \"black\"),\n    plot.tag.position = \"topright\"\n  )\n\np1 / p2\n\n\n\n\n\n\n\n\n图 7.7: 不同切工的钻石随价格的分布",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-confidence-belt",
    "href": "visualization-practice.html#sec-confidence-belt",
    "title": "7  探索实践",
    "section": "7.6 解释二项总体参数的置信带",
    "text": "7.6 解释二项总体参数的置信带\n0 和 1 是世界的原点，蕴含大道真意，从 0-1 分布也叫伯努利分布，独立同 0-1分布之和可以衍生出二项分布。在一定条件下，可以用泊松分布近似二项分布。根据中心极限定理，独立同二项分布的极限和与正态分布可以发生关系。在二项分布、正态分布的基础上，可以衍生出超几何分布、贝塔分布等等。本书多个地方以二项分布为例介绍基本统计概念和模型。\n在给定置信水平为 0.95，即 \\(\\alpha = 0.05\\)，固定样本量 \\(n = 10\\)，观测到的成功次数 \\(x\\) 可能为 \\(0,1,\\cdots,10\\)。对于给定的 \\(p\\)，不同 \\(x\\) 值出现的机率 \\(P(X = x)\\) 由 \\((p + q)^{10}\\) 二项展开式的项给出，这里 \\(q = 1-p\\)，即：\n\\[\nP(X = x) = \\binom{n}{x}p^x(1-p)^{n-x}\n\\tag{7.1}\\]\n在给定 \\(p = 0.1\\) 的情况下，求二项分布的上 \\(\\alpha/2 = 0.025\\) 分位点，尾项之和不应超过 \\(\\alpha/2\\)，最大的 \\(x\\) 值可有如下方程给出：\n\\[\n\\sum_{r = x}^{n}\\binom{n}{x}p^x(1-p)^{n-x} = \\frac{\\alpha}{2}\n\\tag{7.2}\\]\n在 R 语言中，函数 qbinom() 可以计算上述二项分布的上分位点 \\(x = 3\\)，即\n\nqbinom(0.025, size = 10, prob = 0.1, lower.tail = F)\n#&gt; [1] 3\n\n反过来，若已知上分位点为 \\(x = 3\\)，则概率为\n\\[\nP(X &gt; 3) = \\sum_{x &gt; 3}^{10}\\binom{10}{x}0.1^x*(1-0.1)^{10-x}\n\\tag{7.3}\\]\n在 R 语言中，函数 pbinom() 可以计算上述二项分布的上分位点对应的概率为 \\(0.0127952\\)。\n\npbinom(q = 3, size = 10, prob = 0.1, lower.tail = F)\n#&gt; [1] 0.0127952\n\n首先简单回顾一下置信区间，在学校和教科书里，有两种说法如下：\n\n\\(1-\\alpha\\) 的把握确定区间包含真值。\n区间包含真值的概率是 \\(1-\\alpha\\)。\n\n为什么要采纳第一种说法而不是第二种呢？这其实涉及到置信区间的定义问题，历史上 E. S. Pearson 和 R. A. Fisher 曾有过争论。和大多数以正态分布为例介绍参数的置信估计不同，下面以二项分布为例展开介绍。我们知道二项分布是 N 个伯努利分布的卷积，而伯努利分布又称为 0-1 分布，最形象的例子要数抛硬币了，反复投掷硬币，将正面朝上记为 1，反面朝上记为 0，记录正反面出现的次数，正面朝上的总次数又叫成功次数。\n1934 年 C. J. Clopper 和 E. S. Pearson 在给定置信水平 \\(1- \\alpha = 0.95\\) 和样本量 \\(n = 10\\) 的情况下，给出二项分布 \\(B(n, p)\\) 参数 \\(p\\) 的区间估计（即所谓的 Clopper-Pearson 精确区间估计）和置信带 (Clopper 和 Pearson 1934)，如 图 7.8 所示，横坐标为观测到的成功次数，纵坐标为参数 \\(p\\) 的置信限。具体来说，固定样本量为 10，假定观测到的成功次数为 2，在置信水平为 0.95 的情况下，Base R 内置的二项精确检验函数 binom.test()，可以获得参数 \\(p\\) 的精确区间估计为 \\((p_1, p_2) = (0.025, 0.556)\\)，即：\n\n# 精确二项检验 p = 0.2\nbinom.test(x = 2, n = 10, p = 0.2)\n#&gt; \n#&gt;  Exact binomial test\n#&gt; \n#&gt; data:  2 and 10\n#&gt; number of successes = 2, number of trials = 10, p-value = 1\n#&gt; alternative hypothesis: true probability of success is not equal to 0.2\n#&gt; 95 percent confidence interval:\n#&gt;  0.02521073 0.55609546\n#&gt; sample estimates:\n#&gt; probability of success \n#&gt;                    0.2\n\n值得注意，这个估计的区间与函数 binom.test() 中参数 p 的取值无关，也就是说，当 \\(p = 0.4\\)，区间估计结果是一样的，如下：\n\n# 精确二项检验 p = 0.4\nbinom.test(x = 2, n = 10, p = 0.4)\n#&gt; \n#&gt;  Exact binomial test\n#&gt; \n#&gt; data:  2 and 10\n#&gt; number of successes = 2, number of trials = 10, p-value =\n#&gt; 0.3335\n#&gt; alternative hypothesis: true probability of success is not equal to 0.4\n#&gt; 95 percent confidence interval:\n#&gt;  0.02521073 0.55609546\n#&gt; sample estimates:\n#&gt; probability of success \n#&gt;                    0.2\n\n由此，也可以看出区间估计与假设检验的一些关系。\n\n\n\n代码\nlibrary(rootSolve) # uniroot.all\noptions(digits = 4)\n# r 为上分位点\np_fun &lt;- function(p, r = 9) qbinom(0.025, size = 10, prob = p, lower.tail = F) - r # 上分位点\nl_fun &lt;- function(p, r = 9) qbinom(0.025, size = 10, prob = p, lower.tail = T) - r # 下分位点\n\n# 计算每个分位点对应的最小的概率 p\np &lt;- sapply(0:10, function(x) min(uniroot.all(p_fun, lower = 0, upper = 1, r = x)))\n\n# 计算每个分位点对应的最大的概率 l\nl &lt;- sapply(0:10, function(x) max(uniroot.all(l_fun, lower = 0, upper = 1, r = x)))\n\nplot(\n  x = seq(from = 0, to = 10, length.out = 11),\n  y = seq(from = 0, to = 1, length.out = 11),\n  type = \"n\", ann = FALSE, family = \"sans\", panel.first = grid()\n)\ntitle(xlab = \"成功次数\", ylab = \"置信限\", family = \"Noto Serif CJK SC\")\nlines(x = 0:10, y = p, type = \"s\") # 朝下的阶梯线\nlines(x = 0:10, y = p, type = \"l\") # 折线\n# points(x = 0:10, y = p, pch = 16, cex = .8) # 散点\n\n# abline(a = 0, b = 0.1, col = \"gray\", lwd = 2, lty = 2) # 添加对称线\ntext(x = 5, y = 0.5, label = \"置信带\", cex = 1.5, srt = 45, family = \"Noto Serif CJK SC\")\n# points(x = 5, y = 0.5, col = \"black\", pch = 16) # 中心对称点\n# points(x = 5, y = 0.5, col = \"black\", pch = 3) # 中心对称点\n\nlines(x = 0:10, y = l, type = \"S\") # 朝上的阶梯线\nlines(x = 0:10, y = l, type = \"l\") # 折线\n# points(x = 0:10, y = l, pch = 16, cex = .8) # 散点\n\npoints(x = c(2, 2), y = c(0.03, 0.55), pch = 8, col = \"black\")\ntext(x = 2, y = 0.55, labels = expression(p[2]), pos = 1)\ntext(x = 2, y = 0.03, labels = expression(p[1]), pos = 3)\n\n\n\n\n\n\n\n\n图 7.8: 二项分布参数的置信带",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-coverage-probability",
    "href": "visualization-practice.html#sec-coverage-probability",
    "title": "7  探索实践",
    "section": "7.7 解释置信区间及其覆盖概率",
    "text": "7.7 解释置信区间及其覆盖概率\n\n统计图形很重要的一个作用是解释统计概念，这就要求不拘泥于抽象的严格数学表达，借助数值模拟，可视化等手段帮助读者发散思维，加深理解复杂的逻辑概念，建立统计直觉，正如顾恺之所言「以形写神，形神兼备」。下面仅以二项分布为例讲讲区间估计及其覆盖概率。众所周知，在置信水平为 \\(1 - \\alpha\\) 的情况下，二项分布 \\(\\mathrm{Bin}(n,p)\\) 的参数 \\(p\\) （也叫成功概率）的 Wald 区间估计为\n\\[\n(\\hat{p} - Z_{1-\\alpha/2} \\sqrt{\\hat{p}*(1-\\hat{p})/n}, \\hat{p} + Z_{1-\\alpha/2} \\sqrt{\\hat{p}*(1-\\hat{p})/n})\n\\tag{7.4}\\]\n其中，\\(n\\) 为样本量，\\(Z_{1-\\alpha/2}\\) 为标准正态分布 \\(\\mathcal{N}(0,1)\\) 在 \\(1-\\alpha/2\\) 处的分位点。 \\(\\alpha\\) 一般取 0.05，进而 \\(Z_{1-\\alpha/2} \\approx 1.96\\)。用通俗的话说，有 \\(1 - \\alpha\\) 的把握确定参数真值 \\(p\\) 在该估计区间内。可见区间估计的意义是解决点估计可靠性问题，但是可靠性和精度往往不能兼得。统计上，通常的做法是先给定可靠性，去尽可能提升精度，即给定置信水平，使估计区间的长度尽可能短，这就涉及到区间估计的方法问题。\n下面通过数值模拟的方式辅助说明 Wald 和 Agresti-Coull 两种区间估计方法，现固定样本量 \\(n = 10\\) 或 \\(n = 100\\)，重复抽样 1000 次，将参数 \\(p\\) 以 0.01 的间隔离散化，从 0.01 取值到 0.99。已知给定参数 \\(p\\)，每次抽样都可以得到参数 \\(p\\) 的估计值 \\(\\hat{p}\\) 及其置信区间，1000 次的重复抽样可以计算出来 1000 个置信区间，每个区间要么覆盖真值，要么没有覆盖真值，覆盖的比例可以近似为覆盖概率。\n如 图 7.9 所示，从上往下分别代表 Wald、 Agresti-Coull、 Wilson 和 Clopper-Pearson 区间估计，纵坐标是覆盖概率，横坐标是参数 \\(p\\) 的真值，图中黑虚线表示置信水平 \\(1-\\alpha=0.95\\)，红、蓝点线分别表示样本量 \\(n=10\\) 和 \\(n=100\\) 的模拟情况。不难看出，Wald 区间估计方法在小样本情况下表现很差，覆盖概率很少能达到置信水平的，而 Agresti-Coull 区间估计在 Wald 基础上添加了修正后，情况得到显著改善。更多区间估计方法的详细比较见文献 Blyth 和 Hutchinson (1960);Brown, Cai, 和 DasGupta (2001);Geyer 和 Meeden (2005) 。\n\n\n代码\n# 计算覆盖概率\n# Wald 覆盖\ncoverage_wald &lt;- function(p = 0.1, n = 10, nsim = 1000) {\n  phats &lt;- rbinom(nsim, prob = p, size = n) / n\n  ll &lt;- phats - qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)\n  ul &lt;- phats + qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)\n  mean(ll &lt; p & ul &gt; p)\n}\n# Agresti-Coull 覆盖\ncoverage_agresti &lt;- function(p = 0.1, n = 10, nsim = 1000) {\n  phats &lt;- (rbinom(nsim, prob = p, size = n) + 2) / (n + 4)\n  ll &lt;- phats - qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)\n  ul &lt;- phats + qnorm(1 - 0.05 / 2) * sqrt(phats * (1 - phats) / n)\n  mean(ll &lt; p & ul &gt; p)\n}\n# Clopper and Pearson (1934)\n# 与 binom.test() 计算结果一致\ncoverage_clopper &lt;- function(p = 0.1, n = 10, nsim = 1000) {\n  nd &lt;- rbinom(nsim, prob = p, size = n)\n  ll &lt;- qbeta(p = 0.05 / 2, shape1 = nd, shape2 = n - nd + 1)\n  ul &lt;- qbeta(p = 1 - 0.05 / 2, shape1 = nd + 1, shape2 = n - nd)\n  mean(ll &lt; p & ul &gt; p)\n}\n# Wilson (1927)\n# 与 prop.test(correct = FALSE) 计算结果一致\ncoverage_wilson &lt;- function(p = 0.1, n = 10, nsim = 1000) {\n  phats &lt;- rbinom(nsim, prob = p, size = n) / n\n  lambda &lt;- qnorm(1 - 0.05 / 2)\n  ll &lt;- phats + lambda^2 / (2 * n) - lambda * sqrt(phats * (1 - phats) / n + lambda^2 / (4 * n^2))\n  ul &lt;- phats + lambda^2 / (2 * n) + lambda * sqrt(phats * (1 - phats) / n + lambda^2 / (4 * n^2))\n  mean(ll / (1 + lambda^2 / n) &lt; p & ul / (1 + lambda^2 / n) &gt; p)\n}\n\nsim_dat &lt;- transform(expand.grid(\n  p = seq(0.01, 0.99, by = 0.01),\n  n = c(10, 100),\n  nsim = 1000,\n  methods = c(\"Wald\", \"Agresti-Coull\", \"Wilson\", \"Clopper-Pearson\")\n), prob = ifelse(methods == \"Wald\",\n  Vectorize(coverage_wald)(p = p, n = n, nsim = nsim),\n  ifelse(methods == \"Agresti-Coull\",\n    Vectorize(coverage_agresti)(p = p, n = n, nsim = nsim),\n    ifelse(methods == \"Wilson\",\n      Vectorize(coverage_wilson)(p = p, n = n, nsim = nsim),\n      Vectorize(coverage_clopper)(p = p, n = n, nsim = nsim)\n    )\n  )\n), nsample = ifelse(n == 10, \"n=10\", \"n=100\"))\n\nggplot(data = sim_dat, aes(x = p, y = prob, color = nsample)) +\n  geom_hline(yintercept = 0.95, linetype = 2, \n             linewidth = 1, color = \"gray60\") +\n  geom_point() +\n  geom_path() +\n  # annotate(geom = \"text\", x = 0, y = 0.95, label = \"0.950\",\n  #          fontface = \"bold\", hjust = 2, size = 3.5) +\n  # scale_color_grey() +\n  scale_color_brewer(palette = \"Set1\") +\n  facet_wrap(facets = ~methods, ncol = 1, scales = \"free_y\") +\n  labs(x = \"成功概率\", y = \"覆盖概率\", color = \"样本量\") +\n  theme_bw(base_size = 13, base_family = \"sans\") +\n  theme(title = element_text(family = \"Noto Serif CJK SC\")) + \n  coord_cartesian(clip = 'off')\n\n\n\n\n\n\n\n\n图 7.9: 二项分布参数的几种区间估计：覆盖概率随成功概率的变化\n\n\n\n\n\n通过 图 7.9 一看就明白了几种区间估计方法的优劣，以及为什么软件普遍默认采用 Wilson 估计方法？因为它又稳定又准确。 Wilson 区间估计用的更加广泛的，Base R 内置的比例检验函数 prop.test() 在不启用 Yates 修正时，就是用该方法获得比例 \\(p\\) 的区间估计 (Wilson 1927)。Clopper-Pearson 区间估计特别适合小样本情形，它是精确区间估计方法，Base R 内置的二项比例检验函数 binom.test() 就是用该方法获得比例 \\(p\\) 的区间估计(Clopper 和 Pearson 1934)。\n\n\n\n\n\n\n提示\n\n\n\n请读者再思考两个问题： 图 7.9 为什么呈现对称的形式，泊松分布会和二项分布有类似的现象吗？如果有的话，连续分布，如正态分布和指数分布也会有吗？",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#sec-exercise-practice",
    "href": "visualization-practice.html#sec-exercise-practice",
    "title": "7  探索实践",
    "section": "7.8 习题",
    "text": "7.8 习题\n\n1888 年，瑞士开始进入一个人口转变的阶段，从发展中国家的高出生率开始下滑。分析生育率和经济指标的关系。数据集 swiss 记录了 1888 年瑞士 47 个说法语的省份的生育率和社会经济指标数据。Fertility（生育率，采用常见的标准生育率统计口径）、Agriculture（男性从事农业生产的比例）、Examination（应征者在军队考试中获得最高等级的比例）、Education（应征者有小学以上教育水平的比例）、Catholic（信仰天主教的比例）、Infant.Mortality（婴儿死亡率，仅考虑出生一年内死亡），各个指标都统一标准化为百分比的形式。其中，Examination 和 Education 是 1887 年、1888 年和 1889 年的平均值。瑞士 182 个地区 1888 年及其它年份的数据可从网站获得。\n\n\n\n\n\nBlyth, Colin R., 和 David W. Hutchinson. 1960. 《Table of Neyman-Shortest Unbiased Confidence Intervals for the Binomial Parameter》. Biometrika 47 (3/4): 381–91. https://www.jstor.org/stable/2333308.\n\n\nBrown, Lawrence D., T. Tony Cai, 和 Anirban DasGupta. 2001. 《Interval Estimation for a Binomial Proportion》. Statistical Science, 期 2: 101–33. https://projecteuclid.org/euclid.ss/1009213286.\n\n\nClopper, C. J., 和 E. S. Pearson. 1934. 《The Use of Confidence or Fiducial Limits Illustrated In The Case of The Binomial》. Biometrika 26 (4): 404–13. https://doi.org/10.1093/biomet/26.4.404.\n\n\nGeyer, Charles J., 和 Glen D. Meeden. 2005. 《Fuzzy and Randomized Confidence Intervals and P-Values》. Statistical Science 20 (4): 358–66. https://www.jstor.org/stable/20061193.\n\n\nJosé. Chacón, Tarn Duong. 2018. Multivariate Kernel Smoothing and Its Applications. Boca Raton, Florida: Chapman; Hall/CRC. https://www.mvstat.net/mvksa/.\n\n\nMarron, J. S., 和 Ian L. Dryden. 2022. Object Oriented Data Analysis. 1st 本. Boca Raton, Florida: Chapman; Hall/CRC.\n\n\nPu, Xiaoying, 和 Matthew Kay. 2020. 《A Probabilistic Grammar of Graphics》. 收入 Proceedings of the 2020 CHI Conference on Human Factors in Computing Systems, 1–13. ACM. https://doi.org/10.1145/3313831.3376466.\n\n\nWand, M. P., 和 M. C. Jones. 1995. Kernel Smoothing. 1st 本. Boca Raton, Florida: Chapman; Hall/CRC. http://matt-wand.utsacademics.info/webWJbook/.\n\n\nWilson, Edwin B. 1927. 《Probable inference, the law of succession, and statistical inference》. Journal of the American Statistical Association 22 (158): 209–12. https://doi.org/10.1080/01621459.1927.10502953.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "visualization-practice.html#footnotes",
    "href": "visualization-practice.html#footnotes",
    "title": "7  探索实践",
    "section": "",
    "text": "数据来自德国马克斯普朗克人口研究所、美国加州大学伯克利分校、法国人口研究所共同建立的人类死亡率数据库 (https://www.mortality.org/)。↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>探索实践</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "参考文献",
    "section": "",
    "text": "Antony Unwin, Heike Hofmann, Martin Theus. 2006. Graphics of Large\nDatasets: Visualizing a Million. New York, NY: Springer-Verlag.\n\n\nArnold, Jeffrey B. 2021. ggthemes: Extra\nThemes, Scales and Geoms for ggplot2.\nhttps://CRAN.R-project.org/package=ggthemes.\n\n\nAttali, Dean, and Christopher Baker. 2022. ggExtra: Add Marginal Histograms to ggplot2, and More ggplot2 Enhancements. https://CRAN.R-project.org/package=ggExtra.\n\n\nBai, H., L. Wang, W. Pan, and M. Frey. 2009. “Measuring\nMathematics Anxiety: Psychometric Analysis of a Bidimensional Affective\nScale.” Journal of Instructional Psychology 36 (3):\n185–93.\n\n\nBion, Ricardo. 2018. ggtech: ggplot2 Tech Themes and Scales.\n\n\nBishop, Christopher. 2006. Pattern Recognition and Machine\nLearning. New York, NY: Springer. https://www.microsoft.com/en-us/research/people/cmbishop/prml-book/.\n\n\nBlyth, Colin R., and David W. Hutchinson. 1960. “Table of\nNeyman-Shortest Unbiased Confidence Intervals for the Binomial\nParameter.” Biometrika 47 (3/4): 381–91. https://www.jstor.org/stable/2333308.\n\n\nBrown, Lawrence D., T. Tony Cai, and Anirban DasGupta. 2001.\n“Interval Estimation for a Binomial Proportion.”\nStatistical Science, no. 2: 101–33. https://projecteuclid.org/euclid.ss/1009213286.\n\n\nChang, Winston. 2018. R Graphics Cookbook: Practical\nRecipes for Visualizing Data. 2nd ed. Sebastopol, California:\nO’Reilly Media, Inc. https://r-graphics.org/.\n\n\nChen, Chun-houh, Wolfgang Härdle, and Antony Unwin. 2008. Handbook\nof Data Visualization. Berlin, Heidelberg: Springer-Verlag.\n\n\nClopper, C. J., and E. S. Pearson. 1934. “The Use of Confidence or\nFiducial Limits Illustrated in the Case of the Binomial.”\nBiometrika 26 (4): 404–13. https://doi.org/10.1093/biomet/26.4.404.\n\n\nConstantin, Ahlmann-Eltze, and Indrajeet Patil. 2021. “ggsignif: R Package for Displaying Significance\nBrackets for ggplot2.”\nPsyArxiv. https://doi.org/10.31234/osf.io/7awm6.\n\n\nFeng, Dai, and Luke Tierney. 2008. “Computing and Displaying\nIsosurfaces in R.” Journal of Statistical\nSoftware 28 (1). https://doi.org/10.18637/jss.v028.i01.\n\n\nGarnier, Simon, Ross, Noam, Rudis, Robert, Camargo, et al. 2021.\nviridis: Colorblind-Friendly Color Maps\nfor R. https://doi.org/10.5281/zenodo.4679424.\n\n\nGeyer, Charles J., and Glen D. Meeden. 2005. “Fuzzy and Randomized\nConfidence Intervals and p-Values.” Statistical Science\n20 (4): 358–66. https://www.jstor.org/stable/20061193.\n\n\nGoodfellow, Ian, Yoshua Bengio, and Aaron Courville. 2016. Deep\nLearning. MIT Press. https://www.deeplearningbook.org/.\n\n\nGross, Calli, and Philipp Ottolinger. 2016. ggThemeAssist: Add-in to Customize ggplot2 Themes. https://CRAN.R-project.org/package=ggThemeAssist.\n\n\nHawkins, Oliver. 2022. pilot: A Minimal\nggplot2 Theme with an Accessible Discrete\nColor Palette. https://github.com/olihawkins/pilot.\n\n\nHealy, Kieran. 2019. Data Visualization: A Practical\nIntroduction. Princeton, New Jersey: Princeton University Press. https://socviz.co/.\n\n\nHeyde, C. C., E. Seneta, P. Crépel, S. E. Fienberg, and J. Gani. 2001.\nStatisticians of the Centuries. New York, NY: Springer-Verlag.\nhttps://doi.org/10.1007/978-1-4613-0179-0.\n\n\nHvitfeldt, Emil. 2021. paletteer:\nComprehensive Collection of Color Palettes. https://github.com/EmilHvitfeldt/paletteer.\n\n\nJohnson, Norman L., and Samuel Kotz, eds. 1997. Leading\nPersonalities in Statistical Sciences: From the Seventeenth Century to\nthe Present. John Wiley & Sons, Inc. https://doi.org/10.1002/9781118150719.\n\n\nJosé. Chacón, Tarn Duong. 2018. Multivariate Kernel Smoothing and\nIts Applications. Boca Raton, Florida: Chapman; Hall/CRC. https://www.mvstat.net/mvksa/.\n\n\nKarambelkar, Bhaskar. 2016. colormap:\nColor Palettes Using Colormaps Node Module. https://CRAN.R-project.org/package=colormap.\n\n\nKassambara, Alboukadel. 2022. ggpubr:\nggplot2 Based Publication Ready Plots.\nhttps://CRAN.R-project.org/package=ggpubr.\n\n\nKay, Matthew. 2022. ggdist:\nVisualizations of Distributions and Uncertainty. https://doi.org/10.5281/zenodo.3879620.\n\n\nKothari, Aditya. 2022. ggTimeSeries:\nTime Series Visualisations Using the Grammar of Graphics. https://CRAN.R-project.org/package=ggTimeSeries.\n\n\nLamigueiro, Oscar Perpinan. 2018. Displaying Time Series, Spatial,\nand Space-Time Data with R. 2nd ed. Boca Raton,\nFlorida: Chapman; Hall/CRC. https://oscarperpinan.github.io/bookvis/.\n\n\nLehmann, Erich L. 2011. Fisher, Neyman, and the Creation of\nClassical Statistics. Springer New York. https://doi.org/10.1007/978-1-4419-9500-1.\n\n\nLemon, Jim. 2006. “plotrix: A Package\nin the Red Light District of R.” R-News 6\n(4): 8–12.\n\n\nLigges, Uwe, and Martin Mächler. 2003. “scatterplot3d: An R Package for\nVisualizing Multivariate Data.” Journal of Statistical\nSoftware 8 (11): 1–20. https://doi.org/10.18637/jss.v008.i11.\n\n\nLikert, Rensis. 1932. “A Technique for the Measurement of\nAttitudes.” Archives of Psychology 142 (1): 1–55.\n\n\nLin, Xihong, Christian Genest, David L. Banks, Geert Molenberghs, David\nW. Scott, and Jane-Ling Wang, eds. 2014. Past, Present, and Future\nof Statistical Science. Boca Raton, Florida: Chapman; Hall/CRC.\n\n\nMarron, J. S., and Ian L. Dryden. 2022. Object Oriented Data\nAnalysis. 1st ed. Boca Raton, Florida: Chapman; Hall/CRC.\n\n\nMcGill, Tukey, R., and W. A. Larsen. 1978. “Variations of Box\nPlots.” The American Statistician 32 (1): 12–16. https://www.jstor.org/stable/2683468.\n\n\nMohri, Mehryar, Afshin Rostamizadeh, and Ameet Talwalkar. 2018.\nFoundations of Machine Learning. 2nd ed. Cambridge,\nMassachusetts: MIT Press. https://cs.nyu.edu/~mohri/mlbook/.\n\n\nMurrell, Paul. 2018. R Graphics. 3rd ed. Boca\nRaton, Florida: Chapman; Hall/CRC. https://www.stat.auckland.ac.nz/~paul/RG3e/.\n\n\nNeitmann, Thomas. 2020. ggcharts:\nShorten the Distance from Data Visualization Idea to Actual Plot.\nhttps://CRAN.R-project.org/package=ggcharts.\n\n\nNeuwirth, Erich. 2022. RColorBrewer:\nColorBrewer Palettes. https://CRAN.R-project.org/package=RColorBrewer.\n\n\nOtto, James, and David Kahle. 2023. “ggdensity: Improved Bivariate Density\nVisualization in R.” The R Journal 15:\n220–36. https://doi.org/10.32614/RJ-2023-048.\n\n\nPatil, Indrajeet. 2021. “Visualizations with\nstatistical details: The ggstatsplot\napproach.” Journal of Open Source\nSoftware 6 (61): 3167. https://doi.org/10.21105/joss.03167.\n\n\nPedersen, Thomas Lin, and Fabio Crameri. 2022. scico: Colour Palettes Based on the Scientific\nColour-Maps. https://CRAN.R-project.org/package=scico.\n\n\nPu, Xiaoying, and Matthew Kay. 2020. “A Probabilistic Grammar of\nGraphics.” In Proceedings of the 2020 CHI\nConference on Human Factors in Computing Systems, 1–13. ACM. https://doi.org/10.1145/3313831.3376466.\n\n\nRahlf, Thomas. 2019. Data Visualisation with R.\n2nd ed. New York, NY: Springer Nature. https://www.datavisualisation-r.com/.\n\n\nReid, Constance. 1982. Neyman. New York, NY: Springer-Verlag.\nhttps://doi.org/10.1007/978-1-4612-5754-7.\n\n\n———. 1987. 耐曼—现代统计学家. Edited by 袁运开, 张瑞琨, and\n应兴国. Translated by 姚慕生等. 上海: 上海翻译出版公司.\n\n\nSalsburg, David. 2001. The Lady Tasting Tea: How Statistics\nRevolutionized Science in the Twentieth Century. New York, NY: W.\nH. Freeman; Company.\n\n\nSarkar, Deepayan. 2008b. lattice:\nMultivariate Data Visualization with R. New York:\nSpringer. http://lmdvr.r-forge.r-project.org.\n\n\n———. 2008a. lattice: Multivariate Data\nVisualization with R. New York: Springer. http://lmdvr.r-forge.r-project.org.\n\n\nSidiropoulos, Nikos, Sina Hadi Sohi, Thomas Lin Pedersen, Bo Torben\nPorse, Ole Winther, Nicolas Rapin, and Frederik Otzen Bagger. 2018.\n“SinaPlot: An Enhanced Chart for Simple and Truthful\nRepresentation of Single Observations over Multiple Classes.”\nJournal of Computational and Graphical Statistics 27 (3):\n673–76. https://doi.org/10.1080/10618600.2017.1366914.\n\n\nSievert, Carson. 2020. Interactive Web-Based Data Visualization with\nR, plotly, and shiny. 1st ed. Boca Raton, Florida: Chapman;\nHall/CRC. https://plotly-r.com/.\n\n\nSlowikowski, Kamil. 2021. ggrepel:\nAutomatically Position Non-Overlapping Text Labels with ggplot2. https://CRAN.R-project.org/package=ggrepel.\n\n\nSoetaert, Karline. 2021. plot3D:\nPlotting Multi-Dimensional Data. https://CRAN.R-project.org/package=plot3D.\n\n\nStylianou, Nassos, Will Dahlgreen, Robert Cuffe, Tom Calver, and Ransome\nMpini. 2022. bbplot: Making ggplot2 Graphics in BBC NEWS\nStyle.\n\n\nTobin, Ciaran. 2020. ggthemr: Themes for\nggplot2.\n\n\nWand, M. P., and M. C. Jones. 1995. Kernel Smoothing. 1st ed.\nBoca Raton, Florida: Chapman; Hall/CRC. http://matt-wand.utsacademics.info/webWJbook/.\n\n\nWickham, Charlotte. 2018. munsell:\nUtilities for Using Munsell Colours. https://CRAN.R-project.org/package=munsell.\n\n\nWickham, Hadley. 2016b. ggplot2: Elegant\nGraphics for Data Analysis. 2nd ed. New York: Springer-Verlag. https://ggplot2-book.org/.\n\n\n———. 2016a. ggplot2: Elegant Graphics\nfor Data Analysis. 2nd ed. Springer-Verlag New York. https://ggplot2.tidyverse.org.\n\n\nWickham, Hadley, and Garrett Grolemund. 2017. R for\nData Science. 1st ed. Sebastopol, California: O’Reilly Media, Inc.\nhttps://r4ds.had.co.nz/.\n\n\nWickham, Hadley, and Dana Seidel. 2022. scales: Scale Functions for Visualization. https://CRAN.R-project.org/package=scales.\n\n\nWilke, Claus O. 2019. Fundamentals of Data Visualization: A Primer\non Making Informative and Compelling Figures. Sebastopol,\nCalifornia: O’Reilly Media, Inc. https://clauswilke.com/dataviz/.\n\n\n———. 2020. ggtext: Improved Text\nRendering Support for ggplot2. https://CRAN.R-project.org/package=ggtext.\n\n\nWilson, Edwin B. 1927. “Probable Inference, the Law of Succession,\nand Statistical Inference.” Journal of the American\nStatistical Association 22 (158): 209–12. https://doi.org/10.1080/01621459.1927.10502953.\n\n\nXiao, Nan. 2018. ggsci: Scientific\nJournal and Sci-Fi Themed Color Palettes for ggplot2. https://CRAN.R-project.org/package=ggsci.\n\n\nYu, Guangchuang. 2022. ggimage: Use\nImage in ggplot2. https://CRAN.R-project.org/package=ggimage.\n\n\nYutani, Hiroaki. 2022. string2path:\nRendering Font into data.frame. https://CRAN.R-project.org/package=string2path.\n\n\nZeileis, Achim, Jason C. Fisher, Kurt Hornik, Ross Ihaka, Claire D.\nMcWhite, Paul Murrell, Reto Stauffer, and Claus O. Wilke. 2020.\n“colorspace: A Toolbox for\nManipulating and Assessing Colors and Palettes.” Journal of\nStatistical Software 96 (1): 1–49. https://doi.org/10.18637/jss.v096.i01.\n\n\n吴建福. 1986. “从历史发展看中国统计发展方向.”\n数理统计与管理, no. 1: 1–7. https://doi.org/10.13860/j.cnki.sltj.1986.01.001.\n\n\n———. 2011. “统计学者的工作及风范：灵感、抱负、雄心.”\n应用概率统计, no. 2: 113–23.\n\n\n方开泰. 2016. 漫漫修远攻算路—方开泰自述. 第一版. 长沙:\n湖南教育出版社.\n\n\n许宝騄先生纪念文集编委会编. 2010.\n道德文章垂范人间：纪念许宝騄先生百年诞辰. 第一版. 北京:\n北京大学出版社.\n\n\n赵鹏, 谢益辉, and 黄湘云. 2021. 现代统计图形. 北京:\n人民邮电出版社. https://bookdown.org/xiangyun/msg.\n\n\n陈为, 沈则潜, and 陶煜波. 2019. 数据可视化. 第二版. 北京:\n电子工业出版社. https://zjuvag.org/.\n\n\n陈善林, and 张浙. 1987. 统计发展史. 上海: 立信会计图书用品社.\n\n\n陈希孺. 2000. 数理统计学简史. 第一版. 长沙: 湖南教育出版社.\n\n\n陈希孺, and 苏淳. 2016. 统计学漫话. 第二版. 合肥, 安徽:\n中国科学技术大学出版社.",
    "crumbs": [
      "参考文献"
    ]
  }
]